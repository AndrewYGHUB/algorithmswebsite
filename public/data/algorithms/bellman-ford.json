{
  "slug": "bellman-ford",
  "name": "Bellman Ford",
  "categories": [
    "graphs"
  ],
  "body": {
    "en": "<h4>Problem Statement</h4>\n<p>Given a weighted directed graph G(V,E) and a source vertex s ∈ V, determine for each vertex v ∈ V the shortest path between s and v.</p>\n<h4>Approach</h4>\n<ul>\n<li>Initialize the distance from the source to all vertices as infinite.</li>\n<li>Initialize the distance to itself as 0.</li>\n<li>Create an array dist[] of size |V| with all values as infinite except dist[s].</li>\n<li>Repeat the following |V| - 1 times. Where |V| is number of vertices.</li>\n<li>Create another loop to go through each edge (u, v) in E and do the following:\n<ol>\n<li>dist[v] = minimum(dist[v], dist[u] + weight of edge).</li>\n</ol>\n</li>\n<li>Lastly iterate through all edges on last time to make sure there are no negatively weighted cycles.</li>\n</ul>\n<h4>Time Complexity</h4>\n<p>O(VE)</p>\n<h4>Space Complexity</h4>\n<p>O(V^2)</p>\n<h4>Founder's Name</h4>\n<ul>\n<li>Richard Bellman &#x26; Lester Ford, Jr.</li>\n</ul>\n<h4>Example</h4>\n<pre><code class=\"hljs language-json\">    # of vertices in graph = <span class=\"hljs-number\">5</span> [A, B, C, D, E]\n    # of edges in graph = <span class=\"hljs-number\">8</span> \n\n    edges  [A->B, A->C, B->C, B->D, B->E, D->C, D->B, E->D]\n    weight [ <span class=\"hljs-number\">-1</span>,    <span class=\"hljs-number\">4</span>,    <span class=\"hljs-number\">3</span>,    <span class=\"hljs-number\">2</span>,    <span class=\"hljs-number\">2</span>,    <span class=\"hljs-number\">5</span>,    <span class=\"hljs-number\">1</span>,   <span class=\"hljs-number\">-4</span> ]\n    source [  A,    A,    B,    B,    B,    D,    D,    E ]\n\n\n\n    <span class=\"hljs-comment\">// edge A->B </span>\n    graph->edge[<span class=\"hljs-number\">0</span>].src = A \n    graph->edge[<span class=\"hljs-number\">0</span>].dest = B \n    graph->edge[<span class=\"hljs-number\">0</span>].weight = <span class=\"hljs-number\">-1</span> \n  \n    <span class=\"hljs-comment\">// edge A->C </span>\n    graph->edge[<span class=\"hljs-number\">1</span>].src = A \n    graph->edge[<span class=\"hljs-number\">1</span>].dest = C \n    graph->edge[<span class=\"hljs-number\">1</span>].weight = <span class=\"hljs-number\">4</span> \n  \n    <span class=\"hljs-comment\">// edge B->C </span>\n    graph->edge[<span class=\"hljs-number\">2</span>].src = B \n    graph->edge[<span class=\"hljs-number\">2</span>].dest = C \n    graph->edge[<span class=\"hljs-number\">2</span>].weight = <span class=\"hljs-number\">3</span> \n  \n    <span class=\"hljs-comment\">// edge B->D </span>\n    graph->edge[<span class=\"hljs-number\">3</span>].src = B \n    graph->edge[<span class=\"hljs-number\">3</span>].dest = D \n    graph->edge[<span class=\"hljs-number\">3</span>].weight = <span class=\"hljs-number\">2</span> \n  \n    <span class=\"hljs-comment\">// edge B->E </span>\n    graph->edge[<span class=\"hljs-number\">4</span>].src = B \n    graph->edge[<span class=\"hljs-number\">4</span>].dest = E \n    graph->edge[<span class=\"hljs-number\">4</span>].weight = <span class=\"hljs-number\">2</span> \n  \n    <span class=\"hljs-comment\">// edge D->C </span>\n    graph->edge[<span class=\"hljs-number\">5</span>].src = D\n    graph->edge[<span class=\"hljs-number\">5</span>].dest = C \n    graph->edge[<span class=\"hljs-number\">5</span>].weight = <span class=\"hljs-number\">5</span> \n  \n    <span class=\"hljs-comment\">// edge D->B </span>\n    graph->edge[<span class=\"hljs-number\">6</span>].src = D\n    graph->edge[<span class=\"hljs-number\">6</span>].dest = B \n    graph->edge[<span class=\"hljs-number\">6</span>].weight = <span class=\"hljs-number\">1</span> \n  \n    <span class=\"hljs-comment\">// edge E->D </span>\n    graph->edge[<span class=\"hljs-number\">7</span>].src = E\n    graph->edge[<span class=\"hljs-number\">7</span>].dest = D \n    graph->edge[<span class=\"hljs-number\">7</span>].weight = <span class=\"hljs-number\">-3</span>\n\n    for source = A\n\n    Vertex   Distance from Source\n\tA                <span class=\"hljs-number\">0</span>\t\t\t\tA->A\n\tB                <span class=\"hljs-number\">-1</span>\t\t\t\tA->B\n\tC                <span class=\"hljs-number\">2</span> \t\t\t\tA->B->C = <span class=\"hljs-number\">-1</span> + <span class=\"hljs-number\">3</span>\n\tD                <span class=\"hljs-number\">-2</span>\t\t\t\tA->B->E->D = <span class=\"hljs-number\">-1</span> + <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">-3</span>\n\tE                <span class=\"hljs-number\">1</span>\t\t\t\tA->B->E = <span class=\"hljs-number\">-1</span> + <span class=\"hljs-number\">2</span>\n</code></pre>\n<h4>Code Implementation Links</h4>\n<ul>\n<li><a href=\"https://github.com/TheAlgorithms/Java/blob/master/DataStructures/Graphs/BellmanFord.java\">Java</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/dynamic_programming/bellman_ford.cpp\">C++</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/Python/blob/master/graphs/bellman_ford.py\">Python</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/C/blob/master/data_structures/graphs/bellman_ford.c\">C</a></li>\n</ul>\n<h4>Video Explanation</h4>\n<p><a href=\"https://www.youtube.com/watch?v=hxMWBBCpR6A\">A video explaining the Bellman-Ford Algorithm</a></p>\n<h4>Others</h4>\n<p>Sources Used:</p>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/\">https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\">https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm</a></li>\n</ul>",
    "es": "<h4>Declaración de problema</h4>\n<p>Dado un gráfico dirigido ponderado <code>G(V,E)</code> y un vértice de origen s ∈ V, determine para cada <code>v v v ∈ V</code> el trayecto más corto entre <code>s</code> y <code>v</code>.</p>\n<h4>Enfoque</h4>\n<ul>\n<li>Inicializar la distancia de la fuente a todos los vértices como infinito.</li>\n<li>Inicializar la distancia a sí mismo como 0.</li>\n<li>Crear una matriz dist[] de tamaño | V| con todos los valores como infinitos excepto dist[s].</li>\n<li>Repita los siguientes |V| - 1 vez, dónde |V| es el número de vértices.</li>\n<li>Crear otro bucle para ir a través de cada borde <code>(u, v)</code> en E y hacer lo siguiente:\n<ol>\n<li><code>dist[v] = minimum(dist[v], dist[u] + peso de borde</code>.</li>\n</ol>\n</li>\n<li>Por último, iterar a través de todos los bordes en la última vez, para asegurarse de que no hay ciclos ponderados negativamente.</li>\n</ul>\n<h4>Complejidad temporal</h4>\n<p><code>O(VE)</code></p>\n<h4>Complejidad espacial</h4>\n<p><code>O(V^2)</code></p>\n<h4>Nombre del Fundador</h4>\n<ul>\n<li>Richard Bellman &#x26; Lester Ford, Jr.</li>\n</ul>\n<h4>Ejemplo</h4>\n<pre><code class=\"hljs language-markdown\"><span class=\"hljs-section\"># de vértices en el gráfico = 5 [A, B, C, D, E]</span>\n<span class=\"hljs-section\"># de bordes en gráfico = 8</span>\n\nbordes [A->B, A->C, B->C, B->D, B->E, D->C, D->B, E->D]\npeso [ -1, 4, 3, 2, 2, 5, 1, -4 ]\nfuente [ A, A, B, B, B, D, D, E ]\n\nborde A->B\ngraph->edge[0].src = A\ngraph->edge[0].dest = B\ngraph->edge[0].weight = -1\n\nborde A->C\ngraph->edge[1] .src = A\ngraph->edge[1].dest = C\ngráfico->edge[1] .weight = 4\n\nborde B->C\ngraph->edge[2].src = B\ngraph->edge[2].dest = C\ngráfico->edge[2].peso = 3\n\nborde B->D\ngráfico->edge[3] .src = B\ngraph->edge[3] .dest = D\ngráfico->edge[3] .peso = 2\n\nborde B->E\ngraph->edge[4].src = B\ngraph->edge[4].dest = E\ngráfico->edge[4].peso = 2\n\nborde D->C\ngraph->edge[5].src = D\ngraph->edge[5].dest = C\ngráfico->edge[5].peso = 5\n\nborde D->B\ngraph->edge[6] .src = D\ngraph->edge[6].dest = B\ngráfico->edge[6].weight = 1\n\nborde E->D\ngraph->edge[7] .src = E\ngraph->edge[7].dest = D\ngráfico->edge[7].weight = -3\n\npara la fuente = A\n\nDistancia de vértice desde la fuente\nA 0 A->A\nB -1 A->B\nC 2 A->B->C = -1 + 3\nD -2 A->B->E->D = -1 + 2 + -3\nE 1 A->B->E = -1 + 2\n</code></pre>\n<h4>Enlaces de implementación de código</h4>\n<ul>\n<li><a href=\"https://github.com/TheAlgorithms/Java/blob/master/DataStructures/Graphs/BellmanFord.java\">Java</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/C-Plus-Plus/blob/master/Dynamic%20Programming/Bellman-Ford.cpp\">C++</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/Python/blob/master/data_structures/graph/bellman_ford.py\">Python</a></li>\n<li><a href=\"https://github.com/TheAlgorithms/C/blob/master/data_structures/graphs/Bellman-Ford.c\">C</a></li>\n</ul>\n<h4>Explicación de vídeo</h4>\n<p><a href=\"https://www.youtube.com/watch?v=hxMWBBCpR6A\">Un video explicando el algoritmo Bellman Ford</a></p>\n<h4>Otros</h4>\n<p>Fuentes utilizadas:</p>\n<ul>\n<li><a href=\"https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/\">https://www.geeksforgeeks.org/bellman-ford-algorithm-dp-23/</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm\">https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm</a></li>\n</ul>"
  },
  "implementations": {
    "python": {
      "dir": "graphs/bellman_ford.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/graphs/bellman_ford.py",
      "code": "<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print_distance</span>(<span class=\"hljs-params\">distance: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">float</span>], src</span>):\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;Vertex\\tShortest Distance from vertex <span class=\"hljs-subst\">{src}</span>&quot;</span>)\n    <span class=\"hljs-keyword\">for</span> i, d <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(distance):\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;<span class=\"hljs-subst\">{i}</span>\\t\\t<span class=\"hljs-subst\">{d}</span>&quot;</span>)\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">check_negative_cycle</span>(<span class=\"hljs-params\">\n    graph: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">int</span>]], distance: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">float</span>], edge_count: <span class=\"hljs-built_in\">int</span>\n</span>):\n    <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(edge_count):\n        u, v, w = (graph[j][k] <span class=\"hljs-keyword\">for</span> k <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-string\">&quot;src&quot;</span>, <span class=\"hljs-string\">&quot;dst&quot;</span>, <span class=\"hljs-string\">&quot;weight&quot;</span>])\n        <span class=\"hljs-keyword\">if</span> distance[u] != <span class=\"hljs-built_in\">float</span>(<span class=\"hljs-string\">&quot;inf&quot;</span>) <span class=\"hljs-keyword\">and</span> distance[u] + w &lt; distance[v]:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">bellman_ford</span>(<span class=\"hljs-params\">\n    graph: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">int</span>]], vertex_count: <span class=\"hljs-built_in\">int</span>, edge_count: <span class=\"hljs-built_in\">int</span>, src: <span class=\"hljs-built_in\">int</span>\n</span>) -&gt; <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">float</span>]:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Returns shortest paths from a vertex src to all\n    other vertices.\n    &gt;&gt;&gt; edges = [(2, 1, -10), (3, 2, 3), (0, 3, 5), (0, 1, 4)]\n    &gt;&gt;&gt; g = [{&quot;src&quot;: s, &quot;dst&quot;: d, &quot;weight&quot;: w} for s, d, w in edges]\n    &gt;&gt;&gt; bellman_ford(g, 4, 4, 0)\n    [0.0, -2.0, 8.0, 5.0]\n    &gt;&gt;&gt; g = [{&quot;src&quot;: s, &quot;dst&quot;: d, &quot;weight&quot;: w} for s, d, w in edges + [(1, 3, 5)]]\n    &gt;&gt;&gt; bellman_ford(g, 4, 5, 0)\n    Traceback (most recent call last):\n     ...\n    Exception: Negative cycle found\n    &quot;&quot;&quot;</span>\n    distance = [<span class=\"hljs-built_in\">float</span>(<span class=\"hljs-string\">&quot;inf&quot;</span>)] * vertex_count\n    distance[src] = <span class=\"hljs-number\">0.0</span>\n\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(vertex_count - <span class=\"hljs-number\">1</span>):\n        <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(edge_count):\n            u, v, w = (graph[j][k] <span class=\"hljs-keyword\">for</span> k <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-string\">&quot;src&quot;</span>, <span class=\"hljs-string\">&quot;dst&quot;</span>, <span class=\"hljs-string\">&quot;weight&quot;</span>])\n\n            <span class=\"hljs-keyword\">if</span> distance[u] != <span class=\"hljs-built_in\">float</span>(<span class=\"hljs-string\">&quot;inf&quot;</span>) <span class=\"hljs-keyword\">and</span> distance[u] + w &lt; distance[v]:\n                distance[v] = distance[u] + w\n\n    negative_cycle_exists = check_negative_cycle(graph, distance, edge_count)\n    <span class=\"hljs-keyword\">if</span> negative_cycle_exists:\n        <span class=\"hljs-keyword\">raise</span> Exception(<span class=\"hljs-string\">&quot;Negative cycle found&quot;</span>)\n\n    <span class=\"hljs-keyword\">return</span> distance\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">import</span> doctest\n\n    doctest.testmod()\n\n    V = <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&quot;Enter number of vertices: &quot;</span>).strip())\n    E = <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&quot;Enter number of edges: &quot;</span>).strip())\n\n    graph: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">str</span>, <span class=\"hljs-built_in\">int</span>]] = [<span class=\"hljs-built_in\">dict</span>() <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(E)]\n\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(E):\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Edge &quot;</span>, i + <span class=\"hljs-number\">1</span>)\n        src, dest, weight = (\n            <span class=\"hljs-built_in\">int</span>(x)\n            <span class=\"hljs-keyword\">for</span> x <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&quot;Enter source, destination, weight: &quot;</span>).strip().split(<span class=\"hljs-string\">&quot; &quot;</span>)\n        )\n        graph[i] = {<span class=\"hljs-string\">&quot;src&quot;</span>: src, <span class=\"hljs-string\">&quot;dst&quot;</span>: dest, <span class=\"hljs-string\">&quot;weight&quot;</span>: weight}\n\n    source = <span class=\"hljs-built_in\">int</span>(<span class=\"hljs-built_in\">input</span>(<span class=\"hljs-string\">&quot;\\nEnter shortest path source:&quot;</span>).strip())\n    shortest_distance = bellman_ford(graph, V, E, source)\n    print_distance(shortest_distance, <span class=\"hljs-number\">0</span>)\n"
    },
    "javascript": {
      "dir": "Graphs/BellmanFord.js",
      "url": "https://github.com/TheAlgorithms/javascript/tree/master/Graphs/BellmanFord.js",
      "code": "<span class=\"hljs-comment\">/*\nThe Bellman–Ford algorithm is an algorithm that computes shortest paths\nfrom a single source vertex to all of the other vertices in a weighted digraph.\nIt also detects negative weight cycle.\n\nComplexity:\n    Worst-case performance O(VE)\n    Best-case performance O(E)\n    Worst-case space complexity O(V)\n\nReference:\n    https://en.wikipedia.org/wiki/Bellman–Ford_algorithm\n    https://cp-algorithms.com/graph/bellman_ford.html\n\n*/</span>\n\n<span class=\"hljs-comment\">/**\n *\n * <span class=\"hljs-doctag\">@param</span> graph Graph in the format (u, v, w) where\n *  the edge is from vertex u to v. And weight\n *  of the edge is w.\n * <span class=\"hljs-doctag\">@param</span> V Number of vertices in graph\n * <span class=\"hljs-doctag\">@param</span> E Number of edges in graph\n * <span class=\"hljs-doctag\">@param</span> src Starting node\n * <span class=\"hljs-doctag\">@param</span> dest Destination node\n * <span class=\"hljs-doctag\">@returns</span> Shortest distance from source to destination\n */</span>\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">BellmanFord</span> (graph, V, E, src, dest) {\n  <span class=\"hljs-comment\">// Initialize distance of all vertices as infinite.</span>\n  <span class=\"hljs-keyword\">const</span> dis = <span class=\"hljs-title class_\">Array</span>(V).<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-title class_\">Infinity</span>)\n  <span class=\"hljs-comment\">// initialize distance of source as 0</span>\n  dis[src] = <span class=\"hljs-number\">0</span>\n\n  <span class=\"hljs-comment\">// Relax all edges |V| - 1 times. A simple</span>\n  <span class=\"hljs-comment\">// shortest path from src to any other</span>\n  <span class=\"hljs-comment\">// vertex can have at-most |V| - 1 edges</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; V - <span class=\"hljs-number\">1</span>; i++) {\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = <span class=\"hljs-number\">0</span>; j &lt; E; j++) {\n      <span class=\"hljs-keyword\">if</span> ((dis[graph[j][<span class=\"hljs-number\">0</span>]] + graph[j][<span class=\"hljs-number\">2</span>]) &lt; dis[graph[j][<span class=\"hljs-number\">1</span>]]) { dis[graph[j][<span class=\"hljs-number\">1</span>]] = dis[graph[j][<span class=\"hljs-number\">0</span>]] + graph[j][<span class=\"hljs-number\">2</span>] }\n    }\n  }\n  <span class=\"hljs-comment\">// check for negative-weight cycles.</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; E; i++) {\n    <span class=\"hljs-keyword\">const</span> x = graph[i][<span class=\"hljs-number\">0</span>]\n    <span class=\"hljs-keyword\">const</span> y = graph[i][<span class=\"hljs-number\">1</span>]\n    <span class=\"hljs-keyword\">const</span> weight = graph[i][<span class=\"hljs-number\">2</span>]\n    <span class=\"hljs-keyword\">if</span> ((dis[x] !== <span class=\"hljs-title class_\">Infinity</span>) &amp;&amp; (dis[x] + weight &lt; dis[y])) {\n      <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>\n    }\n  }\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) {\n    <span class=\"hljs-keyword\">if</span> (i === dest) <span class=\"hljs-keyword\">return</span> dis[i]\n  }\n}\n\n<span class=\"hljs-keyword\">export</span> { <span class=\"hljs-title class_\">BellmanFord</span> }\n"
    },
    "c-plus-plus": {
      "dir": "dynamic_programming/bellman_ford.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/dynamic_programming/bellman_ford.cpp",
      "code": "<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;limits.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n\n<span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> std;\n\n<span class=\"hljs-comment\">// Wrapper class for storing an edge</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Edge</span> {\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-type\">int</span> src, dst, weight;\n};\n\n<span class=\"hljs-comment\">// Wrapper class for storing a graph</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span> {\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-type\">int</span> vertexNum, edgeNum;\n    Edge *edges;\n\n    <span class=\"hljs-comment\">// Constructs a graph with V vertices and E edges</span>\n    <span class=\"hljs-built_in\">Graph</span>(<span class=\"hljs-type\">int</span> V, <span class=\"hljs-type\">int</span> E) {\n        <span class=\"hljs-keyword\">this</span>-&gt;vertexNum = V;\n        <span class=\"hljs-keyword\">this</span>-&gt;edgeNum = E;\n        <span class=\"hljs-keyword\">this</span>-&gt;edges = (Edge *)<span class=\"hljs-built_in\">malloc</span>(E * <span class=\"hljs-built_in\">sizeof</span>(Edge));\n    }\n\n    <span class=\"hljs-comment\">// Adds the given edge to the graph</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> src, <span class=\"hljs-type\">int</span> dst, <span class=\"hljs-type\">int</span> weight)</span> </span>{\n        <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> edgeInd = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">if</span> (edgeInd &lt; <span class=\"hljs-keyword\">this</span>-&gt;edgeNum) {\n            Edge newEdge;\n            newEdge.src = src;\n            newEdge.dst = dst;\n            newEdge.weight = weight;\n            <span class=\"hljs-keyword\">this</span>-&gt;edges[edgeInd++] = newEdge;\n        }\n    }\n};\n\n<span class=\"hljs-comment\">// Utility function to print distances</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> dist[], <span class=\"hljs-type\">int</span> V)</span> </span>{\n    cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nVertex  Distance&quot;</span> &lt;&lt; endl;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) {\n        <span class=\"hljs-keyword\">if</span> (dist[i] != INT_MAX)\n            cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot;\\t&quot;</span> &lt;&lt; dist[i] &lt;&lt; endl;\n        <span class=\"hljs-keyword\">else</span>\n            cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot;\\tINF&quot;</span> &lt;&lt; endl;\n    }\n}\n\n<span class=\"hljs-comment\">// The main function that finds the shortest path from given source</span>\n<span class=\"hljs-comment\">// to all other vertices using Bellman-Ford.It also detects negative</span>\n<span class=\"hljs-comment\">// weight cycle</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">BellmanFord</span><span class=\"hljs-params\">(Graph graph, <span class=\"hljs-type\">int</span> src)</span> </span>{\n    <span class=\"hljs-type\">int</span> V = graph.vertexNum;\n    <span class=\"hljs-type\">int</span> E = graph.edgeNum;\n    <span class=\"hljs-type\">int</span> dist[V];\n\n    <span class=\"hljs-comment\">// Initialize distances array as INF for all except source</span>\n    <span class=\"hljs-comment\">// Intialize source as zero</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) dist[i] = INT_MAX;\n    dist[src] = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-comment\">// Calculate shortest path distance from source to all edges</span>\n    <span class=\"hljs-comment\">// A path can contain maximum (|V|-1) edges</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= V - <span class=\"hljs-number\">1</span>; i++)\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; E; j++) {\n            <span class=\"hljs-type\">int</span> u = graph.edges[j].src;\n            <span class=\"hljs-type\">int</span> v = graph.edges[j].dst;\n            <span class=\"hljs-type\">int</span> w = graph.edges[j].weight;\n\n            <span class=\"hljs-keyword\">if</span> (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v])\n                dist[v] = dist[u] + w;\n        }\n\n    <span class=\"hljs-comment\">// Iterate inner loop once more to check for negative cycle</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; E; j++) {\n        <span class=\"hljs-type\">int</span> u = graph.edges[j].src;\n        <span class=\"hljs-type\">int</span> v = graph.edges[j].dst;\n        <span class=\"hljs-type\">int</span> w = graph.edges[j].weight;\n\n        <span class=\"hljs-keyword\">if</span> (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v]) {\n            cout &lt;&lt; <span class=\"hljs-string\">&quot;Graph contains negative weight cycle. Hence, shortest &quot;</span>\n                    <span class=\"hljs-string\">&quot;distance not guaranteed.&quot;</span>\n                 &lt;&lt; endl;\n            <span class=\"hljs-keyword\">return</span>;\n        }\n    }\n\n    <span class=\"hljs-built_in\">print</span>(dist, V);\n\n    <span class=\"hljs-keyword\">return</span>;\n}\n\n<span class=\"hljs-comment\">// Driver Function</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">int</span> V, E, gsrc;\n    <span class=\"hljs-type\">int</span> src, dst, weight;\n    cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter number of vertices: &quot;</span>;\n    cin &gt;&gt; V;\n    cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter number of edges: &quot;</span>;\n    cin &gt;&gt; E;\n    <span class=\"hljs-function\">Graph <span class=\"hljs-title\">G</span><span class=\"hljs-params\">(V, E)</span></span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; E; i++) {\n        cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nEdge &quot;</span> &lt;&lt; i + <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-string\">&quot;\\nEnter source: &quot;</span>;\n        cin &gt;&gt; src;\n        cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter destination: &quot;</span>;\n        cin &gt;&gt; dst;\n        cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter weight: &quot;</span>;\n        cin &gt;&gt; weight;\n        G.<span class=\"hljs-built_in\">addEdge</span>(src, dst, weight);\n    }\n    cout &lt;&lt; <span class=\"hljs-string\">&quot;\\nEnter source: &quot;</span>;\n    cin &gt;&gt; gsrc;\n    <span class=\"hljs-built_in\">BellmanFord</span>(G, gsrc);\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "java": {
      "dir": "src/main/java/com/thealgorithms/datastructures/graphs/BellmanFord.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src/main/java/com/thealgorithms/datastructures/graphs/BellmanFord.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.datastructures.graphs;\n\n<span class=\"hljs-keyword\">import</span> java.util.*;\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BellmanFord</span> <span class=\"hljs-comment\">/*Implementation of Bellman ford to detect negative cycles. Graph accepts inputs in form of edges which have\nstart vertex, end vertex and weights. Vertices should be labelled with a number between 0 and total number of vertices-1,both inclusive*/</span> {\n\n    <span class=\"hljs-type\">int</span> vertex, edge;\n    <span class=\"hljs-keyword\">private</span> Edge edges[];\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">index</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n\n    BellmanFord(<span class=\"hljs-type\">int</span> v, <span class=\"hljs-type\">int</span> e) {\n        vertex = v;\n        edge = e;\n        edges = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Edge</span>[e];\n    }\n\n    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Edge</span> {\n\n        <span class=\"hljs-type\">int</span> u, v;\n        <span class=\"hljs-type\">int</span> w;\n\n        <span class=\"hljs-comment\">/**\n         * <span class=\"hljs-doctag\">@param</span> u Source Vertex\n         * <span class=\"hljs-doctag\">@param</span> v End vertex\n         * <span class=\"hljs-doctag\">@param</span> c Weight\n         */</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Edge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> a, <span class=\"hljs-type\">int</span> b, <span class=\"hljs-type\">int</span> c)</span> {\n            u = a;\n            v = b;\n            w = c;\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * <span class=\"hljs-doctag\">@param</span> p[] Parent array which shows updates in edges\n     * <span class=\"hljs-doctag\">@param</span> i Current vertex under consideration\n     */</span>\n    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printPath</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> p[], <span class=\"hljs-type\">int</span> i)</span> {\n        <span class=\"hljs-keyword\">if</span> (p[i] == -<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// Found the path back to parent</span>\n        {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        printPath(p, p[i]);\n        System.out.print(i + <span class=\"hljs-string\">&quot; &quot;</span>);\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String args[])</span> {\n        <span class=\"hljs-type\">BellmanFord</span> <span class=\"hljs-variable\">obj</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BellmanFord</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>); <span class=\"hljs-comment\">// Dummy object to call nonstatic variables</span>\n        obj.go();\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span>\n            <span class=\"hljs-title function_\">go</span><span class=\"hljs-params\">()</span> <span class=\"hljs-comment\">// Interactive run for understanding the class first time. Assumes source vertex is 0 and</span>\n    <span class=\"hljs-comment\">// shows distance to all vertices</span>\n    {\n        <span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">sc</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in); <span class=\"hljs-comment\">// Grab scanner object for user input</span>\n        <span class=\"hljs-type\">int</span> i, v, e, u, ve, w, j, neg = <span class=\"hljs-number\">0</span>;\n        System.out.println(<span class=\"hljs-string\">&quot;Enter no. of vertices and edges please&quot;</span>);\n        v = sc.nextInt();\n        e = sc.nextInt();\n        Edge arr[] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Edge</span>[e]; <span class=\"hljs-comment\">// Array of edges</span>\n        System.out.println(<span class=\"hljs-string\">&quot;Input edges&quot;</span>);\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; e; i++) {\n            u = sc.nextInt();\n            ve = sc.nextInt();\n            w = sc.nextInt();\n            arr[i] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Edge</span>(u, ve, w);\n        }\n        <span class=\"hljs-type\">int</span> dist[]\n                = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[v]; <span class=\"hljs-comment\">// Distance array for holding the finalized shortest path distance between source</span>\n        <span class=\"hljs-comment\">// and all vertices</span>\n        <span class=\"hljs-type\">int</span> p[] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[v]; <span class=\"hljs-comment\">// Parent array for holding the paths</span>\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v; i++) {\n            dist[i] = Integer.MAX_VALUE; <span class=\"hljs-comment\">// Initializing distance values</span>\n        }\n        dist[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;\n        p[<span class=\"hljs-number\">0</span>] = -<span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v - <span class=\"hljs-number\">1</span>; i++) {\n            <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; e; j++) {\n                <span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-type\">int</span>) dist[arr[j].u] != Integer.MAX_VALUE\n                        &amp;&amp; dist[arr[j].v] &gt; dist[arr[j].u] + arr[j].w) {\n                    dist[arr[j].v] = dist[arr[j].u] + arr[j].w; <span class=\"hljs-comment\">// Update</span>\n                    p[arr[j].v] = arr[j].u;\n                }\n            }\n        }\n        <span class=\"hljs-comment\">// Final cycle for negative checking</span>\n        <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; e; j++) {\n            <span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-type\">int</span>) dist[arr[j].u] != Integer.MAX_VALUE &amp;&amp; dist[arr[j].v] &gt; dist[arr[j].u] + arr[j].w) {\n                neg = <span class=\"hljs-number\">1</span>;\n                System.out.println(<span class=\"hljs-string\">&quot;Negative cycle&quot;</span>);\n                <span class=\"hljs-keyword\">break</span>;\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> (neg == <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// Go ahead and show results of computation</span>\n        {\n            System.out.println(<span class=\"hljs-string\">&quot;Distances are: &quot;</span>);\n            <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v; i++) {\n                System.out.println(i + <span class=\"hljs-string\">&quot; &quot;</span> + dist[i]);\n            }\n            System.out.println(<span class=\"hljs-string\">&quot;Path followed:&quot;</span>);\n            <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v; i++) {\n                System.out.print(<span class=\"hljs-string\">&quot;0 &quot;</span>);\n                printPath(p, i);\n                System.out.println();\n            }\n        }\n        sc.close();\n    }\n\n    <span class=\"hljs-comment\">/**\n     * <span class=\"hljs-doctag\">@param</span> source Starting vertex\n     * <span class=\"hljs-doctag\">@param</span> end Ending vertex\n     * <span class=\"hljs-doctag\">@param</span> Edge Array of edges\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">show</span><span class=\"hljs-params\">(\n            <span class=\"hljs-type\">int</span> source,\n            <span class=\"hljs-type\">int</span> end,\n            Edge arr[])</span> <span class=\"hljs-comment\">// Just shows results of computation, if graph is passed to it. The graph should</span>\n    <span class=\"hljs-comment\">// be created by using addEdge() method and passed by calling getEdgeArray() method</span>\n    {\n        <span class=\"hljs-type\">int</span> i, j, v = vertex, e = edge, neg = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-type\">double</span> dist[]\n                = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">double</span>[v]; <span class=\"hljs-comment\">// Distance array for holding the finalized shortest path distance between source</span>\n        <span class=\"hljs-comment\">// and all vertices</span>\n        <span class=\"hljs-type\">int</span> p[] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[v]; <span class=\"hljs-comment\">// Parent array for holding the paths</span>\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v; i++) {\n            dist[i] = Integer.MAX_VALUE; <span class=\"hljs-comment\">// Initializing distance values</span>\n        }\n        dist[source] = <span class=\"hljs-number\">0</span>;\n        p[source] = -<span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; v - <span class=\"hljs-number\">1</span>; i++) {\n            <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; e; j++) {\n                <span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-type\">int</span>) dist[arr[j].u] != Integer.MAX_VALUE\n                        &amp;&amp; dist[arr[j].v] &gt; dist[arr[j].u] + arr[j].w) {\n                    dist[arr[j].v] = dist[arr[j].u] + arr[j].w; <span class=\"hljs-comment\">// Update</span>\n                    p[arr[j].v] = arr[j].u;\n                }\n            }\n        }\n        <span class=\"hljs-comment\">// Final cycle for negative checking</span>\n        <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; e; j++) {\n            <span class=\"hljs-keyword\">if</span> ((<span class=\"hljs-type\">int</span>) dist[arr[j].u] != Integer.MAX_VALUE &amp;&amp; dist[arr[j].v] &gt; dist[arr[j].u] + arr[j].w) {\n                neg = <span class=\"hljs-number\">1</span>;\n                System.out.println(<span class=\"hljs-string\">&quot;Negative cycle&quot;</span>);\n                <span class=\"hljs-keyword\">break</span>;\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> (neg == <span class=\"hljs-number\">0</span>) <span class=\"hljs-comment\">// Go ahead and show results of computaion</span>\n        {\n            System.out.println(<span class=\"hljs-string\">&quot;Distance is: &quot;</span> + dist[end]);\n            System.out.println(<span class=\"hljs-string\">&quot;Path followed:&quot;</span>);\n            System.out.print(source + <span class=\"hljs-string\">&quot; &quot;</span>);\n            printPath(p, end);\n            System.out.println();\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * <span class=\"hljs-doctag\">@param</span> x Source Vertex\n     * <span class=\"hljs-doctag\">@param</span> y End vertex\n     * <span class=\"hljs-doctag\">@param</span> z Weight\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y, <span class=\"hljs-type\">int</span> z)</span> <span class=\"hljs-comment\">// Adds unidirectional edge</span>\n    {\n        edges[index++] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Edge</span>(x, y, z);\n    }\n\n    <span class=\"hljs-keyword\">public</span> Edge[] getEdgeArray() {\n        <span class=\"hljs-keyword\">return</span> edges;\n    }\n}\n"
    },
    "c": {
      "dir": "data_structures/graphs/bellman_ford.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/data_structures/graphs/bellman_ford.c",
      "code": "<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;limits.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span></span>\n\n<span class=\"hljs-comment\">// Structure for storing edge</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span>\n{</span>\n    <span class=\"hljs-type\">int</span> src, dst, weight;\n};\n\n<span class=\"hljs-comment\">// Structure for storing a graph</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Graph</span>\n{</span>\n    <span class=\"hljs-type\">int</span> vertexNum;\n    <span class=\"hljs-type\">int</span> edgeNum;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span> *<span class=\"hljs-title\">edges</span>;</span>\n};\n\n<span class=\"hljs-comment\">// Constructs a graph with V vertices and E edges</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">createGraph</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Graph *G, <span class=\"hljs-type\">int</span> V, <span class=\"hljs-type\">int</span> E)</span>\n{\n    G-&gt;vertexNum = V;\n    G-&gt;edgeNum = E;\n    G-&gt;edges = (<span class=\"hljs-keyword\">struct</span> Edge *)<span class=\"hljs-built_in\">malloc</span>(E * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> Edge));\n}\n\n<span class=\"hljs-comment\">// Adds the given edge to the graph</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Graph *G, <span class=\"hljs-type\">int</span> src, <span class=\"hljs-type\">int</span> dst, <span class=\"hljs-type\">int</span> weight)</span>\n{\n    <span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> ind;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Edge</span> <span class=\"hljs-title\">newEdge</span>;</span>\n    newEdge.src = src;\n    newEdge.dst = dst;\n    newEdge.weight = weight;\n    G-&gt;edges[ind++] = newEdge;\n}\n\n<span class=\"hljs-comment\">// Utility function to find minimum distance vertex in mdist</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">minDistance</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> mdist[], <span class=\"hljs-type\">int</span> vset[], <span class=\"hljs-type\">int</span> V)</span>\n{\n    <span class=\"hljs-type\">int</span> minVal = INT_MAX, minInd;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++)\n        <span class=\"hljs-keyword\">if</span> (vset[i] == <span class=\"hljs-number\">0</span> &amp;&amp; mdist[i] &lt; minVal)\n        {\n            minVal = mdist[i];\n            minInd = i;\n        }\n\n    <span class=\"hljs-keyword\">return</span> minInd;\n}\n\n<span class=\"hljs-comment\">// Utility function to print distances</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">print</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> dist[], <span class=\"hljs-type\">int</span> V)</span>\n{\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\nVertex  Distance\\n&quot;</span>);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++)\n    {\n        <span class=\"hljs-keyword\">if</span> (dist[i] != INT_MAX)\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\t%d\\n&quot;</span>, i, dist[i]);\n        <span class=\"hljs-keyword\">else</span>\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\tINF&quot;</span>, i);\n    }\n}\n\n<span class=\"hljs-comment\">// The main function that finds the shortest path from given source</span>\n<span class=\"hljs-comment\">// to all other vertices using Bellman-Ford.It also detects negative</span>\n<span class=\"hljs-comment\">// weight cycle</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">BellmanFord</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Graph *graph, <span class=\"hljs-type\">int</span> src)</span>\n{\n    <span class=\"hljs-type\">int</span> V = graph-&gt;vertexNum;\n    <span class=\"hljs-type\">int</span> E = graph-&gt;edgeNum;\n    <span class=\"hljs-type\">int</span> dist[V];\n\n    <span class=\"hljs-comment\">// Initialize distances array as INF for all except source</span>\n    <span class=\"hljs-comment\">// Intialize source as zero</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) dist[i] = INT_MAX;\n    dist[src] = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-comment\">// Calculate shortest path distance from source to all edges</span>\n    <span class=\"hljs-comment\">// A path can contain maximum (|V|-1) edges</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= V - <span class=\"hljs-number\">1</span>; i++)\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; E; j++)\n        {\n            <span class=\"hljs-type\">int</span> u = graph-&gt;edges[j].src;\n            <span class=\"hljs-type\">int</span> v = graph-&gt;edges[j].dst;\n            <span class=\"hljs-type\">int</span> w = graph-&gt;edges[j].weight;\n\n            <span class=\"hljs-keyword\">if</span> (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v])\n                dist[v] = dist[u] + w;\n        }\n\n    <span class=\"hljs-comment\">// Iterate inner loop once more to check for negative cycle</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; E; j++)\n    {\n        <span class=\"hljs-type\">int</span> u = graph-&gt;edges[j].src;\n        <span class=\"hljs-type\">int</span> v = graph-&gt;edges[j].dst;\n        <span class=\"hljs-type\">int</span> w = graph-&gt;edges[j].weight;\n\n        <span class=\"hljs-keyword\">if</span> (dist[u] != INT_MAX &amp;&amp; dist[u] + w &lt; dist[v])\n        {\n            <span class=\"hljs-built_in\">printf</span>(\n                <span class=\"hljs-string\">&quot;Graph contains negative weight cycle. Hence, shortest &quot;</span>\n                <span class=\"hljs-string\">&quot;distance not guaranteed.&quot;</span>);\n            <span class=\"hljs-keyword\">return</span>;\n        }\n    }\n\n    print(dist, V);\n\n    <span class=\"hljs-keyword\">return</span>;\n}\n\n<span class=\"hljs-comment\">// Driver Function</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>\n{\n    <span class=\"hljs-type\">int</span> V, E, gsrc;\n    <span class=\"hljs-type\">int</span> src, dst, weight;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Graph</span> <span class=\"hljs-title\">G</span>;</span>\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter number of vertices: &quot;</span>);\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;V);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter number of edges: &quot;</span>);\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;E);\n    createGraph(&amp;G, V, E);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; E; i++)\n    {\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\nEdge %d \\nEnter source: &quot;</span>, i + <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;src);\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter destination: &quot;</span>);\n        <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;dst);\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter weight: &quot;</span>);\n        <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;weight);\n        addEdge(&amp;G, src, dst, weight);\n    }\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\nEnter source:&quot;</span>);\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;gsrc);\n    BellmanFord(&amp;G, gsrc);\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "go": {
      "dir": "graph/bellmanford.go",
      "url": "https://github.com/TheAlgorithms/go/tree/master/graph/bellmanford.go",
      "code": "<span class=\"hljs-comment\">// The Bellman–Ford algorithm is an algorithm that computes shortest paths from a</span>\n<span class=\"hljs-comment\">// single source vertex to all of the other vertices in a weighted durected graph.</span>\n<span class=\"hljs-comment\">// It is slower than Dijkstra but capable of handling negative edge weights.</span>\n<span class=\"hljs-comment\">// https://en.wikipedia.org/wiki/Bellman%E2%80%93Ford_algorithm</span>\n<span class=\"hljs-comment\">// Implementation is based on the book &#x27;Introduction to Algorithms&#x27; (CLRS)</span>\n\n<span class=\"hljs-keyword\">package</span> graph\n\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">&quot;errors&quot;</span>\n\t<span class=\"hljs-string\">&quot;math&quot;</span>\n)\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(g *Graph)</span></span> BellmanFord(start, end <span class=\"hljs-type\">int</span>) (isReachable <span class=\"hljs-type\">bool</span>, distance <span class=\"hljs-type\">int</span>, err <span class=\"hljs-type\">error</span>) {\n\tINF := math.Inf(<span class=\"hljs-number\">1</span>)\n\tdistances := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">float64</span>, g.vertices)\n\n\t<span class=\"hljs-comment\">// Set all vertices to unreachable, initialize source</span>\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; g.vertices; i++ {\n\t\tdistances[i] = INF\n\t}\n\tdistances[start] = <span class=\"hljs-number\">0</span>\n\n\t<span class=\"hljs-comment\">// Making iterations equal to #vertices</span>\n\t<span class=\"hljs-keyword\">for</span> n := <span class=\"hljs-number\">0</span>; n &lt; g.vertices; n++ {\n\n\t\t<span class=\"hljs-comment\">// Looping over all edges</span>\n\t\t<span class=\"hljs-keyword\">for</span> u, adjacents := <span class=\"hljs-keyword\">range</span> g.edges {\n\t\t\t<span class=\"hljs-keyword\">for</span> v, weightUV := <span class=\"hljs-keyword\">range</span> adjacents {\n\n\t\t\t\t<span class=\"hljs-comment\">// If new shorter distance is found, update distance value (relaxation step)</span>\n\t\t\t\t<span class=\"hljs-keyword\">if</span> newDistance := distances[u] + <span class=\"hljs-type\">float64</span>(weightUV); distances[v] &gt; newDistance {\n\t\t\t\t\tdistances[v] = newDistance\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t<span class=\"hljs-comment\">// Check for negative weight cycle</span>\n\t<span class=\"hljs-keyword\">for</span> u, adjacents := <span class=\"hljs-keyword\">range</span> g.edges {\n\t\t<span class=\"hljs-keyword\">for</span> v, weightUV := <span class=\"hljs-keyword\">range</span> adjacents {\n\t\t\t<span class=\"hljs-keyword\">if</span> newDistance := distances[u] + <span class=\"hljs-type\">float64</span>(weightUV); distances[v] &gt; newDistance {\n\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>, <span class=\"hljs-number\">-1</span>, errors.New(<span class=\"hljs-string\">&quot;negative weight cycle present&quot;</span>)\n\t\t\t}\n\t\t}\n\t}\n\n\t<span class=\"hljs-keyword\">return</span> distances[end] != INF, <span class=\"hljs-type\">int</span>(distances[end]), <span class=\"hljs-literal\">nil</span>\n}\n"
    },
    "rust": {
      "dir": "src/graph/bellman_ford.rs",
      "url": "https://github.com/TheAlgorithms/rust/tree/master/src/graph/bellman_ford.rs",
      "code": "<span class=\"hljs-keyword\">use</span> std::collections::BTreeMap;\n<span class=\"hljs-keyword\">use</span> std::ops::Add;\n\n<span class=\"hljs-keyword\">use</span> std::ops::Neg;\n\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Graph</span>&lt;V, E&gt; = BTreeMap&lt;V, BTreeMap&lt;V, E&gt;&gt;;\n\n<span class=\"hljs-comment\">// performs the Bellman-Ford algorithm on the given graph from the given start</span>\n<span class=\"hljs-comment\">// the graph is an undirected graph</span>\n<span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">// if there is a negative weighted loop it returns None</span>\n<span class=\"hljs-comment\">// else it returns a map that for each reachable vertex associates the distance and the predecessor</span>\n<span class=\"hljs-comment\">// since the start has no predecessor but is reachable, map[start] will be None</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">bellman_ford</span>&lt;\n    V: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span>,\n    E: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span> + Add&lt;Output = E&gt; + Neg&lt;Output = E&gt; + std::ops::Sub&lt;Output = E&gt;,\n&gt;(\n    graph: &amp;Graph&lt;V, E&gt;,\n    start: &amp;V,\n) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Option</span>&lt;BTreeMap&lt;V, <span class=\"hljs-type\">Option</span>&lt;(V, E)&gt;&gt;&gt; {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">ans</span>: BTreeMap&lt;V, <span class=\"hljs-type\">Option</span>&lt;(V, E)&gt;&gt; = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n\n    ans.<span class=\"hljs-title function_ invoke__\">insert</span>(*start, <span class=\"hljs-literal\">None</span>);\n\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">_</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..(graph.<span class=\"hljs-title function_ invoke__\">len</span>()) {\n        <span class=\"hljs-title function_ invoke__\">for</span> (u, edges) <span class=\"hljs-keyword\">in</span> graph {\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">dist_u</span> = <span class=\"hljs-keyword\">match</span> ans.<span class=\"hljs-title function_ invoke__\">get</span>(u) {\n                <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-title function_ invoke__\">Some</span>((_, d))) =&gt; <span class=\"hljs-title function_ invoke__\">Some</span>(*d),\n                <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-literal\">None</span>) =&gt; <span class=\"hljs-literal\">None</span>,\n                <span class=\"hljs-literal\">None</span> =&gt; <span class=\"hljs-keyword\">continue</span>,\n            };\n\n            <span class=\"hljs-title function_ invoke__\">for</span> (v, d) <span class=\"hljs-keyword\">in</span> edges {\n                <span class=\"hljs-keyword\">match</span> ans.<span class=\"hljs-title function_ invoke__\">get</span>(v) {\n                    <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-title function_ invoke__\">Some</span>((_, dist)))\n                        <span class=\"hljs-comment\">// if this is a longer path, do nothing</span>\n                        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">match</span> dist_u {\n                            <span class=\"hljs-title function_ invoke__\">Some</span>(dist_u) =&gt; dist_u + *d &gt;= *dist,\n                            <span class=\"hljs-literal\">None</span> =&gt; d &gt;= dist,\n                        } =&gt; {}\n                    <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-literal\">None</span>) =&gt; {\n                        <span class=\"hljs-keyword\">match</span> dist_u {\n                            <span class=\"hljs-comment\">// if dist_u + d &lt; 0 there is a negative loop going by start</span>\n                            <span class=\"hljs-comment\">// else it&#x27;s just a longer path</span>\n                            <span class=\"hljs-title function_ invoke__\">Some</span>(dist_u) <span class=\"hljs-keyword\">if</span> dist_u &gt;= -*d =&gt; {}\n                            <span class=\"hljs-comment\">// negative self edge or negative loop</span>\n                            _ =&gt; {\n                                <span class=\"hljs-keyword\">if</span> *d &gt; *d + *d {\n                                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>;\n                                }\n                            }\n                        };\n                    }\n                    <span class=\"hljs-comment\">// it&#x27;s a shorter path: either dist_v was infinite or it was longer than dist_u + d</span>\n                    _ =&gt; {\n                        ans.<span class=\"hljs-title function_ invoke__\">insert</span>(\n                            *v,\n                            <span class=\"hljs-title function_ invoke__\">Some</span>((\n                                *u,\n                                <span class=\"hljs-keyword\">match</span> dist_u {\n                                    <span class=\"hljs-title function_ invoke__\">Some</span>(dist) =&gt; dist + *d,\n                                    <span class=\"hljs-literal\">None</span> =&gt; *d,\n                                },\n                            )),\n                        );\n                    }\n                }\n            }\n        }\n    }\n\n    <span class=\"hljs-title function_ invoke__\">for</span> (u, edges) <span class=\"hljs-keyword\">in</span> graph {\n        <span class=\"hljs-title function_ invoke__\">for</span> (v, d) <span class=\"hljs-keyword\">in</span> edges {\n            <span class=\"hljs-title function_ invoke__\">match</span> (ans.<span class=\"hljs-title function_ invoke__\">get</span>(u), ans.<span class=\"hljs-title function_ invoke__\">get</span>(v)) {\n                (<span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-literal\">None</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-literal\">None</span>)) <span class=\"hljs-keyword\">if</span> *d &gt; *d + *d =&gt; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>,\n                (<span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-literal\">None</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-title function_ invoke__\">Some</span>((_, dv)))) <span class=\"hljs-keyword\">if</span> d &lt; dv =&gt; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>,\n                (<span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-title function_ invoke__\">Some</span>((_, du))), <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-literal\">None</span>)) <span class=\"hljs-keyword\">if</span> *du &lt; -*d =&gt; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>,\n                (<span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-title function_ invoke__\">Some</span>((_, du))), <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-title function_ invoke__\">Some</span>((_, dv)))) <span class=\"hljs-keyword\">if</span> *du + *d &lt; *dv =&gt; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>,\n                (_, _) =&gt; {}\n            }\n        }\n    }\n\n    <span class=\"hljs-title function_ invoke__\">Some</span>(ans)\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::{bellman_ford, Graph};\n    <span class=\"hljs-keyword\">use</span> std::collections::BTreeMap;\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">add_edge</span>&lt;V: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span>, E: <span class=\"hljs-built_in\">Ord</span>&gt;(graph: &amp;<span class=\"hljs-keyword\">mut</span> Graph&lt;V, E&gt;, v1: V, v2: V, c: E) {\n        graph.<span class=\"hljs-title function_ invoke__\">entry</span>(v1).<span class=\"hljs-title function_ invoke__\">or_insert_with</span>(BTreeMap::new).<span class=\"hljs-title function_ invoke__\">insert</span>(v2, c);\n        graph.<span class=\"hljs-title function_ invoke__\">entry</span>(v2).<span class=\"hljs-title function_ invoke__\">or_insert_with</span>(BTreeMap::new);\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">single_vertex</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span>: Graph&lt;<span class=\"hljs-type\">isize</span>, <span class=\"hljs-type\">isize</span>&gt; = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        graph.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>());\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">None</span>);\n\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">0</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists));\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">single_edge</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_0</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_0.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">None</span>);\n        dists_0.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>)));\n\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">0</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_0));\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_1</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_1.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">None</span>);\n\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">1</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_1));\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">tree_1</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">None</span>);\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..<span class=\"hljs-number\">100</span> {\n            <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, i, i * <span class=\"hljs-number\">2</span>, i * <span class=\"hljs-number\">2</span>);\n            <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, i, i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>, i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>);\n\n            <span class=\"hljs-keyword\">match</span> dists[&amp;i] {\n                <span class=\"hljs-title function_ invoke__\">Some</span>((_, d)) =&gt; {\n                    dists.<span class=\"hljs-title function_ invoke__\">insert</span>(i * <span class=\"hljs-number\">2</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((i, d + i * <span class=\"hljs-number\">2</span>)));\n                    dists.<span class=\"hljs-title function_ invoke__\">insert</span>(i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((i, d + i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>)));\n                }\n                <span class=\"hljs-literal\">None</span> =&gt; {\n                    dists.<span class=\"hljs-title function_ invoke__\">insert</span>(i * <span class=\"hljs-number\">2</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((i, i * <span class=\"hljs-number\">2</span>)));\n                    dists.<span class=\"hljs-title function_ invoke__\">insert</span>(i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((i, i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>)));\n                }\n            }\n        }\n\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">1</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists));\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">graph_1</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">12</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-number\">60</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">10</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">20</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-number\">32</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">7</span>);\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_a</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_a.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-literal\">None</span>);\n        dists_a.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">12</span>)));\n        dists_a.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">44</span>)));\n        dists_a.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">32</span>)));\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-string\">&#x27;a&#x27;</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_a));\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_b</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_b.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-literal\">None</span>);\n        dists_b.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">10</span>)));\n        dists_b.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">22</span>)));\n        dists_b.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">54</span>)));\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-string\">&#x27;b&#x27;</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_b));\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_c</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_c.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-literal\">None</span>);\n        dists_c.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">20</span>)));\n        dists_c.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">32</span>)));\n        dists_c.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">30</span>)));\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-string\">&#x27;c&#x27;</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_c));\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_d</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_d.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-literal\">None</span>);\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-string\">&#x27;d&#x27;</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_d));\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_e</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_e.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-literal\">None</span>);\n        dists_e.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-number\">7</span>)));\n        dists_e.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">19</span>)));\n        dists_e.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">51</span>)));\n        dists_e.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">39</span>)));\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-string\">&#x27;e&#x27;</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_e));\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">graph_2</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">6</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">8</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, -<span class=\"hljs-number\">4</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">2</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">3</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">9</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>);\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_0</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_0.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">None</span>);\n        dists_0.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">2</span>)));\n        dists_0.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)));\n        dists_0.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">7</span>)));\n        dists_0.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">2</span>)));\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">0</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_0));\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_1</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_1.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">4</span>, -<span class=\"hljs-number\">1</span>)));\n        dists_1.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">None</span>);\n        dists_1.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>)));\n        dists_1.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">6</span>)));\n        dists_1.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">4</span>)));\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">1</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_1));\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_2</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_2.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">4</span>, -<span class=\"hljs-number\">3</span>)));\n        dists_2.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">2</span>)));\n        dists_2.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">None</span>);\n        dists_2.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">4</span>)));\n        dists_2.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">6</span>)));\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">2</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_2));\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_3</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_3.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">4</span>, -<span class=\"hljs-number\">6</span>)));\n        dists_3.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">5</span>)));\n        dists_3.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">3</span>, -<span class=\"hljs-number\">3</span>)));\n        dists_3.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-literal\">None</span>);\n        dists_3.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">9</span>)));\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">3</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_3));\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_4</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_4.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>)));\n        dists_4.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>)));\n        dists_4.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">7</span>)));\n        dists_4.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">10</span>)));\n        dists_4.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-literal\">None</span>);\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">4</span>), <span class=\"hljs-title function_ invoke__\">Some</span>(dists_4));\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">graph_with_negative_loop</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">6</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">8</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, -<span class=\"hljs-number\">4</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">4</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">3</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">9</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>);\n\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">0</span>), <span class=\"hljs-literal\">None</span>);\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">1</span>), <span class=\"hljs-literal\">None</span>);\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">2</span>), <span class=\"hljs-literal\">None</span>);\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">3</span>), <span class=\"hljs-literal\">None</span>);\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">bellman_ford</span>(&amp;graph, &amp;<span class=\"hljs-number\">4</span>), <span class=\"hljs-literal\">None</span>);\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "PalAditya",
      "email": "adityapal.nghss@gmail.com",
      "commits": 1
    },
    {
      "name": "Pierre Gimalac",
      "email": "pierre.gimalac@gmail.com",
      "commits": 1
    },
    {
      "name": "Taj",
      "email": "tjgurwara99@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Tahmeed Tarek",
      "email": "tahmeedtarek@gmail.com",
      "commits": 1
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "hasan",
      "email": "hasanuli10@gmail.com",
      "commits": 1
    },
    {
      "name": "ParthS007",
      "email": "parth1989shandilya@gmail.com",
      "commits": 1
    },
    {
      "name": "John Law",
      "email": "johnlaw.po@gmail.com",
      "commits": 1
    },
    {
      "name": "Aitor Fidalgo Sánchez",
      "email": "64830228+aitorfi@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Nishant Chatterjee",
      "email": "52992695+nishantc1527@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Maria Lungeanu",
      "email": "Maria.Lungeanu@anritsu.com",
      "commits": 1
    },
    {
      "name": "matkosoric",
      "email": "soric.matko@gmail.com",
      "commits": 1
    },
    {
      "name": "JakobZhao",
      "email": "52325554+JakobMusik@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "cclauss",
      "email": "cclauss@bluewin.ch",
      "commits": 1
    },
    {
      "name": "ashu01",
      "email": "as01hu@gmail.com",
      "commits": 1
    },
    {
      "name": "AlexDvorak",
      "email": "opti.jawsome@gmail.com",
      "commits": 2
    },
    {
      "name": "Libin Yang",
      "email": "szuyanglb@outlook.com",
      "commits": 2
    },
    {
      "name": "Mayank Mamgain",
      "email": "56592363+Mayank17M@users.noreply.github.com",
      "commits": 2
    },
    {
      "name": "Hassan",
      "email": "hassan.elseoudy@gmail.com",
      "commits": 2
    },
    {
      "name": "Sameer Ahmed Khan",
      "email": "68906588+sameerahmedk@users.noreply.github.com",
      "commits": 3
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 5
    },
    {
      "name": "arpanjain97",
      "email": "arpanjain97@gmail.com",
      "commits": 5
    }
  ],
  "explanationUrl": {
    "en": "https://github.com/TheAlgorithms/Algorithms-Explanation/tree/master/en/Data Structures/Graph/Bellman-Ford.md",
    "es": "https://github.com/TheAlgorithms/Algorithms-Explanation/tree/master/es/Estructuras de datos/Gráfico/Bellman Ford.md"
  }
}