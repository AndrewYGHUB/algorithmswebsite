{
  "slug": "bfs-zero-one-shortest-path",
  "name": "Bfs Zero One Shortest Path",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "graphs/bfs_zero_one_shortest_path.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/graphs/bfs_zero_one_shortest_path.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;\nFinding the shortest path in 0-1-graph in O(E + V) which is faster than dijkstra.\n0-1-graph is the weighted graph with the weights equal to 0 or 1.\nLink: https://codeforces.com/blog/entry/22276\n&quot;&quot;&quot;</span>\n<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\n\n<span class=\"hljs-keyword\">from</span> collections <span class=\"hljs-keyword\">import</span> deque\n<span class=\"hljs-keyword\">from</span> collections.abc <span class=\"hljs-keyword\">import</span> Iterator\n<span class=\"hljs-keyword\">from</span> dataclasses <span class=\"hljs-keyword\">import</span> dataclass\n\n\n<span class=\"hljs-meta\">@dataclass</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Edge</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;Weighted directed graph edge.&quot;&quot;&quot;</span>\n\n    destination_vertex: <span class=\"hljs-built_in\">int</span>\n    weight: <span class=\"hljs-built_in\">int</span>\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">AdjacencyList</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;Graph adjacency list.&quot;&quot;&quot;</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, size: <span class=\"hljs-built_in\">int</span></span>):\n        self._graph: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[Edge]] = [[] <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(size)]\n        self._size = size\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__getitem__</span>(<span class=\"hljs-params\">self, vertex: <span class=\"hljs-built_in\">int</span></span>) -&gt; Iterator[Edge]:\n        <span class=\"hljs-string\">&quot;&quot;&quot;Get all the vertices adjacent to the given one.&quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">iter</span>(self._graph[vertex])\n\n<span class=\"hljs-meta\">    @property</span>\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">size</span>(<span class=\"hljs-params\">self</span>):\n        <span class=\"hljs-keyword\">return</span> self._size\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_edge</span>(<span class=\"hljs-params\">self, from_vertex: <span class=\"hljs-built_in\">int</span>, to_vertex: <span class=\"hljs-built_in\">int</span>, weight: <span class=\"hljs-built_in\">int</span></span>):\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        &gt;&gt;&gt; g = AdjacencyList(2)\n        &gt;&gt;&gt; g.add_edge(0, 1, 0)\n        &gt;&gt;&gt; g.add_edge(1, 0, 1)\n        &gt;&gt;&gt; list(g[0])\n        [Edge(destination_vertex=1, weight=0)]\n        &gt;&gt;&gt; list(g[1])\n        [Edge(destination_vertex=0, weight=1)]\n        &gt;&gt;&gt; g.add_edge(0, 1, 2)\n        Traceback (most recent call last):\n            ...\n        ValueError: Edge weight must be either 0 or 1.\n        &gt;&gt;&gt; g.add_edge(0, 2, 1)\n        Traceback (most recent call last):\n            ...\n        ValueError: Vertex indexes must be in [0; size).\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">if</span> weight <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>):\n            <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&quot;Edge weight must be either 0 or 1.&quot;</span>)\n\n        <span class=\"hljs-keyword\">if</span> to_vertex &lt; <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">or</span> to_vertex &gt;= self.size:\n            <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&quot;Vertex indexes must be in [0; size).&quot;</span>)\n\n        self._graph[from_vertex].append(Edge(to_vertex, weight))\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_shortest_path</span>(<span class=\"hljs-params\">self, start_vertex: <span class=\"hljs-built_in\">int</span>, finish_vertex: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span> | <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        Return the shortest distance from start_vertex to finish_vertex in 0-1-graph.\n              1                  1         1\n         0---------&gt;3        6--------7&gt;-------&gt;8\n         |          ^        ^        ^         |1\n         |          |        |        |0        v\n        0|          |0      1|        9--------&gt;10\n         |          |        |        ^    1\n         v          |        |        |0\n         1---------&gt;2&lt;-------4-------&gt;5\n              0         1        1\n        &gt;&gt;&gt; g = AdjacencyList(11)\n        &gt;&gt;&gt; g.add_edge(0, 1, 0)\n        &gt;&gt;&gt; g.add_edge(0, 3, 1)\n        &gt;&gt;&gt; g.add_edge(1, 2, 0)\n        &gt;&gt;&gt; g.add_edge(2, 3, 0)\n        &gt;&gt;&gt; g.add_edge(4, 2, 1)\n        &gt;&gt;&gt; g.add_edge(4, 5, 1)\n        &gt;&gt;&gt; g.add_edge(4, 6, 1)\n        &gt;&gt;&gt; g.add_edge(5, 9, 0)\n        &gt;&gt;&gt; g.add_edge(6, 7, 1)\n        &gt;&gt;&gt; g.add_edge(7, 8, 1)\n        &gt;&gt;&gt; g.add_edge(8, 10, 1)\n        &gt;&gt;&gt; g.add_edge(9, 7, 0)\n        &gt;&gt;&gt; g.add_edge(9, 10, 1)\n        &gt;&gt;&gt; g.add_edge(1, 2, 2)\n        Traceback (most recent call last):\n            ...\n        ValueError: Edge weight must be either 0 or 1.\n        &gt;&gt;&gt; g.get_shortest_path(0, 3)\n        0\n        &gt;&gt;&gt; g.get_shortest_path(0, 4)\n        Traceback (most recent call last):\n            ...\n        ValueError: No path from start_vertex to finish_vertex.\n        &gt;&gt;&gt; g.get_shortest_path(4, 10)\n        2\n        &gt;&gt;&gt; g.get_shortest_path(4, 8)\n        2\n        &gt;&gt;&gt; g.get_shortest_path(0, 1)\n        0\n        &gt;&gt;&gt; g.get_shortest_path(1, 0)\n        Traceback (most recent call last):\n            ...\n        ValueError: No path from start_vertex to finish_vertex.\n        &quot;&quot;&quot;</span>\n        queue = deque([start_vertex])\n        distances: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span> | <span class=\"hljs-literal\">None</span>] = [<span class=\"hljs-literal\">None</span>] * self.size\n        distances[start_vertex] = <span class=\"hljs-number\">0</span>\n\n        <span class=\"hljs-keyword\">while</span> queue:\n            current_vertex = queue.popleft()\n            current_distance = distances[current_vertex]\n            <span class=\"hljs-keyword\">if</span> current_distance <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\n                <span class=\"hljs-keyword\">continue</span>\n\n            <span class=\"hljs-keyword\">for</span> edge <span class=\"hljs-keyword\">in</span> self[current_vertex]:\n                new_distance = current_distance + edge.weight\n                dest_vertex_distance = distances[edge.destination_vertex]\n                <span class=\"hljs-keyword\">if</span> (\n                    <span class=\"hljs-built_in\">isinstance</span>(dest_vertex_distance, <span class=\"hljs-built_in\">int</span>)\n                    <span class=\"hljs-keyword\">and</span> new_distance &gt;= dest_vertex_distance\n                ):\n                    <span class=\"hljs-keyword\">continue</span>\n                distances[edge.destination_vertex] = new_distance\n                <span class=\"hljs-keyword\">if</span> edge.weight == <span class=\"hljs-number\">0</span>:\n                    queue.appendleft(edge.destination_vertex)\n                <span class=\"hljs-keyword\">else</span>:\n                    queue.append(edge.destination_vertex)\n\n        <span class=\"hljs-keyword\">if</span> distances[finish_vertex] <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\n            <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&quot;No path from start_vertex to finish_vertex.&quot;</span>)\n\n        <span class=\"hljs-keyword\">return</span> distances[finish_vertex]\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">import</span> doctest\n\n    doctest.testmod()\n"
    }
  },
  "contributors": [
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 1
    },
    {
      "name": "hasan",
      "email": "hasanuli10@gmail.com",
      "commits": 1
    },
    {
      "name": "Phil Bazun",
      "email": "Phil9lne@gmail.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}