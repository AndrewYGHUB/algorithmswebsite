{
  "slug": "binary-tree",
  "name": "Binary Tree",
  "categories": [
    "datastructures",
    "tree"
  ],
  "body": {},
  "implementations": {
    "java": {
      "dir": "src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src/main/java/com/thealgorithms/datastructures/trees/BinaryTree.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.datastructures.trees;\n\n<span class=\"hljs-keyword\">import</span> java.util.Queue;\n<span class=\"hljs-keyword\">import</span> java.util.LinkedList;\n\n<span class=\"hljs-comment\">/**\n * This entire class is used to build a Binary Tree data structure. There is the\n * Node Class and the Tree Class, both explained below.\n */</span>\n<span class=\"hljs-comment\">/**\n * A binary tree is a data structure in which an element has two\n * successors(children). The left child is usually smaller than the parent, and\n * the right child is usually bigger.\n *\n * <span class=\"hljs-doctag\">@author</span> Unknown\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BinaryTree</span> {\n\n    <span class=\"hljs-comment\">/**\n     * This class implements the nodes that will go on the Binary Tree. They\n     * consist of the data in them, the node to the left, the node to the right,\n     * and the parent from which they came from.\n     *\n     * <span class=\"hljs-doctag\">@author</span> Unknown\n     */</span>\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span> {\n\n        <span class=\"hljs-comment\">/**\n         * Data for the node\n         */</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> data;\n        <span class=\"hljs-comment\">/**\n         * The Node to the left of this one\n         */</span>\n        <span class=\"hljs-keyword\">public</span> Node left;\n        <span class=\"hljs-comment\">/**\n         * The Node to the right of this one\n         */</span>\n        <span class=\"hljs-keyword\">public</span> Node right;\n        <span class=\"hljs-comment\">/**\n         * The parent of this node\n         */</span>\n        <span class=\"hljs-keyword\">public</span> Node parent;\n\n        <span class=\"hljs-comment\">/**\n         * Constructor of Node\n         *\n         * <span class=\"hljs-doctag\">@param</span> value Value to put in the node\n         */</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Node</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> value)</span> {\n            data = value;\n            left = <span class=\"hljs-literal\">null</span>;\n            right = <span class=\"hljs-literal\">null</span>;\n            parent = <span class=\"hljs-literal\">null</span>;\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * The root of the Binary Tree\n     */</span>\n    <span class=\"hljs-keyword\">private</span> Node root;\n\n    <span class=\"hljs-comment\">/**\n     * Constructor\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">BinaryTree</span><span class=\"hljs-params\">()</span> {\n        root = <span class=\"hljs-literal\">null</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Parameterized Constructor\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">BinaryTree</span><span class=\"hljs-params\">(Node root)</span> {\n        <span class=\"hljs-built_in\">this</span>.root = root;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Method to find a Node with a certain value\n     *\n     * <span class=\"hljs-doctag\">@param</span> key Value being looked for\n     * <span class=\"hljs-doctag\">@return</span> The node if it finds it, otherwise returns the parent\n     */</span>\n    <span class=\"hljs-keyword\">public</span> Node <span class=\"hljs-title function_\">find</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> {\n        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">current</span> <span class=\"hljs-operator\">=</span> root;\n        <span class=\"hljs-keyword\">while</span> (current != <span class=\"hljs-literal\">null</span>) {\n            <span class=\"hljs-keyword\">if</span> (key &lt; current.data) {\n                <span class=\"hljs-keyword\">if</span> (current.left == <span class=\"hljs-literal\">null</span>) {\n                    <span class=\"hljs-keyword\">return</span> current; <span class=\"hljs-comment\">// The key isn&#x27;t exist, returns the parent</span>\n                }\n                current = current.left;\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (key &gt; current.data) {\n                <span class=\"hljs-keyword\">if</span> (current.right == <span class=\"hljs-literal\">null</span>) {\n                    <span class=\"hljs-keyword\">return</span> current;\n                }\n                current = current.right;\n            } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-comment\">// If you find the value return it</span>\n                <span class=\"hljs-keyword\">return</span> current;\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">null</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Inserts certain value into the Binary Tree\n     *\n     * <span class=\"hljs-doctag\">@param</span> value Value to be inserted\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">put</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> value)</span> {\n        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">newNode</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(value);\n        <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">null</span>) {\n            root = newNode;\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// This will return the soon to be parent of the value you&#x27;re inserting</span>\n            <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">parent</span> <span class=\"hljs-operator\">=</span> find(value);\n\n            <span class=\"hljs-comment\">// This if/else assigns the new node to be either the left or right child of the parent</span>\n            <span class=\"hljs-keyword\">if</span> (value &lt; parent.data) {\n                parent.left = newNode;\n                parent.left.parent = parent;\n                <span class=\"hljs-keyword\">return</span>;\n            } <span class=\"hljs-keyword\">else</span> {\n                parent.right = newNode;\n                parent.right.parent = parent;\n                <span class=\"hljs-keyword\">return</span>;\n            }\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Deletes a given value from the Binary Tree\n     *\n     * <span class=\"hljs-doctag\">@param</span> value Value to be deleted\n     * <span class=\"hljs-doctag\">@return</span> If the value was deleted\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">remove</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> value)</span> {\n        <span class=\"hljs-comment\">// temp is the node to be deleted</span>\n        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">temp</span> <span class=\"hljs-operator\">=</span> find(value);\n\n        <span class=\"hljs-comment\">// If the value doesn&#x27;t exist</span>\n        <span class=\"hljs-keyword\">if</span> (temp.data != value) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        }\n\n        <span class=\"hljs-comment\">// No children</span>\n        <span class=\"hljs-keyword\">if</span> (temp.right == <span class=\"hljs-literal\">null</span> &amp;&amp; temp.left == <span class=\"hljs-literal\">null</span>) {\n            <span class=\"hljs-keyword\">if</span> (temp == root) {\n                root = <span class=\"hljs-literal\">null</span>;\n            } <span class=\"hljs-comment\">// This if/else assigns the new node to be either the left or right child of the parent</span>\n            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (temp.parent.data &lt; temp.data) {\n                temp.parent.right = <span class=\"hljs-literal\">null</span>;\n            } <span class=\"hljs-keyword\">else</span> {\n                temp.parent.left = <span class=\"hljs-literal\">null</span>;\n            }\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n        } <span class=\"hljs-comment\">// Two children</span>\n        <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (temp.left != <span class=\"hljs-literal\">null</span> &amp;&amp; temp.right != <span class=\"hljs-literal\">null</span>) {\n            <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">successor</span> <span class=\"hljs-operator\">=</span> findSuccessor(temp);\n\n            <span class=\"hljs-comment\">// The left tree of temp is made the left tree of the successor</span>\n            successor.left = temp.left;\n            successor.left.parent = successor;\n\n            <span class=\"hljs-comment\">// If the successor has a right child, the child&#x27;s grandparent is it&#x27;s new parent</span>\n            <span class=\"hljs-keyword\">if</span> (successor.parent != temp) {\n                <span class=\"hljs-keyword\">if</span> (successor.right != <span class=\"hljs-literal\">null</span>) {\n                    successor.right.parent = successor.parent;\n                    successor.parent.left = successor.right;\n                    successor.right = temp.right;\n                    successor.right.parent = successor;\n                } <span class=\"hljs-keyword\">else</span> {\n                    successor.parent.left = <span class=\"hljs-literal\">null</span>;\n                    successor.right = temp.right;\n                    successor.right.parent = successor;\n                }\n            }\n\n            <span class=\"hljs-keyword\">if</span> (temp == root) {\n                successor.parent = <span class=\"hljs-literal\">null</span>;\n                root = successor;\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n            } <span class=\"hljs-comment\">// If you&#x27;re not deleting the root</span>\n            <span class=\"hljs-keyword\">else</span> {\n                successor.parent = temp.parent;\n\n                <span class=\"hljs-comment\">// This if/else assigns the new node to be either the left or right child of the parent</span>\n                <span class=\"hljs-keyword\">if</span> (temp.parent.data &lt; temp.data) {\n                    temp.parent.right = successor;\n                } <span class=\"hljs-keyword\">else</span> {\n                    temp.parent.left = successor;\n                }\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n            }\n        } <span class=\"hljs-comment\">// One child</span>\n        <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-comment\">// If it has a right child</span>\n            <span class=\"hljs-keyword\">if</span> (temp.right != <span class=\"hljs-literal\">null</span>) {\n                <span class=\"hljs-keyword\">if</span> (temp == root) {\n                    root = temp.right;\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n                }\n\n                temp.right.parent = temp.parent;\n\n                <span class=\"hljs-comment\">// Assigns temp to left or right child</span>\n                <span class=\"hljs-keyword\">if</span> (temp.data &lt; temp.parent.data) {\n                    temp.parent.left = temp.right;\n                } <span class=\"hljs-keyword\">else</span> {\n                    temp.parent.right = temp.right;\n                }\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n            } <span class=\"hljs-comment\">// If it has a left child</span>\n            <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-keyword\">if</span> (temp == root) {\n                    root = temp.left;\n                    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n                }\n\n                temp.left.parent = temp.parent;\n\n                <span class=\"hljs-comment\">// Assigns temp to left or right side</span>\n                <span class=\"hljs-keyword\">if</span> (temp.data &lt; temp.parent.data) {\n                    temp.parent.left = temp.left;\n                } <span class=\"hljs-keyword\">else</span> {\n                    temp.parent.right = temp.left;\n                }\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n            }\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * This method finds the Successor to the Node given. Move right once and go\n     * left down the tree as far as you can\n     *\n     * <span class=\"hljs-doctag\">@param</span> n Node that you want to find the Successor of\n     * <span class=\"hljs-doctag\">@return</span> The Successor of the node\n     */</span>\n    <span class=\"hljs-keyword\">public</span> Node <span class=\"hljs-title function_\">findSuccessor</span><span class=\"hljs-params\">(Node n)</span> {\n        <span class=\"hljs-keyword\">if</span> (n.right == <span class=\"hljs-literal\">null</span>) {\n            <span class=\"hljs-keyword\">return</span> n;\n        }\n        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">current</span> <span class=\"hljs-operator\">=</span> n.right;\n        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">parent</span> <span class=\"hljs-operator\">=</span> n.right;\n        <span class=\"hljs-keyword\">while</span> (current != <span class=\"hljs-literal\">null</span>) {\n            parent = current;\n            current = current.left;\n        }\n        <span class=\"hljs-keyword\">return</span> parent;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Returns the root of the Binary Tree\n     *\n     * <span class=\"hljs-doctag\">@return</span> the root of the Binary Tree\n     */</span>\n    <span class=\"hljs-keyword\">public</span> Node <span class=\"hljs-title function_\">getRoot</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> root;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Prints leftChild - root - rightChild This is the equivalent of a depth\n     * first search\n     *\n     * <span class=\"hljs-doctag\">@param</span> localRoot The local root of the binary tree\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">inOrder</span><span class=\"hljs-params\">(Node localRoot)</span> {\n        <span class=\"hljs-keyword\">if</span> (localRoot != <span class=\"hljs-literal\">null</span>) {\n            inOrder(localRoot.left);\n            System.out.print(localRoot.data + <span class=\"hljs-string\">&quot; &quot;</span>);\n            inOrder(localRoot.right);\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Prints root - leftChild - rightChild\n     *\n     * <span class=\"hljs-doctag\">@param</span> localRoot The local root of the binary tree\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">preOrder</span><span class=\"hljs-params\">(Node localRoot)</span> {\n        <span class=\"hljs-keyword\">if</span> (localRoot != <span class=\"hljs-literal\">null</span>) {\n            System.out.print(localRoot.data + <span class=\"hljs-string\">&quot; &quot;</span>);\n            preOrder(localRoot.left);\n            preOrder(localRoot.right);\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Prints rightChild - leftChild - root\n     *\n     * <span class=\"hljs-doctag\">@param</span> localRoot The local root of the binary tree\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">postOrder</span><span class=\"hljs-params\">(Node localRoot)</span> {\n        <span class=\"hljs-keyword\">if</span> (localRoot != <span class=\"hljs-literal\">null</span>) {\n            postOrder(localRoot.left);\n            postOrder(localRoot.right);\n            System.out.print(localRoot.data + <span class=\"hljs-string\">&quot; &quot;</span>);\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Prints the tree in a breadth first search order This is similar to\n     * pre-order traversal, but instead of being implemented with a stack (or\n     * recursion), it is implemented with a queue\n     *\n     * <span class=\"hljs-doctag\">@param</span> localRoot The local root of the binary tree\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">bfs</span><span class=\"hljs-params\">(Node localRoot)</span> {\n        <span class=\"hljs-comment\">// Create a queue for the order of the nodes</span>\n        Queue&lt;Node&gt; queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;Node&gt;();\n\n        <span class=\"hljs-comment\">// If the give root is null, then we don&#x27;t add to the queue</span>\n        <span class=\"hljs-comment\">// and won&#x27;t do anything</span>\n        <span class=\"hljs-keyword\">if</span> (localRoot != <span class=\"hljs-literal\">null</span>) {\n            queue.add(localRoot);\n        }\n\n        <span class=\"hljs-comment\">// Continue until the queue is empty</span>\n        <span class=\"hljs-keyword\">while</span> (!queue.isEmpty()) {\n            <span class=\"hljs-comment\">// Get the next node on the queue to visit</span>\n            localRoot = queue.remove();\n\n            <span class=\"hljs-comment\">// Print the data from the node we are visiting</span>\n            System.out.print(localRoot.data + <span class=\"hljs-string\">&quot; &quot;</span>);\n\n            <span class=\"hljs-comment\">// Add the children to the queue if not null</span>\n            <span class=\"hljs-keyword\">if</span> (localRoot.right != <span class=\"hljs-literal\">null</span>) {\n                queue.add(localRoot.right);\n            }\n            <span class=\"hljs-keyword\">if</span> (localRoot.left != <span class=\"hljs-literal\">null</span>) {\n                queue.add(localRoot.left);\n            }\n        }\n    }\n}\n"
    },
    "haskell": {
      "dir": "src/BinaryTree/BinaryTree.hs",
      "url": "https://github.com/TheAlgorithms/haskell/tree/master/src/BinaryTree/BinaryTree.hs",
      "code": "<span class=\"hljs-keyword\">module</span> BinaryTree.BinaryTree <span class=\"hljs-keyword\">where</span>\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-keyword\">qualified</span> Data.List <span class=\"hljs-keyword\">as</span> L\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> <span class=\"hljs-type\">BTree</span> a = <span class=\"hljs-type\">Empty</span> | <span class=\"hljs-type\">Node</span> a (<span class=\"hljs-type\">BTree</span> <span class=\"hljs-title\">a</span>) (<span class=\"hljs-type\">BTree</span> <span class=\"hljs-title\">a</span>) <span class=\"hljs-keyword\">deriving</span> (<span class=\"hljs-type\">Show</span>)</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">data</span> <span class=\"hljs-type\">Side</span> = <span class=\"hljs-type\">LeftSide</span> | <span class=\"hljs-type\">RightSide</span> <span class=\"hljs-keyword\">deriving</span> (<span class=\"hljs-type\">Eq</span>, <span class=\"hljs-type\">Show</span>)</span>\n\n<span class=\"hljs-comment\">-- Get subtree on specified side</span>\n<span class=\"hljs-title\">getSubTree</span> :: <span class=\"hljs-type\">Side</span> -&gt; <span class=\"hljs-type\">BTree</span> a -&gt; <span class=\"hljs-type\">BTree</span> a\n<span class=\"hljs-title\">getSubTree</span> _ <span class=\"hljs-type\">Empty</span> = <span class=\"hljs-type\">Empty</span>\n<span class=\"hljs-title\">getSubTree</span> s (<span class=\"hljs-type\">Node</span> _ l r) = <span class=\"hljs-keyword\">if</span> s == <span class=\"hljs-type\">LeftSide</span> <span class=\"hljs-keyword\">then</span> l <span class=\"hljs-keyword\">else</span> r\n\n<span class=\"hljs-comment\">-- Get Left Subtree</span>\n<span class=\"hljs-title\">getLeftTree</span> :: <span class=\"hljs-type\">BTree</span> a -&gt; <span class=\"hljs-type\">BTree</span> a\n<span class=\"hljs-title\">getLeftTree</span> <span class=\"hljs-type\">Empty</span> = <span class=\"hljs-type\">Empty</span>\n<span class=\"hljs-title\">getLeftTree</span> (<span class=\"hljs-type\">Node</span> _ l _) = l\n\n<span class=\"hljs-comment\">-- Get Right Subtree</span>\n<span class=\"hljs-title\">getRightTree</span> :: <span class=\"hljs-type\">BTree</span> a -&gt; <span class=\"hljs-type\">BTree</span> a\n<span class=\"hljs-title\">getRightTree</span> <span class=\"hljs-type\">Empty</span> = <span class=\"hljs-type\">Empty</span>\n<span class=\"hljs-title\">getRightTree</span> (<span class=\"hljs-type\">Node</span> _ _ r) = r\n\n<span class=\"hljs-comment\">-- Get string representation of node Data</span>\n<span class=\"hljs-title\">nodeShow</span> :: (<span class=\"hljs-type\">Show</span> a) =&gt; <span class=\"hljs-type\">BTree</span> a -&gt; <span class=\"hljs-type\">String</span>\n<span class=\"hljs-title\">nodeShow</span> <span class=\"hljs-type\">Empty</span> = <span class=\"hljs-string\">&quot;&quot;</span>\n<span class=\"hljs-title\">nodeShow</span> (<span class=\"hljs-type\">Node</span> val _ _) = show val\n\n<span class=\"hljs-comment\">-- Depth first traversal</span>\n<span class=\"hljs-title\">dfsList</span> :: <span class=\"hljs-type\">BTree</span> a -&gt; [a]\n<span class=\"hljs-title\">dfsList</span> <span class=\"hljs-type\">Empty</span> = []\n<span class=\"hljs-title\">dfsList</span> (<span class=\"hljs-type\">Node</span> n l r) = [n] ++ (dfsList l) ++ (dfsList r)\n\n<span class=\"hljs-comment\">-- Breadth first traversal.</span>\n<span class=\"hljs-title\">bfsList</span> :: <span class=\"hljs-type\">BTree</span> a -&gt; [a]\n<span class=\"hljs-title\">bfsList</span> <span class=\"hljs-type\">Empty</span> = []\n<span class=\"hljs-title\">bfsList</span> t = concat $ takeWhile (\\l -&gt; (length l) &gt; <span class=\"hljs-number\">0</span>) [getLevel i <span class=\"hljs-number\">0</span> t | i &lt;- [<span class=\"hljs-number\">0</span>..]]\n\n<span class=\"hljs-comment\">-- Get all nodes from a single level in the tree.</span>\n<span class=\"hljs-title\">getLevel</span> :: (<span class=\"hljs-type\">Num</span> b, <span class=\"hljs-type\">Enum</span> b, <span class=\"hljs-type\">Eq</span> b) =&gt; b -&gt; b -&gt; <span class=\"hljs-type\">BTree</span> a -&gt; [a]\n<span class=\"hljs-title\">getLevel</span> _ _ <span class=\"hljs-type\">Empty</span> = []\n<span class=\"hljs-title\">getLevel</span> <span class=\"hljs-number\">0</span> _ (<span class=\"hljs-type\">Node</span> n l r) = [n]\n<span class=\"hljs-title\">getLevel</span> level i (<span class=\"hljs-type\">Node</span> n l r)\n    | i == level = [n]\n    | otherwise = (getLevel level (i+<span class=\"hljs-number\">1</span>) l) ++ (getLevel level (i+<span class=\"hljs-number\">1</span>) r)\n\n<span class=\"hljs-comment\">-- Get a list of lists of nodes in each level</span>\n<span class=\"hljs-title\">getLevels</span> :: <span class=\"hljs-type\">BTree</span> a -&gt; [[a]]\n<span class=\"hljs-title\">getLevels</span> t = takeWhile (\\l -&gt; (length l) &gt; <span class=\"hljs-number\">0</span>) [getLevel i <span class=\"hljs-number\">0</span> t | i &lt;- [<span class=\"hljs-number\">0</span>..]]\n\n<span class=\"hljs-comment\">-- Get the depth of the tree</span>\n<span class=\"hljs-title\">getDepth</span> :: <span class=\"hljs-type\">BTree</span> a -&gt; <span class=\"hljs-type\">Int</span>\n<span class=\"hljs-title\">getDepth</span> t = length $ getLevels t\n\n<span class=\"hljs-comment\">-- Generate a Binary Tree from a list of values.</span>\n<span class=\"hljs-comment\">-- Assume list is in breadth first order.</span>\n<span class=\"hljs-title\">fromList</span> :: [a] -&gt; <span class=\"hljs-type\">BTree</span> a\n<span class=\"hljs-title\">fromList</span> lst = fromListInt <span class=\"hljs-number\">0</span> lst\n<span class=\"hljs-comment\">-- Internal function to convert list to tree.</span>\n<span class=\"hljs-title\">fromListInt</span> :: <span class=\"hljs-type\">Int</span> -&gt; [a] -&gt; <span class=\"hljs-type\">BTree</span> a\n<span class=\"hljs-title\">fromListInt</span> _ [] = <span class=\"hljs-type\">Empty</span>\n<span class=\"hljs-title\">fromListInt</span> i lst@(x:xs) = <span class=\"hljs-type\">Node</span> x (fromListInt (<span class=\"hljs-number\">2</span>*i + <span class=\"hljs-number\">1</span>) (drop (i+<span class=\"hljs-number\">1</span>) lst)) \n                                  (fromListInt (<span class=\"hljs-number\">2</span>*i + <span class=\"hljs-number\">2</span>) (drop (i+<span class=\"hljs-number\">2</span>) lst))\n\n<span class=\"hljs-comment\">-- Count number of nodes in the tree.</span>\n<span class=\"hljs-title\">numNodes</span> :: <span class=\"hljs-type\">BTree</span> a -&gt; <span class=\"hljs-type\">Int</span>\n<span class=\"hljs-title\">numNodes</span> t = length $ bfsList t\n\n<span class=\"hljs-comment\">-- Pretty Print a Binary Tree</span>\n<span class=\"hljs-title\">simplePrint</span> :: (<span class=\"hljs-type\">Show</span> a) =&gt; <span class=\"hljs-type\">BTree</span> a -&gt; <span class=\"hljs-type\">String</span>\n<span class=\"hljs-title\">simplePrint</span> <span class=\"hljs-type\">Empty</span> = <span class=\"hljs-string\">&quot;&quot;</span>\n<span class=\"hljs-title\">simplePrint</span> t = (nodeShow t) ++ <span class=\"hljs-string\">&quot; &quot;</span> ++ (simplePrint $ getLeftTree t) ++ (simplePrint $ getRightTree t)"
    }
  },
  "contributors": [
    {
      "name": "Stepfen Shawn",
      "email": "m18824909883@163.com",
      "commits": 1
    },
    {
      "name": "Artur Parowicz",
      "email": "arturparowicz@gmail,com",
      "commits": 1
    },
    {
      "name": "Taj",
      "email": "tjgurwara99@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Rak Laptudirm",
      "email": "raklaptudirm@gmail.com",
      "commits": 1
    },
    {
      "name": "liyl",
      "email": "30368453+yaolin-Li@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "babybug",
      "email": "bugbinbo@outlook.com",
      "commits": 1
    },
    {
      "name": "Himanshu Shekhar",
      "email": "himanshushekharb16@gmail.com",
      "commits": 1
    },
    {
      "name": "Aitor Fidalgo Sánchez",
      "email": "64830228+aitorfi@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Ian Cowan",
      "email": "38896380+iccowan@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Amit Kumar",
      "email": "kumanoit@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "1700022814",
      "email": "512620936@qq.com",
      "commits": 1
    },
    {
      "name": "khalil2535",
      "email": "khalil2535@localhost",
      "commits": 1
    },
    {
      "name": "Miki Pokryvailo",
      "email": "mpokryva@gmail.com",
      "commits": 1
    },
    {
      "name": "zacharyjones123",
      "email": "zrjones@ncsu.edu",
      "commits": 1
    },
    {
      "name": "Rian Gallagher",
      "email": "rianogallagher@gmail.com",
      "commits": 1
    },
    {
      "name": "Libin Yang",
      "email": "szuyanglb@outlook.com",
      "commits": 2
    },
    {
      "name": "Ashwin Narayan",
      "email": "ashwinnarayan1994@gmail.com",
      "commits": 5
    }
  ],
  "explanationUrl": {}
}