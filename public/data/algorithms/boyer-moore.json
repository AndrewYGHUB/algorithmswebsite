{
  "slug": "boyer-moore",
  "name": "Boyer Moore",
  "categories": [
    "strings"
  ],
  "body": {},
  "implementations": {
    "javascript": {
      "dir": "String/BoyerMoore.js",
      "url": "https://github.com/TheAlgorithms/javascript/tree/master/String/BoyerMoore.js",
      "code": "<span class=\"hljs-comment\">/*\n *\n *\n *Implementation of the Boyer-Moore String Search Algorithm.\n *The Boyer–Moore string search algorithm allows linear time in\n *search by skipping indices when searching inside a string for a pattern.\n *\n *\n *\n *\n **/</span>\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">buildBadMatchTable</span> = (<span class=\"hljs-params\">str</span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> tableObj = {}\n  <span class=\"hljs-keyword\">const</span> strLength = str.<span class=\"hljs-property\">length</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; strLength - <span class=\"hljs-number\">1</span>; i++) {\n    tableObj[str[i]] = strLength - <span class=\"hljs-number\">1</span> - i\n  }\n  <span class=\"hljs-keyword\">if</span> (tableObj[str[strLength - <span class=\"hljs-number\">1</span>]] === <span class=\"hljs-literal\">undefined</span>) {\n    tableObj[str[strLength - <span class=\"hljs-number\">1</span>]] = strLength\n  }\n  <span class=\"hljs-keyword\">return</span> tableObj\n}\n\n<span class=\"hljs-keyword\">const</span> <span class=\"hljs-title function_\">boyerMoore</span> = (<span class=\"hljs-params\">str, pattern</span>) =&gt; {\n  <span class=\"hljs-keyword\">const</span> badMatchTable = <span class=\"hljs-title function_\">buildBadMatchTable</span>(pattern)\n  <span class=\"hljs-keyword\">let</span> offset = <span class=\"hljs-number\">0</span>\n  <span class=\"hljs-keyword\">const</span> patternLastIndex = pattern.<span class=\"hljs-property\">length</span> - <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">const</span> maxOffset = str.<span class=\"hljs-property\">length</span> - pattern.<span class=\"hljs-property\">length</span>\n  <span class=\"hljs-comment\">// if the offset is bigger than maxOffset, cannot be found</span>\n  <span class=\"hljs-keyword\">while</span> (offset &lt;= maxOffset) {\n    <span class=\"hljs-keyword\">let</span> scanIndex = <span class=\"hljs-number\">0</span>\n    <span class=\"hljs-keyword\">while</span> (pattern[scanIndex] === str[scanIndex + offset]) {\n      <span class=\"hljs-keyword\">if</span> (scanIndex === patternLastIndex) {\n        <span class=\"hljs-comment\">// found at this index</span>\n        <span class=\"hljs-keyword\">return</span> offset\n      }\n      scanIndex++\n    }\n    <span class=\"hljs-keyword\">const</span> badMatchString = str[offset + patternLastIndex]\n    <span class=\"hljs-keyword\">if</span> (badMatchTable[badMatchString]) {\n      <span class=\"hljs-comment\">// increase the offset if it exists</span>\n      offset += badMatchTable[badMatchString]\n    } <span class=\"hljs-keyword\">else</span> {\n      offset++\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>\n}\n<span class=\"hljs-keyword\">export</span> { boyerMoore }\n"
    },
    "java": {
      "dir": "src/main/java/com/thealgorithms/others/BoyerMoore.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src/main/java/com/thealgorithms/others/BoyerMoore.java",
      "code": "<span class=\"hljs-comment\">/* this Code is the illustration of Boyer moore&#x27;s voting algorithm to\nfind the majority element is an array that appears more than n/2 times in an array\nwhere &quot;n&quot; is the length of the array.\nFor more information on the algorithm refer https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_majority_vote_algorithm\n */</span>\n<span class=\"hljs-keyword\">package</span> com.thealgorithms.others;\n\n<span class=\"hljs-keyword\">import</span> java.util.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BoyerMoore</span> {\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">findmajor</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] a)</span> {\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">count</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">cand</span> <span class=\"hljs-operator\">=</span> -<span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; a.length; i++) {\n            <span class=\"hljs-keyword\">if</span> (count == <span class=\"hljs-number\">0</span>) {\n                cand = a[i];\n                count = <span class=\"hljs-number\">1</span>;\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-keyword\">if</span> (a[i] == cand) {\n                    count++;\n                } <span class=\"hljs-keyword\">else</span> {\n                    count--;\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; a.length; i++) {\n            <span class=\"hljs-keyword\">if</span> (a[i] == cand) {\n                count++;\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> (count &gt; (a.length / <span class=\"hljs-number\">2</span>)) {\n            <span class=\"hljs-keyword\">return</span> cand;\n        }\n        <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String args[])</span> {\n        <span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">input</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> input.nextInt();\n        <span class=\"hljs-type\">int</span> a[] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[n];\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; n; i++) {\n            a[i] = input.nextInt();\n        }\n        System.out.println(<span class=\"hljs-string\">&quot;the majority element is &quot;</span> + findmajor(a));\n\n    }\n}\n"
    },
    "go": {
      "dir": "strings/search/boyermoore.go",
      "url": "https://github.com/TheAlgorithms/go/tree/master/strings/search/boyermoore.go",
      "code": "<span class=\"hljs-keyword\">package</span> search\n\n<span class=\"hljs-comment\">// Implementation of boyer moore string search</span>\n<span class=\"hljs-comment\">// O(l) where l=len(text)</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">BoyerMoore</span><span class=\"hljs-params\">(text <span class=\"hljs-type\">string</span>, pattern <span class=\"hljs-type\">string</span>)</span></span> []<span class=\"hljs-type\">int</span> {\n\t<span class=\"hljs-keyword\">var</span> positions []<span class=\"hljs-type\">int</span>\n\n\tl := <span class=\"hljs-built_in\">len</span>(text)\n\tn := <span class=\"hljs-built_in\">len</span>(pattern)\n\n\t<span class=\"hljs-comment\">// using booyer moore horspool modification</span>\n\t<span class=\"hljs-comment\">// O(n) space instead of O(n**2)</span>\n\tbcr := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">byte</span>]<span class=\"hljs-type\">int</span>)\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; n<span class=\"hljs-number\">-1</span>; i++ {\n\t\tbcr[pattern[i]] = n - i - <span class=\"hljs-number\">1</span>\n\t}\n\n\t<span class=\"hljs-comment\">// Apostolico–Giancarlo modification</span>\n\t<span class=\"hljs-comment\">// allow to skip patterns that we know matches</span>\n\t<span class=\"hljs-comment\">// let us do O(l) instead of O(ln)</span>\n\tskips := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">int</span>)\n\t<span class=\"hljs-keyword\">for</span> _, s := <span class=\"hljs-keyword\">range</span> bcr {\n\t\ti := <span class=\"hljs-number\">0</span>\n\t\t<span class=\"hljs-keyword\">for</span> ; i &lt; n-s; i++ {\n\t\t\t<span class=\"hljs-keyword\">if</span> pattern[n<span class=\"hljs-number\">-1</span>-i] != pattern[n<span class=\"hljs-number\">-1</span>-s-i] {\n\t\t\t\t<span class=\"hljs-keyword\">break</span>\n\t\t\t}\n\t\t}\n\t\tskips[s] = i\n\t}\n\n\tskip := <span class=\"hljs-number\">0</span>\n\tjump := n\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; l-n+<span class=\"hljs-number\">1</span>; {\n\t\tskip = skips[jump]\n\t\t<span class=\"hljs-keyword\">for</span> k := n - <span class=\"hljs-number\">1</span>; k &gt; <span class=\"hljs-number\">-1</span>; k-- {\n\t\t\t<span class=\"hljs-keyword\">if</span> text[i+k] != pattern[k] {\n\t\t\t\tjump, ok := bcr[text[i+k]]\n\t\t\t\t<span class=\"hljs-keyword\">if</span> !ok {\n\t\t\t\t\tjump = n\n\t\t\t\t}\n\t\t\t\ti += jump\n\t\t\t\t<span class=\"hljs-keyword\">break</span>\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">if</span> k == n-jump {\n\t\t\t\tk -= skip\n\t\t\t}\n\t\t\t<span class=\"hljs-keyword\">if</span> k == <span class=\"hljs-number\">0</span> {\n\t\t\t\tpositions = <span class=\"hljs-built_in\">append</span>(positions, i)\n\t\t\t\tjump = <span class=\"hljs-number\">1</span>\n\t\t\t\ti += jump\n\t\t\t}\n\t\t}\n\t}\n\n\t<span class=\"hljs-keyword\">return</span> positions\n}\n"
    },
    "c-sharp": {
      "dir": "./Algorithms/Strings/BoyerMoore.cs",
      "url": "https:/github.com/TheAlgorithms/C-Sharp/tree/master/Algorithms/Strings/BoyerMoore.cs",
      "code": "<span class=\"hljs-keyword\">using</span> System;\n\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">Algorithms.Strings</span>\n{\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     The idea:   You compare the pattern with the text from right to left.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     If the text symbol that is compared with the rightmost pattern symbol</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     does not occur in the pattern at all, then the pattern can be shifted</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     by m positions behind this text symbol.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Complexity:</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Time:   Preprocessing: O(m²)</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Comparison: O(mn)</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Space:  O(m + a)</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     where   m - pattern length</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     n - text length</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     a - alphabet length.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Source:     https://www.inf.hs-flensburg.de/lang/algorithmen/pattern/bmen.htm</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BoyerMoore</span>\n    {\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Finds the index of the first occurrence of the pattern <span class=\"hljs-doctag\">&lt;c&gt;</span>p<span class=\"hljs-doctag\">&lt;/c&gt;</span> in <span class=\"hljs-doctag\">&lt;c&gt;</span>t<span class=\"hljs-doctag\">&lt;/c&gt;</span>.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;t&quot;&gt;</span>Input text.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;p&quot;&gt;</span>Search pattern.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Index of the pattern in text or -1 if the pattern  was not found.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">FindFirstOccurrence</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> t, <span class=\"hljs-built_in\">string</span> p</span>)</span>\n        {\n            <span class=\"hljs-comment\">// Pattern length</span>\n            <span class=\"hljs-keyword\">var</span> m = p.Length;\n\n            <span class=\"hljs-comment\">// Text length</span>\n            <span class=\"hljs-keyword\">var</span> n = t.Length;\n\n            <span class=\"hljs-comment\">// For each symbol of the alphabet, the position of its rightmost occurrence in the pattern,</span>\n            <span class=\"hljs-comment\">// or -1 if the symbol does not occur in the pattern.</span>\n            <span class=\"hljs-built_in\">int</span>[] badChar = BadCharacterRule(p, m);\n\n            <span class=\"hljs-comment\">// Each entry goodSuffix[i] contains the shift distance of the pattern</span>\n            <span class=\"hljs-comment\">// if a mismatch at position i – 1 occurs, i.e. if the suffix of the pattern starting at position i has matched.</span>\n            <span class=\"hljs-built_in\">int</span>[] goodSuffix = GoodSuffixRule(p, m);\n\n            <span class=\"hljs-comment\">// Index in text</span>\n            <span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>;\n\n            <span class=\"hljs-comment\">// Index in pattern</span>\n            <span class=\"hljs-built_in\">int</span> j;\n\n            <span class=\"hljs-keyword\">while</span> (i &lt;= n - m)\n            {\n                <span class=\"hljs-comment\">// Starting at end of pattern</span>\n                j = m - <span class=\"hljs-number\">1</span>;\n\n                <span class=\"hljs-comment\">// While matching</span>\n                <span class=\"hljs-keyword\">while</span> (j &gt;= <span class=\"hljs-number\">0</span> &amp;&amp; p[j] == t[i + j])\n                {\n                    j--;\n                }\n\n                <span class=\"hljs-comment\">// Pattern found</span>\n                <span class=\"hljs-keyword\">if</span> (j &lt; <span class=\"hljs-number\">0</span>)\n                {\n                    <span class=\"hljs-keyword\">return</span> i;\n                }\n\n                <span class=\"hljs-comment\">// Pattern is shifted by the maximum of the values</span>\n                <span class=\"hljs-comment\">// given by the good-suffix and the bad-character heuristics</span>\n                i += Math.Max(goodSuffix[j + <span class=\"hljs-number\">1</span>], j - badChar[t[i + j]]);\n            }\n\n            <span class=\"hljs-comment\">// Pattern not found</span>\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Finds out the position of its rightmost occurrence in the pattern for each symbol of the alphabet,</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     or -1 if the symbol does not occur in the pattern.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;p&quot;&gt;</span>Search pattern.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;m&quot;&gt;</span>Length of the pattern.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Array of the named postition for each symbol of the alphabet.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">int</span>[] <span class=\"hljs-title\">BadCharacterRule</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> p, <span class=\"hljs-built_in\">int</span> m</span>)</span>\n        {\n            <span class=\"hljs-comment\">// For each character (note that there are more than 256 characters)</span>\n            <span class=\"hljs-built_in\">int</span>[] badChar = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[<span class=\"hljs-number\">256</span>];\n            Array.Fill(badChar, <span class=\"hljs-number\">-1</span>);\n\n            <span class=\"hljs-comment\">// Iterate from left to right over the pattern</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; m; j++)\n            {\n                badChar[p[j]] = j;\n            }\n\n            <span class=\"hljs-keyword\">return</span> badChar;\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Finds out the shift distance of the pattern if a mismatch at position i – 1 occurs</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     for each character of the pattern, i.e. if the suffix of the pattern starting at position i has matched.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;p&quot;&gt;</span>Search pattern.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;m&quot;&gt;</span>Length of the pattern.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Array of the named shift distance for each character of the pattern.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">int</span>[] <span class=\"hljs-title\">GoodSuffixRule</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> p, <span class=\"hljs-built_in\">int</span> m</span>)</span>\n        {\n            <span class=\"hljs-comment\">// CASE 1</span>\n            <span class=\"hljs-comment\">// The matching suffix occurs somewhere else in the pattern</span>\n            <span class=\"hljs-comment\">// --&gt; matching suffix is a border of a suffix of the pattern</span>\n\n            <span class=\"hljs-comment\">// f[i] contains starting position of the widest border of the suffix of the pattern beginning at position i</span>\n            <span class=\"hljs-built_in\">int</span>[] f = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[p.Length + <span class=\"hljs-number\">1</span>];\n\n            <span class=\"hljs-comment\">// Suffix of p[m] has no border --&gt; f[m] = m+1</span>\n            f[m] = m + <span class=\"hljs-number\">1</span>;\n\n            <span class=\"hljs-comment\">// Corresponding shift distance</span>\n            <span class=\"hljs-built_in\">int</span>[] s = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[p.Length + <span class=\"hljs-number\">1</span>];\n\n            <span class=\"hljs-comment\">// Start of suffix including border of the pattern</span>\n            <span class=\"hljs-comment\">// (hint: https://www.inf.hs-flensburg.de/lang/algorithmen/pattern/kmpen.htm#section2)</span>\n            <span class=\"hljs-keyword\">var</span> i = m;\n\n            <span class=\"hljs-comment\">// Start of suffix of the pattern</span>\n            <span class=\"hljs-keyword\">var</span> j = m + <span class=\"hljs-number\">1</span>;\n\n            <span class=\"hljs-keyword\">while</span> (i &gt; <span class=\"hljs-number\">0</span>)\n            {\n                <span class=\"hljs-comment\">// checking if a shorter border that is already known can be extended to the left by the same symbol</span>\n                <span class=\"hljs-keyword\">while</span> (j &lt;= m &amp;&amp; p[i - <span class=\"hljs-number\">1</span>] != p[j - <span class=\"hljs-number\">1</span>])\n                {\n                    <span class=\"hljs-keyword\">if</span> (s[j] == <span class=\"hljs-number\">0</span>)\n                    {\n                        s[j] = j - i;\n                    }\n\n                    j = f[j];\n                }\n\n                --i;\n                --j;\n                f[i] = j;\n            }\n\n            <span class=\"hljs-comment\">// CASE 2</span>\n            <span class=\"hljs-comment\">// Only a part of the matching suffix occurs at the beginning of the pattern</span>\n            <span class=\"hljs-comment\">// (filling remaining entries)</span>\n            j = f[<span class=\"hljs-number\">0</span>];\n            <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt;= m; i++)\n            {\n                <span class=\"hljs-comment\">// Starting postition of the greates border</span>\n                <span class=\"hljs-keyword\">if</span> (s[i] == <span class=\"hljs-number\">0</span>)\n                {\n                    s[i] = j;\n                }\n\n                <span class=\"hljs-comment\">// From position i = j, it switches to the next narrower border f[j]</span>\n                <span class=\"hljs-keyword\">if</span> (i == j)\n                {\n                    j = f[j];\n                }\n            }\n\n            <span class=\"hljs-keyword\">return</span> s;\n        }\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Antony",
      "email": "45163503+DuckNrOne@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Metta Ong",
      "email": "ongspxm@gmail.com",
      "commits": 1
    },
    {
      "name": "Ayoade David",
      "email": "adewoleayoade057@gmail.com",
      "commits": 1
    },
    {
      "name": "Aitor Fidalgo Sánchez",
      "email": "64830228+aitorfi@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Shraddha",
      "email": "42699578+shraddhavp@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Andrii Siriak",
      "email": "siryaka@gmail.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}