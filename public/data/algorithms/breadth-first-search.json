{
  "slug": "breadth-first-search",
  "name": "Breadth First Search",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "graphs/breadth_first_search.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/graphs/breadth_first_search.py",
      "code": "<span class=\"hljs-comment\">#!/usr/bin/python</span>\n\n<span class=\"hljs-string\">&quot;&quot;&quot; Author: OMKAR PATHAK &quot;&quot;&quot;</span>\n<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\n\n<span class=\"hljs-keyword\">from</span> queue <span class=\"hljs-keyword\">import</span> Queue\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        self.vertices: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]] = {}\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">print_graph</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        prints adjacency list representation of graaph\n        &gt;&gt;&gt; g = Graph()\n        &gt;&gt;&gt; g.print_graph()\n        &gt;&gt;&gt; g.add_edge(0, 1)\n        &gt;&gt;&gt; g.print_graph()\n        0  :  1\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> self.vertices:\n            <span class=\"hljs-built_in\">print</span>(i, <span class=\"hljs-string\">&quot; : &quot;</span>, <span class=\"hljs-string\">&quot; -&gt; &quot;</span>.join([<span class=\"hljs-built_in\">str</span>(j) <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> self.vertices[i]]))\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">add_edge</span>(<span class=\"hljs-params\">self, from_vertex: <span class=\"hljs-built_in\">int</span>, to_vertex: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        adding the edge between two vertices\n        &gt;&gt;&gt; g = Graph()\n        &gt;&gt;&gt; g.print_graph()\n        &gt;&gt;&gt; g.add_edge(0, 1)\n        &gt;&gt;&gt; g.print_graph()\n        0  :  1\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">if</span> from_vertex <span class=\"hljs-keyword\">in</span> self.vertices:\n            self.vertices[from_vertex].append(to_vertex)\n        <span class=\"hljs-keyword\">else</span>:\n            self.vertices[from_vertex] = [to_vertex]\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">bfs</span>(<span class=\"hljs-params\">self, start_vertex: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">set</span>[<span class=\"hljs-built_in\">int</span>]:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        &gt;&gt;&gt; g = Graph()\n        &gt;&gt;&gt; g.add_edge(0, 1)\n        &gt;&gt;&gt; g.add_edge(0, 1)\n        &gt;&gt;&gt; g.add_edge(0, 2)\n        &gt;&gt;&gt; g.add_edge(1, 2)\n        &gt;&gt;&gt; g.add_edge(2, 0)\n        &gt;&gt;&gt; g.add_edge(2, 3)\n        &gt;&gt;&gt; g.add_edge(3, 3)\n        &gt;&gt;&gt; sorted(g.bfs(2))\n        [0, 1, 2, 3]\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-comment\"># initialize set for storing already visited vertices</span>\n        visited = <span class=\"hljs-built_in\">set</span>()\n\n        <span class=\"hljs-comment\"># create a first in first out queue to store all the vertices for BFS</span>\n        queue: Queue = Queue()\n\n        <span class=\"hljs-comment\"># mark the source node as visited and enqueue it</span>\n        visited.add(start_vertex)\n        queue.put(start_vertex)\n\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">not</span> queue.empty():\n            vertex = queue.get()\n\n            <span class=\"hljs-comment\"># loop through all adjacent vertex and enqueue it if not yet visited</span>\n            <span class=\"hljs-keyword\">for</span> adjacent_vertex <span class=\"hljs-keyword\">in</span> self.vertices[vertex]:\n                <span class=\"hljs-keyword\">if</span> adjacent_vertex <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> visited:\n                    queue.put(adjacent_vertex)\n                    visited.add(adjacent_vertex)\n        <span class=\"hljs-keyword\">return</span> visited\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">from</span> doctest <span class=\"hljs-keyword\">import</span> testmod\n\n    testmod(verbose=<span class=\"hljs-literal\">True</span>)\n\n    g = Graph()\n    g.add_edge(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>)\n    g.add_edge(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>)\n    g.add_edge(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>)\n    g.add_edge(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>)\n    g.add_edge(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>)\n    g.add_edge(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>)\n\n    g.print_graph()\n    <span class=\"hljs-comment\"># 0  :  1 -&gt; 2</span>\n    <span class=\"hljs-comment\"># 1  :  2</span>\n    <span class=\"hljs-comment\"># 2  :  0 -&gt; 3</span>\n    <span class=\"hljs-comment\"># 3  :  3</span>\n\n    <span class=\"hljs-keyword\">assert</span> <span class=\"hljs-built_in\">sorted</span>(g.bfs(<span class=\"hljs-number\">2</span>)) == [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>]\n"
    },
    "javascript": {
      "dir": "Graphs/BreadthFirstSearch.js",
      "url": "https://github.com/TheAlgorithms/javascript/tree/master/Graphs/BreadthFirstSearch.js",
      "code": "<span class=\"hljs-comment\">/**\r\n * Breadth-first search is an algorithm for traversing a graph.\r\n *\r\n * It discovers all nodes reachable from the starting position by exploring all of the neighbor nodes at the present\r\n * depth prior to moving on to the nodes at the next depth level.\r\n *\r\n * (description adapted from https://en.wikipedia.org/wiki/Breadth-first_search)\r\n * <span class=\"hljs-doctag\">@see</span> https://www.koderdojo.com/blog/breadth-first-search-and-shortest-path-in-csharp-and-net-core\r\n */</span>\r\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">breadthFirstSearch</span> (graph, startingNode) {\r\n  <span class=\"hljs-comment\">// visited keeps track of all nodes visited</span>\r\n  <span class=\"hljs-keyword\">const</span> visited = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Set</span>()\r\n\r\n  <span class=\"hljs-comment\">// queue contains the nodes to be explored in the future</span>\r\n  <span class=\"hljs-keyword\">const</span> queue = [startingNode]\r\n\r\n  <span class=\"hljs-keyword\">while</span> (queue.<span class=\"hljs-property\">length</span> &gt; <span class=\"hljs-number\">0</span>) {\r\n    <span class=\"hljs-comment\">// start with the queue&#x27;s first node</span>\r\n    <span class=\"hljs-keyword\">const</span> node = queue.<span class=\"hljs-title function_\">shift</span>()\r\n\r\n    <span class=\"hljs-keyword\">if</span> (!visited.<span class=\"hljs-title function_\">has</span>(node)) {\r\n      <span class=\"hljs-comment\">// mark the node as visited</span>\r\n      visited.<span class=\"hljs-title function_\">add</span>(node)\r\n      <span class=\"hljs-keyword\">const</span> neighbors = graph[node]\r\n\r\n      <span class=\"hljs-comment\">// put all its neighbors into the queue</span>\r\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; neighbors.<span class=\"hljs-property\">length</span>; i++) {\r\n        queue.<span class=\"hljs-title function_\">push</span>(neighbors[i])\r\n      }\r\n    }\r\n  }\r\n\r\n  <span class=\"hljs-keyword\">return</span> visited\r\n}\r\n"
    },
    "c-plus-plus": {
      "dir": "graph/breadth_first_search.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph/breadth_first_search.cpp",
      "code": "<span class=\"hljs-comment\">/**\n *\n * \\file\n * \\brief [Breadth First Search Algorithm\n * (Breadth First Search)](https://en.wikipedia.org/wiki/Breadth-first_search)\n *\n * \\author [Ayaan Khan](https://github.com/ayaankhan98)\n * \\author [Aman Kumar Pandey](https://github.com/gpamangkp)\n *\n *\n * \\details\n * Breadth First Search also quoted as BFS is a Graph Traversal Algorithm.\n * Time Complexity O(|V| + |E|) where V are the number of vertices and E\n * are the number of edges in the graph.\n *\n * Applications of Breadth First Search are\n *\n * 1. Finding shortest path between two vertices say u and v, with path\n *    length measured by number of edges (an advantage over depth first\n *    search algorithm)\n * 2. Ford-Fulkerson Method for computing the maximum flow in a flow network.\n * 3. Testing bipartiteness of a graph.\n * 4. Cheney&#x27;s Algorithm, Copying garbage collection.\n *\n * And there are many more...\n *\n * &lt;h4&gt;working&lt;/h4&gt;\n * In the implementation below we first created a graph using the adjacency\n * list representation of graph.\n * Breadth First Search Works as follows\n * it requires a vertex as a start vertex, Start vertex is that vertex\n * from where you want to start traversing the graph.\n * We maintain a bool array or a vector to keep track of the vertices\n * which we have visited so that we do not traverse the visited vertices\n * again and again and eventually fall into an infinite loop. Along with this\n * boolen array we use a Queue.\n *\n * 1. First we mark the start vertex as visited.\n * 2. Push this visited vertex in the Queue.\n * 3. while the queue is not empty we repeat the following steps\n *\n *      1. Take out an element from the front of queue\n *      2. Explore the adjacency list of this vertex\n *         if element in the adjacency list is not visited then we\n *         push that element into the queue and mark this as visited\n *\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-comment\">/**\n * \\namespace graph\n * \\brief Graph algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> graph {\n<span class=\"hljs-comment\">/* Class Graph definition */</span>\n<span class=\"hljs-keyword\">template</span> &lt;<span class=\"hljs-keyword\">typename</span> T&gt;\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span> {\n    <span class=\"hljs-comment\">/**\n     *  adjacency_list maps every vertex to the list of its neighbours in the\n     * order in which they are added.\n     */</span>\n    std::map&lt;T, std::list&lt;T&gt; &gt; adjacency_list;\n\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-built_in\">Graph</span>() = <span class=\"hljs-keyword\">default</span>;\n    ;\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">add_edge</span><span class=\"hljs-params\">(T u, T v, <span class=\"hljs-type\">bool</span> bidir = <span class=\"hljs-literal\">true</span>)</span> </span>{\n        <span class=\"hljs-comment\">/**\n         *  add_edge(u,v,bidir) is used to add an edge between node u and\n         * node v by default , bidir is made true , i.e graph is\n         * bidirectional . It means if edge(u,v) is added then u--&gt;v  and\n         * v--&gt;u both edges exist.\n         *\n         *  to make the graph unidirectional pass the third parameter of\n         * add_edge as false which will\n         */</span>\n        adjacency_list[u].<span class=\"hljs-built_in\">push_back</span>(v);  <span class=\"hljs-comment\">// u--&gt;v edge added</span>\n        <span class=\"hljs-keyword\">if</span> (bidir == <span class=\"hljs-literal\">true</span>) {\n            <span class=\"hljs-comment\">// if graph is bidirectional</span>\n            adjacency_list[v].<span class=\"hljs-built_in\">push_back</span>(u);  <span class=\"hljs-comment\">// v--&gt;u edge added</span>\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     *  this function performs the breadth first search on graph and return a\n     *  mapping which maps the nodes to a boolean value representing whether the\n     *  node was traversed or not.\n     */</span>\n    <span class=\"hljs-function\">std::map&lt;T, <span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-title\">breadth_first_search</span><span class=\"hljs-params\">(T src)</span> </span>{\n        <span class=\"hljs-comment\">/// mapping to keep track of all visited nodes</span>\n        std::map&lt;T, <span class=\"hljs-type\">bool</span>&gt; visited;\n        <span class=\"hljs-comment\">/// initialise every possible vertex to map to false</span>\n        <span class=\"hljs-comment\">/// initially none of the vertices are unvisited</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> <span class=\"hljs-type\">const</span> &amp;adjlist : adjacency_list) {\n            visited[adjlist.first] = <span class=\"hljs-literal\">false</span>;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> <span class=\"hljs-type\">const</span> &amp;node : adjacency_list[adjlist.first]) {\n                visited[node] = <span class=\"hljs-literal\">false</span>;\n            }\n        }\n\n        <span class=\"hljs-comment\">/// queue to store the nodes which are yet to be traversed</span>\n        std::queue&lt;T&gt; tracker;\n\n        <span class=\"hljs-comment\">/// push the source vertex to queue to begin traversing</span>\n        tracker.<span class=\"hljs-built_in\">push</span>(src);\n        <span class=\"hljs-comment\">/// mark the source vertex as visited</span>\n        visited[src] = <span class=\"hljs-literal\">true</span>;\n        <span class=\"hljs-keyword\">while</span> (!tracker.<span class=\"hljs-built_in\">empty</span>()) {\n            <span class=\"hljs-comment\">/// traverse the graph till no connected vertex are left</span>\n            <span class=\"hljs-comment\">/// extract a node from queue for further traversal</span>\n            T node = tracker.<span class=\"hljs-built_in\">front</span>();\n            <span class=\"hljs-comment\">/// remove the node from the queue</span>\n            tracker.<span class=\"hljs-built_in\">pop</span>();\n            <span class=\"hljs-keyword\">for</span> (T <span class=\"hljs-type\">const</span> &amp;neighbour : adjacency_list[node]) {\n                <span class=\"hljs-comment\">/// check every vertex connected to the node which are still</span>\n                <span class=\"hljs-comment\">/// unvisited</span>\n                <span class=\"hljs-keyword\">if</span> (!visited[neighbour]) {\n                    <span class=\"hljs-comment\">/// if the neighbour is unvisited , push it into the queue</span>\n                    tracker.<span class=\"hljs-built_in\">push</span>(neighbour);\n                    <span class=\"hljs-comment\">/// mark the neighbour as visited</span>\n                    visited[neighbour] = <span class=\"hljs-literal\">true</span>;\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> visited;\n    }\n};\n<span class=\"hljs-comment\">/* Class definition ends */</span>\n}  <span class=\"hljs-comment\">// namespace graph</span>\n\n<span class=\"hljs-comment\">/** Test function */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">tests</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">/// Test 1 Begin</span>\n    graph::Graph&lt;<span class=\"hljs-type\">int</span>&gt; g;\n    std::map&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">bool</span>&gt; correct_result;\n    g.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>);\n    g.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n    g.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>);\n    correct_result[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-literal\">true</span>;\n    correct_result[<span class=\"hljs-number\">1</span>] = <span class=\"hljs-literal\">true</span>;\n    correct_result[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-literal\">true</span>;\n    correct_result[<span class=\"hljs-number\">3</span>] = <span class=\"hljs-literal\">true</span>;\n\n    std::map&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">bool</span>&gt; returned_result = g.<span class=\"hljs-built_in\">breadth_first_search</span>(<span class=\"hljs-number\">2</span>);\n\n    <span class=\"hljs-built_in\">assert</span>(returned_result == correct_result);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1 Passed...&quot;</span> &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">/// Test 2 Begin</span>\n    returned_result = g.<span class=\"hljs-built_in\">breadth_first_search</span>(<span class=\"hljs-number\">0</span>);\n\n    <span class=\"hljs-built_in\">assert</span>(returned_result == correct_result);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2 Passed...&quot;</span> &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">/// Test 3 Begins</span>\n    graph::Graph&lt;std::string&gt; g2;\n\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Gorakhpur&quot;</span>, <span class=\"hljs-string\">&quot;Lucknow&quot;</span>, <span class=\"hljs-literal\">false</span>);\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Gorakhpur&quot;</span>, <span class=\"hljs-string\">&quot;Kanpur&quot;</span>, <span class=\"hljs-literal\">false</span>);\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Lucknow&quot;</span>, <span class=\"hljs-string\">&quot;Agra&quot;</span>, <span class=\"hljs-literal\">false</span>);\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Kanpur&quot;</span>, <span class=\"hljs-string\">&quot;Agra&quot;</span>, <span class=\"hljs-literal\">false</span>);\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Lucknow&quot;</span>, <span class=\"hljs-string\">&quot;Prayagraj&quot;</span>, <span class=\"hljs-literal\">false</span>);\n    g2.<span class=\"hljs-built_in\">add_edge</span>(<span class=\"hljs-string\">&quot;Agra&quot;</span>, <span class=\"hljs-string\">&quot;Noida&quot;</span>, <span class=\"hljs-literal\">false</span>);\n\n    std::map&lt;std::string, <span class=\"hljs-type\">bool</span>&gt; correct_res;\n    std::map&lt;std::string, <span class=\"hljs-type\">bool</span>&gt; returned_res =\n        g2.<span class=\"hljs-built_in\">breadth_first_search</span>(<span class=\"hljs-string\">&quot;Kanpur&quot;</span>);\n    correct_res[<span class=\"hljs-string\">&quot;Gorakhpur&quot;</span>] = <span class=\"hljs-literal\">false</span>;\n    correct_res[<span class=\"hljs-string\">&quot;Lucknow&quot;</span>] = <span class=\"hljs-literal\">false</span>;\n    correct_res[<span class=\"hljs-string\">&quot;Kanpur&quot;</span>] = <span class=\"hljs-literal\">true</span>;\n    correct_res[<span class=\"hljs-string\">&quot;Agra&quot;</span>] = <span class=\"hljs-literal\">true</span>;\n    correct_res[<span class=\"hljs-string\">&quot;Prayagraj&quot;</span>] = <span class=\"hljs-literal\">false</span>;\n    correct_res[<span class=\"hljs-string\">&quot;Noida&quot;</span>] = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-built_in\">assert</span>(correct_res == returned_res);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 3 Passed...&quot;</span> &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/** Main function */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">tests</span>();\n    <span class=\"hljs-type\">size_t</span> edges = <span class=\"hljs-number\">0</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the number of edges: &quot;</span>;\n    std::cin &gt;&gt; edges;\n\n    graph::Graph&lt;<span class=\"hljs-type\">int</span>&gt; g;\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter space-separated pairs of vertices that form edges: &quot;</span>\n              &lt;&lt; std::endl;\n    <span class=\"hljs-keyword\">while</span> (edges--) {\n        <span class=\"hljs-type\">int</span> u = <span class=\"hljs-number\">0</span>, v = <span class=\"hljs-number\">0</span>;\n        std::cin &gt;&gt; u &gt;&gt; v;\n        g.<span class=\"hljs-built_in\">add_edge</span>(u, v);\n    }\n\n    g.<span class=\"hljs-built_in\">breadth_first_search</span>(<span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "java": {
      "dir": "src/main/java/com/thealgorithms/searches/BreadthFirstSearch.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src/main/java/com/thealgorithms/searches/BreadthFirstSearch.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.searches;\n\n<span class=\"hljs-keyword\">import</span> com.thealgorithms.searches.DepthFirstSearch.Node;\n\n<span class=\"hljs-keyword\">import</span> java.util.ArrayList;\n<span class=\"hljs-keyword\">import</span> java.util.List;\n<span class=\"hljs-keyword\">import</span> java.util.Objects;\n<span class=\"hljs-keyword\">import</span> java.util.Optional;\n\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@author</span>: caos321\n * <span class=\"hljs-doctag\">@date</span>: 31 October 2021 (Sunday)\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BreadthFirstSearch</span> {\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Optional&lt;Node&gt; <span class=\"hljs-title function_\">search</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> Node node, <span class=\"hljs-keyword\">final</span> String name)</span> {\n        <span class=\"hljs-keyword\">if</span> (node.getName().equals(name)) {\n            <span class=\"hljs-keyword\">return</span> Optional.of(node);\n        }\n\n        List&lt;Node&gt; queue = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;(node.getSubNodes());\n\n        <span class=\"hljs-keyword\">while</span> (!queue.isEmpty()) {\n            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">current</span> <span class=\"hljs-operator\">=</span> queue.get(<span class=\"hljs-number\">0</span>);\n\n            <span class=\"hljs-keyword\">if</span> (current.getName().equals(name)) {\n                <span class=\"hljs-keyword\">return</span> Optional.of(current);\n            }\n\n            queue.addAll(current.getSubNodes());\n\n            queue.remove(<span class=\"hljs-number\">0</span>);\n        }\n\n        <span class=\"hljs-keyword\">return</span> Optional.empty();\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">assertThat</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> Object actual, <span class=\"hljs-keyword\">final</span> Object expected)</span> {\n        <span class=\"hljs-keyword\">if</span> (!Objects.equals(actual, expected)) {\n            <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AssertionError</span>(String.format(<span class=\"hljs-string\">&quot;expected=%s but was actual=%s&quot;</span>, expected, actual));\n        }\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> String[] args)</span> {\n        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">rootNode</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;A&quot;</span>, List.of(\n                <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;B&quot;</span>, List.of(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;D&quot;</span>), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;F&quot;</span>, List.of(\n                        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;H&quot;</span>), <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;I&quot;</span>)\n                )))),\n                <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;C&quot;</span>, List.of(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;G&quot;</span>))),\n                <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-string\">&quot;E&quot;</span>)\n        ));\n\n        {\n            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">expected</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;I&quot;</span>;\n\n            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> search(rootNode, expected)\n                    .orElseThrow(() -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AssertionError</span>(<span class=\"hljs-string\">&quot;Node not found!&quot;</span>));\n\n            assertThat(result.getName(), expected);\n        }\n\n        {\n            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">expected</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;G&quot;</span>;\n\n            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> search(rootNode, expected)\n                    .orElseThrow(() -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AssertionError</span>(<span class=\"hljs-string\">&quot;Node not found!&quot;</span>));\n\n            assertThat(result.getName(), expected);\n        }\n\n        {\n            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">expected</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;E&quot;</span>;\n\n            <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> search(rootNode, expected)\n                    .orElseThrow(() -&gt; <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">AssertionError</span>(<span class=\"hljs-string\">&quot;Node not found!&quot;</span>));\n\n            assertThat(result.getName(), expected);\n        }\n    }\n}\n"
    },
    "go": {
      "dir": "graph/breadthfirstsearch.go",
      "url": "https://github.com/TheAlgorithms/go/tree/master/graph/breadthfirstsearch.go",
      "code": "<span class=\"hljs-keyword\">package</span> graph\n\n<span class=\"hljs-comment\">// BreadthFirstSearch is an algorithm for traversing and searching graph data structures.</span>\n<span class=\"hljs-comment\">// It starts at an arbitrary node of a graph, and explores all of the neighbor nodes</span>\n<span class=\"hljs-comment\">// at the present depth prior to moving on to the nodes at the next depth level.</span>\n<span class=\"hljs-comment\">// Worst-case performance\t \t\tO(|V|+|E|)=O(b^{d})}O(|V|+|E|)=O(b^{d})</span>\n<span class=\"hljs-comment\">// Worst-case space complexity\t \tO(|V|)=O(b^{d})}O(|V|)=O(b^{d})</span>\n<span class=\"hljs-comment\">// reference: https://en.wikipedia.org/wiki/Breadth-first_search</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">BreadthFirstSearch</span><span class=\"hljs-params\">(start, end, nodes <span class=\"hljs-type\">int</span>, edges [][]<span class=\"hljs-type\">int</span>)</span></span> (isConnected <span class=\"hljs-type\">bool</span>, distance <span class=\"hljs-type\">int</span>) {\n\tqueue := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">0</span>)\n\tdiscovered := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, nodes)\n\tdiscovered[start] = <span class=\"hljs-number\">1</span>\n\tqueue = <span class=\"hljs-built_in\">append</span>(queue, start)\n\t<span class=\"hljs-keyword\">for</span> <span class=\"hljs-built_in\">len</span>(queue) &gt; <span class=\"hljs-number\">0</span> {\n\t\tv := queue[<span class=\"hljs-number\">0</span>]\n\t\tqueue = queue[<span class=\"hljs-number\">1</span>:]\n\t\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-built_in\">len</span>(edges[v]); i++ {\n\t\t\t<span class=\"hljs-keyword\">if</span> discovered[i] == <span class=\"hljs-number\">0</span> &amp;&amp; edges[v][i] &gt; <span class=\"hljs-number\">0</span> {\n\t\t\t\t<span class=\"hljs-keyword\">if</span> i == end {\n\t\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>, discovered[v]\n\t\t\t\t}\n\t\t\t\tdiscovered[i] = discovered[v] + <span class=\"hljs-number\">1</span>\n\t\t\t\tqueue = <span class=\"hljs-built_in\">append</span>(queue, i)\n\t\t\t}\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>, <span class=\"hljs-number\">0</span>\n}\n"
    },
    "rust": {
      "dir": "src/graph/breadth_first_search.rs",
      "url": "https://github.com/TheAlgorithms/rust/tree/master/src/graph/breadth_first_search.rs",
      "code": "<span class=\"hljs-keyword\">use</span> std::collections::HashSet;\n<span class=\"hljs-keyword\">use</span> std::collections::VecDeque;\n\n<span class=\"hljs-comment\">/// Perform a breadth-first search on Graph `graph`.</span>\n<span class=\"hljs-comment\">///</span>\n<span class=\"hljs-comment\">/// # Parameters</span>\n<span class=\"hljs-comment\">///</span>\n<span class=\"hljs-comment\">/// - `graph`: The graph to search.</span>\n<span class=\"hljs-comment\">/// - `root`: The starting node of the graph from which to begin searching.</span>\n<span class=\"hljs-comment\">/// - `target`: The target node for the search.</span>\n<span class=\"hljs-comment\">///</span>\n<span class=\"hljs-comment\">/// # Returns</span>\n<span class=\"hljs-comment\">///</span>\n<span class=\"hljs-comment\">/// If the target is found, an Optional vector is returned with the history</span>\n<span class=\"hljs-comment\">/// of nodes visited as its contents.</span>\n<span class=\"hljs-comment\">///</span>\n<span class=\"hljs-comment\">/// If the target is not found or there is no path from the root,</span>\n<span class=\"hljs-comment\">/// `None` is returned.</span>\n<span class=\"hljs-comment\">///</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">breadth_first_search</span>(graph: &amp;Graph, root: Node, target: Node) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Option</span>&lt;<span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">u32</span>&gt;&gt; {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">visited</span>: HashSet&lt;Node&gt; = HashSet::<span class=\"hljs-title function_ invoke__\">new</span>();\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">history</span>: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">u32</span>&gt; = Vec::<span class=\"hljs-title function_ invoke__\">new</span>();\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">queue</span> = VecDeque::<span class=\"hljs-title function_ invoke__\">new</span>();\n\n    visited.<span class=\"hljs-title function_ invoke__\">insert</span>(root);\n    queue.<span class=\"hljs-title function_ invoke__\">push_back</span>(root);\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">Some</span>(currentnode) = queue.<span class=\"hljs-title function_ invoke__\">pop_front</span>() {\n        history.<span class=\"hljs-title function_ invoke__\">push</span>(currentnode.<span class=\"hljs-title function_ invoke__\">value</span>());\n\n        <span class=\"hljs-comment\">// If we reach the goal, return our travel history.</span>\n        <span class=\"hljs-keyword\">if</span> currentnode == target {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-title function_ invoke__\">Some</span>(history);\n        }\n\n        <span class=\"hljs-comment\">// Check the neighboring nodes for any that we&#x27;ve not visited yet.</span>\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">neighbor</span> <span class=\"hljs-keyword\">in</span> currentnode.<span class=\"hljs-title function_ invoke__\">neighbors</span>(graph) {\n            <span class=\"hljs-keyword\">if</span> !visited.<span class=\"hljs-title function_ invoke__\">contains</span>(&amp;neighbor) {\n                visited.<span class=\"hljs-title function_ invoke__\">insert</span>(neighbor);\n                queue.<span class=\"hljs-title function_ invoke__\">push_back</span>(neighbor);\n            }\n        }\n    }\n\n    <span class=\"hljs-comment\">// All nodes were visited, yet the target was not found.</span>\n    <span class=\"hljs-literal\">None</span>\n}\n\n<span class=\"hljs-comment\">// Data Structures</span>\n\n<span class=\"hljs-meta\">#[derive(Copy, Clone, PartialEq, Eq, Hash)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-type\">u32</span>);\n\n<span class=\"hljs-meta\">#[derive(Copy, Clone, PartialEq, Eq, Hash)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Edge</span>(<span class=\"hljs-type\">u32</span>, <span class=\"hljs-type\">u32</span>);\n\n<span class=\"hljs-meta\">#[derive(Clone)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Graph</span> {\n    <span class=\"hljs-meta\">#[allow(dead_code)]</span>\n    nodes: <span class=\"hljs-type\">Vec</span>&lt;Node&gt;,\n    edges: <span class=\"hljs-type\">Vec</span>&lt;Edge&gt;,\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Graph</span> {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">new</span>(nodes: <span class=\"hljs-type\">Vec</span>&lt;Node&gt;, edges: <span class=\"hljs-type\">Vec</span>&lt;Edge&gt;) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\n        Graph { nodes, edges }\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">From</span>&lt;<span class=\"hljs-type\">u32</span>&gt; <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Node</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">from</span>(item: <span class=\"hljs-type\">u32</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-title function_ invoke__\">Node</span>(item)\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Node</span> {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">value</span>(&amp;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">u32</span> {\n        <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">neighbors</span>(&amp;<span class=\"hljs-keyword\">self</span>, graph: &amp;Graph) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Vec</span>&lt;Node&gt; {\n        graph\n            .edges\n            .<span class=\"hljs-title function_ invoke__\">iter</span>()\n            .<span class=\"hljs-title function_ invoke__\">filter</span>(|e| e.<span class=\"hljs-number\">0</span> == <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-number\">0</span>)\n            .<span class=\"hljs-title function_ invoke__\">map</span>(|e| e.<span class=\"hljs-number\">1</span>.<span class=\"hljs-title function_ invoke__\">into</span>())\n            .<span class=\"hljs-title function_ invoke__\">collect</span>()\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">From</span>&lt;(<span class=\"hljs-type\">u32</span>, <span class=\"hljs-type\">u32</span>)&gt; <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Edge</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">from</span>(item: (<span class=\"hljs-type\">u32</span>, <span class=\"hljs-type\">u32</span>)) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-title function_ invoke__\">Edge</span>(item.<span class=\"hljs-number\">0</span>, item.<span class=\"hljs-number\">1</span>)\n    }\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::*;\n\n    <span class=\"hljs-comment\">/* Example graph #1:\n     *\n     *            (1)   &lt;--- Root\n     *           /   \\\n     *         (2)   (3)\n     *        / |     | \\\n     *     (4) (5)   (6) (7)\n     *          |\n     *         (8)\n     */</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">graph1</span>() <span class=\"hljs-punctuation\">-&gt;</span> Graph {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">nodes</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>];\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">edges</span> = <span class=\"hljs-built_in\">vec!</span>[(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>), (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>), (<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>), (<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>), (<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>), (<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>), (<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>)];\n\n        Graph::<span class=\"hljs-title function_ invoke__\">new</span>(\n            nodes.<span class=\"hljs-title function_ invoke__\">into_iter</span>().<span class=\"hljs-title function_ invoke__\">map</span>(|v| v.<span class=\"hljs-title function_ invoke__\">into</span>()).<span class=\"hljs-title function_ invoke__\">collect</span>(),\n            edges.<span class=\"hljs-title function_ invoke__\">into_iter</span>().<span class=\"hljs-title function_ invoke__\">map</span>(|e| e.<span class=\"hljs-title function_ invoke__\">into</span>()).<span class=\"hljs-title function_ invoke__\">collect</span>(),\n        )\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">breadth_first_search_graph1_when_node_not_found_returns_none</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">graph</span> = <span class=\"hljs-title function_ invoke__\">graph1</span>();\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">root</span> = <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">target</span> = <span class=\"hljs-number\">10</span>;\n\n        <span class=\"hljs-built_in\">assert_eq!</span>(\n            <span class=\"hljs-title function_ invoke__\">breadth_first_search</span>(&amp;graph, root.<span class=\"hljs-title function_ invoke__\">into</span>(), target.<span class=\"hljs-title function_ invoke__\">into</span>()),\n            <span class=\"hljs-literal\">None</span>\n        );\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">breadth_first_search_graph1_when_target_8_should_evaluate_all_nodes_first</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">graph</span> = <span class=\"hljs-title function_ invoke__\">graph1</span>();\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">root</span> = <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">target</span> = <span class=\"hljs-number\">8</span>;\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">expected_path</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>];\n\n        <span class=\"hljs-built_in\">assert_eq!</span>(\n            <span class=\"hljs-title function_ invoke__\">breadth_first_search</span>(&amp;graph, root.<span class=\"hljs-title function_ invoke__\">into</span>(), target.<span class=\"hljs-title function_ invoke__\">into</span>()),\n            <span class=\"hljs-title function_ invoke__\">Some</span>(expected_path)\n        );\n    }\n\n    <span class=\"hljs-comment\">/* Example graph #2:\n     *\n     *     (1) --- (2)     (3) --- (4)\n     *            / |     /       /\n     *          /   |   /       /\n     *        /     | /       /\n     *     (5)     (6) --- (7)     (8)\n     */</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">graph2</span>() <span class=\"hljs-punctuation\">-&gt;</span> Graph {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">nodes</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>];\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">undirected_edges</span> = <span class=\"hljs-built_in\">vec!</span>[\n            (<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>),\n            (<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>),\n            (<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>),\n            (<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>),\n            (<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">6</span>),\n            (<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>),\n            (<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>),\n            (<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>),\n            (<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>),\n            (<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">3</span>),\n            (<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">7</span>),\n            (<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">4</span>),\n            (<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>),\n            (<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">6</span>),\n        ];\n\n        Graph::<span class=\"hljs-title function_ invoke__\">new</span>(\n            nodes.<span class=\"hljs-title function_ invoke__\">into_iter</span>().<span class=\"hljs-title function_ invoke__\">map</span>(|v| v.<span class=\"hljs-title function_ invoke__\">into</span>()).<span class=\"hljs-title function_ invoke__\">collect</span>(),\n            undirected_edges.<span class=\"hljs-title function_ invoke__\">into_iter</span>().<span class=\"hljs-title function_ invoke__\">map</span>(|e| e.<span class=\"hljs-title function_ invoke__\">into</span>()).<span class=\"hljs-title function_ invoke__\">collect</span>(),\n        )\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">breadth_first_search_graph2_when_no_path_to_node_returns_none</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">graph</span> = <span class=\"hljs-title function_ invoke__\">graph2</span>();\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">root</span> = <span class=\"hljs-number\">8</span>;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">target</span> = <span class=\"hljs-number\">4</span>;\n\n        <span class=\"hljs-built_in\">assert_eq!</span>(\n            <span class=\"hljs-title function_ invoke__\">breadth_first_search</span>(&amp;graph, root.<span class=\"hljs-title function_ invoke__\">into</span>(), target.<span class=\"hljs-title function_ invoke__\">into</span>()),\n            <span class=\"hljs-literal\">None</span>\n        );\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">breadth_first_search_graph2_should_find_path_from_4_to_1</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">graph</span> = <span class=\"hljs-title function_ invoke__\">graph2</span>();\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">root</span> = <span class=\"hljs-number\">4</span>;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">target</span> = <span class=\"hljs-number\">1</span>;\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">expected_path</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>];\n\n        <span class=\"hljs-built_in\">assert_eq!</span>(\n            <span class=\"hljs-title function_ invoke__\">breadth_first_search</span>(&amp;graph, root.<span class=\"hljs-title function_ invoke__\">into</span>(), target.<span class=\"hljs-title function_ invoke__\">into</span>()),\n            <span class=\"hljs-title function_ invoke__\">Some</span>(expected_path)\n        );\n    }\n}\n"
    },
    "dart": {
      "dir": "graphs/breadth_first_search.dart",
      "url": "https://github.com/TheAlgorithms/dart/tree/master/graphs/breadth_first_search.dart",
      "code": "<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;dart:collection&#x27;</span>;\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&#x27;package:test/test.dart&#x27;</span>;\n\n<span class=\"hljs-comment\">/// <span class=\"language-markdown\">Implementation of Breadth First Search</span></span>\n<span class=\"hljs-comment\">/// <span class=\"language-markdown\">https://en.wikipedia.org/wiki/Breadth-first<span class=\"hljs-emphasis\">_search</span></span></span>\n\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Graph</span> </span>{\n  <span class=\"hljs-comment\">/// <span class=\"language-markdown\"><span class=\"hljs-emphasis\">Adjacency List representation using dynamic list and HashMap</span></span></span>\n  HashMap graph = <span class=\"hljs-keyword\">new</span> HashMap&lt;<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">dynamic</span>&gt;&gt;();\n  <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; nodes;\n\n  <span class=\"hljs-keyword\">void</span> makeGraph() {\n    <span class=\"hljs-comment\">/// <span class=\"language-markdown\"><span class=\"hljs-emphasis\">initialise all nodes with empty lists.</span></span></span>\n    <span class=\"hljs-comment\">/// <span class=\"language-markdown\"><span class=\"hljs-emphasis\">each node will have a list as value which stores</span></span></span>\n    <span class=\"hljs-comment\">/// <span class=\"language-markdown\"><span class=\"hljs-emphasis\">the nodes to which it is connected to</span></span></span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-keyword\">this</span>.nodes.length; i++) {\n      <span class=\"hljs-keyword\">this</span>.graph[nodes[i]] = <span class=\"hljs-built_in\">List</span>();\n    }\n  }\n\n  Graph(<span class=\"hljs-keyword\">this</span>.nodes) {\n    <span class=\"hljs-keyword\">this</span>.makeGraph();\n  }\n\n  <span class=\"hljs-built_in\">int</span> <span class=\"hljs-keyword\">get</span> numberOfNodesInGraph {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.nodes.length;\n  }\n\n  HashMap <span class=\"hljs-keyword\">get</span> graphDataStructure {\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">this</span>.graph;\n  }\n\n  <span class=\"hljs-keyword\">void</span> addNodes(<span class=\"hljs-built_in\">int</span> newNode) {\n    <span class=\"hljs-keyword\">this</span>.nodes.add(newNode);\n    <span class=\"hljs-keyword\">this</span>.graph[newNode] = <span class=\"hljs-built_in\">List</span>();\n  }\n\n  <span class=\"hljs-keyword\">void</span> addEdges(<span class=\"hljs-built_in\">int</span> start, <span class=\"hljs-built_in\">int</span> end) {\n    <span class=\"hljs-keyword\">this</span>.graph[start].add(end);\n  }\n}\n\n<span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; breadthFirstSearch(Graph graph, <span class=\"hljs-built_in\">int</span> numberOfNodes, <span class=\"hljs-built_in\">int</span> startNode) {\n  Queue queue = <span class=\"hljs-keyword\">new</span> Queue&lt;<span class=\"hljs-built_in\">int</span>&gt;();\n  <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; answer = <span class=\"hljs-built_in\">List</span>();\n  queue.add(startNode);\n  <span class=\"hljs-keyword\">while</span> (queue.isNotEmpty) {\n    <span class=\"hljs-built_in\">int</span> node = queue.removeFirst();\n    answer.add(node);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> child <span class=\"hljs-keyword\">in</span> graph.graph[node]) {\n      queue.add(child);\n    }\n  }\n  <span class=\"hljs-keyword\">return</span> answer;\n}\n\n<span class=\"hljs-keyword\">void</span> main() {\n  test((<span class=\"hljs-string\">&#x27;Test case 1:&#x27;</span>), () {\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; nodes = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>];\n    <span class=\"hljs-built_in\">int</span> numberOfEdges = <span class=\"hljs-number\">2</span>;\n\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt;&gt; edges = [\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>]\n    ];\n    Graph graph = Graph(nodes);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; numberOfEdges; i++) {\n      <span class=\"hljs-built_in\">int</span> start = edges[i][<span class=\"hljs-number\">0</span>];\n      <span class=\"hljs-built_in\">int</span> end = edges[i][<span class=\"hljs-number\">1</span>];\n      graph.addEdges(start, end);\n    }\n    <span class=\"hljs-built_in\">int</span> startNode = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; answer =\n        breadthFirstSearch(graph, graph.numberOfNodesInGraph, startNode);\n    expect(answer, equals([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]));\n  });\n\n  test((<span class=\"hljs-string\">&#x27;Test case 2:&#x27;</span>), () {\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; nodes = [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>];\n    <span class=\"hljs-built_in\">int</span> numberOfEdges = <span class=\"hljs-number\">4</span>;\n\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt;&gt; edges = [\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>],\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>],\n      [<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>],\n      [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>]\n    ];\n    Graph graph = Graph(nodes);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; numberOfEdges; i++) {\n      <span class=\"hljs-built_in\">int</span> start = edges[i][<span class=\"hljs-number\">0</span>];\n      <span class=\"hljs-built_in\">int</span> end = edges[i][<span class=\"hljs-number\">1</span>];\n      graph.addEdges(start, end);\n    }\n    <span class=\"hljs-built_in\">int</span> startNode = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-built_in\">List</span>&lt;<span class=\"hljs-built_in\">int</span>&gt; answer =\n        breadthFirstSearch(graph, graph.numberOfNodesInGraph, startNode);\n    expect(answer, equals([<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>]));\n  });\n}\n"
    },
    "c-sharp": {
      "dir": "./Algorithms/Graph/BreadthFirstSearch.cs",
      "url": "https:/github.com/TheAlgorithms/C-Sharp/tree/master/Algorithms/Graph/BreadthFirstSearch.cs",
      "code": "<span class=\"hljs-keyword\">using</span> System;\n<span class=\"hljs-keyword\">using</span> System.Collections.Generic;\n<span class=\"hljs-keyword\">using</span> DataStructures.Graph;\n\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">Algorithms.Graph</span>\n{\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> Breadth First Search - algorithm for traversing graph.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> Algorithm starts from root node that is selected by the user.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> Algorithm explores all nodes at the present depth.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;typeparam name=&quot;T&quot;&gt;</span>Vertex data type.<span class=\"hljs-doctag\">&lt;/typeparam&gt;</span></span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">BreadthFirstSearch</span>&lt;<span class=\"hljs-title\">T</span>&gt; : <span class=\"hljs-title\">IGraphSearch</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">where</span> <span class=\"hljs-title\">T</span> : <span class=\"hljs-title\">IComparable</span>&lt;<span class=\"hljs-title\">T</span>&gt;\n    {\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> Traverses graph from start vertex.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;graph&quot;&gt;</span>Graph instance.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;startVertex&quot;&gt;</span>Vertex that search starts from.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;action&quot;&gt;</span>Action that needs to be executed on each graph vertex.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">VisitAll</span>(<span class=\"hljs-params\">IDirectedWeightedGraph&lt;T&gt; graph, Vertex&lt;T&gt; startVertex, Action&lt;Vertex&lt;T&gt;&gt;? action = <span class=\"hljs-literal\">default</span></span>)</span>\n        {\n            Bfs(graph, startVertex, action, <span class=\"hljs-keyword\">new</span> HashSet&lt;Vertex&lt;T&gt;&gt;());\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> Traverses graph from start vertex.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;graph&quot;&gt;</span>Graph instance.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;startVertex&quot;&gt;</span>Vertex that search starts from.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;action&quot;&gt;</span>Action that needs to be executed on each graph vertex.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;visited&quot;&gt;</span>Hash set with visited vertices.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Bfs</span>(<span class=\"hljs-params\">IDirectedWeightedGraph&lt;T&gt; graph, Vertex&lt;T&gt; startVertex, Action&lt;Vertex&lt;T&gt;&gt;? action, HashSet&lt;Vertex&lt;T&gt;&gt; visited</span>)</span>\n        {\n            <span class=\"hljs-keyword\">var</span> queue = <span class=\"hljs-keyword\">new</span> Queue&lt;Vertex&lt;T&gt;&gt;();\n\n            queue.Enqueue(startVertex);\n\n            <span class=\"hljs-keyword\">while</span> (queue.Count &gt; <span class=\"hljs-number\">0</span>)\n            {\n                <span class=\"hljs-keyword\">var</span> currentVertex = queue.Dequeue();\n\n                <span class=\"hljs-keyword\">if</span> (currentVertex == <span class=\"hljs-literal\">null</span> || visited.Contains(currentVertex))\n                {\n                    <span class=\"hljs-keyword\">continue</span>;\n                }\n\n                <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> vertex <span class=\"hljs-keyword\">in</span> graph.GetNeighbors(currentVertex))\n                {\n                    queue.Enqueue(vertex!);\n                }\n\n                action?.Invoke(currentVertex);\n\n                visited.Add(currentVertex);\n            }\n        }\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Anup Kumar Panwar",
      "email": "1anuppanwar@gmail.com",
      "commits": 1
    },
    {
      "name": "scturtle",
      "email": "scturtle@gmail.com",
      "commits": 1
    },
    {
      "name": "Joshua Ford",
      "email": "joshua.ford@protonmail.com",
      "commits": 1
    },
    {
      "name": "AlexDvorak",
      "email": "opti.jawsome@gmail.com",
      "commits": 1
    },
    {
      "name": "Akash G Krishnan",
      "email": "krishnanag1996@gmail.com",
      "commits": 1
    },
    {
      "name": "BohdanLev",
      "email": "43375672+BohdanLev@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Taj",
      "email": "tjgurwara99@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Simon Berndtsson",
      "email": "simon.berndtsson@gmail.com",
      "commits": 1
    },
    {
      "name": "Brayo",
      "email": "vukubrian@gmail.com",
      "commits": 1
    },
    {
      "name": "Kaveh Fazaeli",
      "email": "kaveh.fazaeli@gmail.com",
      "commits": 1
    },
    {
      "name": "hasan",
      "email": "hasanuli10@gmail.com",
      "commits": 1
    },
    {
      "name": "ParthS007",
      "email": "parth1989shandilya@gmail.com",
      "commits": 1
    },
    {
      "name": "Kaustubh Damania",
      "email": "kaustubh.damania@gmail.com",
      "commits": 1
    },
    {
      "name": "gpamangkp",
      "email": "gpamangkp.18je0087@mc.iitism.ac.in",
      "commits": 1
    },
    {
      "name": "caos321",
      "email": "36530240+caos321@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Rohan R Bharadwaj",
      "email": "rohanrbharadwaj@gmail.com",
      "commits": 1
    },
    {
      "name": "Casper Rysgaard",
      "email": "Crowton@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Lewis Tian",
      "email": "taseikyo@gmail.com",
      "commits": 1
    },
    {
      "name": "Sanders Lin",
      "email": "45224617+SandersLin@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "cclauss",
      "email": "cclauss@bluewin.ch",
      "commits": 1
    },
    {
      "name": "97arushisharma",
      "email": "97arushisharma@gmail.com",
      "commits": 1
    },
    {
      "name": "mounaim",
      "email": "mounaim.zaryouhi@gmail.com",
      "commits": 1
    },
    {
      "name": "algobytewise",
      "email": "algobytewise@gmail.com",
      "commits": 2
    },
    {
      "name": "rxaru",
      "email": "ai.kanaria.ai@gmail.com",
      "commits": 2
    },
    {
      "name": "Roland Hummel",
      "email": "roland.hummel@qaware.de",
      "commits": 2
    },
    {
      "name": "Alvin Nguyen",
      "email": "alvin@D-10-16-24-223.dhcp4.washington.edu",
      "commits": 2
    },
    {
      "name": "Francisco Matias",
      "email": "franciscomatias@alu.ufc.br",
      "commits": 2
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 3
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 4
    },
    {
      "name": "Gpamangkp",
      "email": "41160734+Gpamangkp@users.noreply.github.com",
      "commits": 7
    }
  ],
  "explanationUrl": {}
}