{
  "slug": "check-if-binary-tree-balanced",
  "name": "Check If Binary Tree Balanced",
  "categories": [
    "datastructures",
    "tree"
  ],
  "body": {},
  "implementations": {
    "java": {
      "dir": "src/main/java/com/thealgorithms/datastructures/trees/CheckIfBinaryTreeBalanced.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src/main/java/com/thealgorithms/datastructures/trees/CheckIfBinaryTreeBalanced.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.datastructures.trees;\n\n<span class=\"hljs-keyword\">import</span> java.util.Stack;\n<span class=\"hljs-keyword\">import</span> java.util.HashMap;\n\n<span class=\"hljs-comment\">/**\n * This class will check if a BinaryTree is balanced. A balanced binary tree is\n * defined as a binary tree where the differenced in height between the left and\n * right subtree of each node differs by at most one.\n *\n * This can be done in both an iterative and recursive fashion. Below,\n * `isBalancedRecursive()` is implemented in a recursive fashion, and\n * `isBalancedIterative()` is implemented in an iterative fashion.\n *\n * <span class=\"hljs-doctag\">@author</span> [Ian Cowan](https://github.com/iccowan)\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">CheckIfBinaryTreeBalanced</span> {\n\n    <span class=\"hljs-comment\">/**\n     * This class implements the BinaryTree for these algorithms\n     */</span>\n    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BinaryTree</span> {\n\n        <span class=\"hljs-comment\">/**\n         * The root node of the binary tree\n         */</span>\n        <span class=\"hljs-type\">BTNode</span> <span class=\"hljs-variable\">root</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * This class implements the nodes for the binary tree\n     */</span>\n    <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BTNode</span> {\n\n        <span class=\"hljs-comment\">/**\n         * The value of the node\n         */</span>\n        <span class=\"hljs-type\">int</span> value;\n\n        <span class=\"hljs-comment\">/**\n         * The left child of the node\n         */</span>\n        <span class=\"hljs-type\">BTNode</span> <span class=\"hljs-variable\">left</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n\n        <span class=\"hljs-comment\">/**\n         * The right child of the node\n         */</span>\n        <span class=\"hljs-type\">BTNode</span> <span class=\"hljs-variable\">right</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n\n        <span class=\"hljs-comment\">/**\n         * Constructor\n         */</span>\n        BTNode(<span class=\"hljs-type\">int</span> value) {\n            <span class=\"hljs-built_in\">this</span>.value = value;\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Recursive is BT balanced implementation\n     *\n     * <span class=\"hljs-doctag\">@param</span> binaryTree The binary tree to check if balanced\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isBalancedRecursive</span><span class=\"hljs-params\">(BinaryTree binaryTree)</span> {\n        <span class=\"hljs-comment\">// Create an array of length 1 to keep track of our balance</span>\n        <span class=\"hljs-comment\">// Default to true. We use an array so we have an efficient mutable object</span>\n        <span class=\"hljs-type\">boolean</span>[] isBalanced = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">boolean</span>[<span class=\"hljs-number\">1</span>];\n        isBalanced[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-literal\">true</span>;\n\n        <span class=\"hljs-comment\">// Check for balance and return whether or not we are balanced</span>\n        isBalancedRecursive(binaryTree.root, <span class=\"hljs-number\">0</span>, isBalanced);\n        <span class=\"hljs-keyword\">return</span> isBalanced[<span class=\"hljs-number\">0</span>];\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Private helper method to keep track of the depth and balance during\n     * recursion. We effectively perform a modified post-order traversal where\n     * we are looking at the heights of both children of each node in the tree\n     *\n     * <span class=\"hljs-doctag\">@param</span> node The current node to explore\n     * <span class=\"hljs-doctag\">@param</span> depth The current depth of the node\n     * <span class=\"hljs-doctag\">@param</span> isBalanced The array of length 1 keeping track of our balance\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">isBalancedRecursive</span><span class=\"hljs-params\">(BTNode node, <span class=\"hljs-type\">int</span> depth, <span class=\"hljs-type\">boolean</span>[] isBalanced)</span> {\n        <span class=\"hljs-comment\">// If the node is null, we should not explore it and the height is 0</span>\n        <span class=\"hljs-comment\">// If the tree is already not balanced, might as well stop because we</span>\n        <span class=\"hljs-comment\">// can&#x27;t make it balanced now!</span>\n        <span class=\"hljs-keyword\">if</span> (node == <span class=\"hljs-literal\">null</span> || !isBalanced[<span class=\"hljs-number\">0</span>]) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n        }\n\n        <span class=\"hljs-comment\">// Visit the left and right children, incrementing their depths by 1</span>\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">leftHeight</span> <span class=\"hljs-operator\">=</span> isBalancedRecursive(node.left, depth + <span class=\"hljs-number\">1</span>, isBalanced);\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">rightHeight</span> <span class=\"hljs-operator\">=</span> isBalancedRecursive(node.right, depth + <span class=\"hljs-number\">1</span>, isBalanced);\n\n        <span class=\"hljs-comment\">// If the height of either of the left or right subtrees differ by more</span>\n        <span class=\"hljs-comment\">// than 1, we cannot be balanced</span>\n        <span class=\"hljs-keyword\">if</span> (Math.abs(leftHeight - rightHeight) &gt; <span class=\"hljs-number\">1</span>) {\n            isBalanced[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-literal\">false</span>;\n        }\n\n        <span class=\"hljs-comment\">// The height of our tree is the maximum of the heights of the left</span>\n        <span class=\"hljs-comment\">// and right subtrees plus one</span>\n        <span class=\"hljs-keyword\">return</span> Math.max(leftHeight, rightHeight) + <span class=\"hljs-number\">1</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Iterative is BT balanced implementation\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isBalancedIterative</span><span class=\"hljs-params\">(BinaryTree binaryTree)</span> {\n        <span class=\"hljs-comment\">// Default that we are balanced and our algo will prove it wrong</span>\n        <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">isBalanced</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">true</span>;\n\n        <span class=\"hljs-comment\">// Create a stack for our post order traversal</span>\n        Stack&lt;BTNode&gt; nodeStack = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Stack</span>&lt;BTNode&gt;();\n\n        <span class=\"hljs-comment\">// For post order traversal, we&#x27;ll have to keep track of where we</span>\n        <span class=\"hljs-comment\">// visited last</span>\n        <span class=\"hljs-type\">BTNode</span> <span class=\"hljs-variable\">lastVisited</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n\n        <span class=\"hljs-comment\">// Create a HashMap to keep track of the subtree heights for each node</span>\n        HashMap&lt;BTNode, Integer&gt; subtreeHeights = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;BTNode, Integer&gt;();\n\n        <span class=\"hljs-comment\">// We begin at the root of the tree</span>\n        <span class=\"hljs-type\">BTNode</span> <span class=\"hljs-variable\">node</span> <span class=\"hljs-operator\">=</span> binaryTree.root;\n\n        <span class=\"hljs-comment\">// We loop while:</span>\n        <span class=\"hljs-comment\">// - the node stack is empty and the node we explore is null</span>\n        <span class=\"hljs-comment\">// AND</span>\n        <span class=\"hljs-comment\">// - the tree is still balanced</span>\n        <span class=\"hljs-keyword\">while</span> (!(nodeStack.isEmpty() &amp;&amp; node == <span class=\"hljs-literal\">null</span>) &amp;&amp; isBalanced) {\n            <span class=\"hljs-comment\">// If the node is not null, we push it to the stack and continue</span>\n            <span class=\"hljs-comment\">// to the left</span>\n            <span class=\"hljs-keyword\">if</span> (node != <span class=\"hljs-literal\">null</span>) {\n                nodeStack.push(node);\n                node = node.left;\n                <span class=\"hljs-comment\">// Once we hit a node that is null, we are as deep as we can go</span>\n                <span class=\"hljs-comment\">// to the left</span>\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-comment\">// Find the last node we put on the stack</span>\n                node = nodeStack.peek();\n\n                <span class=\"hljs-comment\">// If the right child of the node has either been visited or</span>\n                <span class=\"hljs-comment\">// is null, we visit this node</span>\n                <span class=\"hljs-keyword\">if</span> (node.right == <span class=\"hljs-literal\">null</span> || node.right == lastVisited) {\n                    <span class=\"hljs-comment\">// We assume the left and right heights are 0</span>\n                    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">leftHeight</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n                    <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">rightHeight</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n\n                    <span class=\"hljs-comment\">// If the right and left children are not null, we must</span>\n                    <span class=\"hljs-comment\">// have already explored them and have a height</span>\n                    <span class=\"hljs-comment\">// for them so let&#x27;s get that</span>\n                    <span class=\"hljs-keyword\">if</span> (node.left != <span class=\"hljs-literal\">null</span>) {\n                        leftHeight = subtreeHeights.get(node.left);\n                    }\n\n                    <span class=\"hljs-keyword\">if</span> (node.right != <span class=\"hljs-literal\">null</span>) {\n                        rightHeight = subtreeHeights.get(node.right);\n                    }\n\n                    <span class=\"hljs-comment\">// If the difference in the height of the right subtree</span>\n                    <span class=\"hljs-comment\">// and left subtree differs by more than 1, we cannot be</span>\n                    <span class=\"hljs-comment\">// balanced</span>\n                    <span class=\"hljs-keyword\">if</span> (Math.abs(rightHeight - leftHeight) &gt; <span class=\"hljs-number\">1</span>) {\n                        isBalanced = <span class=\"hljs-literal\">false</span>;\n                    }\n\n                    <span class=\"hljs-comment\">// The height of the subtree containing this node is the</span>\n                    <span class=\"hljs-comment\">// max of the left and right subtree heighs plus 1</span>\n                    subtreeHeights.put(node, Math.max(rightHeight, leftHeight) + <span class=\"hljs-number\">1</span>);\n\n                    <span class=\"hljs-comment\">// We&#x27;ve now visited this node, so we pop it from the stack</span>\n                    nodeStack.pop();\n                    lastVisited = node;\n\n                    <span class=\"hljs-comment\">// Current visiting node is now null</span>\n                    node = <span class=\"hljs-literal\">null</span>;\n                    <span class=\"hljs-comment\">// If the right child node of this node has not been visited</span>\n                    <span class=\"hljs-comment\">// and is not null, we need to get that child node on the stack</span>\n                } <span class=\"hljs-keyword\">else</span> {\n                    node = node.right;\n                }\n            }\n        }\n\n        <span class=\"hljs-comment\">// Return whether or not the tree is balanced</span>\n        <span class=\"hljs-keyword\">return</span> isBalanced;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Generates the following unbalanced binary tree for testing 0 / \\ / \\ 0 0\n     * / / \\ / / \\ 0 0 0 / \\ / \\ 0 0 / / 0\n     */</span>\n    <span class=\"hljs-keyword\">private</span> BinaryTree <span class=\"hljs-title function_\">buildUnbalancedTree</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-type\">BinaryTree</span> <span class=\"hljs-variable\">tree</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BinaryTree</span>();\n        tree.root = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n\n        <span class=\"hljs-type\">BTNode</span> <span class=\"hljs-variable\">root</span> <span class=\"hljs-operator\">=</span> tree.root;\n        root.left = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n        root.right = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n\n        <span class=\"hljs-type\">BTNode</span> <span class=\"hljs-variable\">left</span> <span class=\"hljs-operator\">=</span> root.left;\n        <span class=\"hljs-type\">BTNode</span> <span class=\"hljs-variable\">right</span> <span class=\"hljs-operator\">=</span> root.right;\n\n        left.left = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n        right.left = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n        right.right = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n        right.left.right = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n\n        left = left.left;\n        left.left = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n        left.left.left = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n        left.left.left.left = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n\n        <span class=\"hljs-keyword\">return</span> tree;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Generates the following balanced binary tree for testing 0 / \\ / \\ 0 0 /\n     * \\ / \\ / 0 / \\ 0 0 0 / / / / 0 0\n     */</span>\n    <span class=\"hljs-keyword\">private</span> BinaryTree <span class=\"hljs-title function_\">buildBalancedTree</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-type\">BinaryTree</span> <span class=\"hljs-variable\">tree</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BinaryTree</span>();\n        tree.root = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n\n        <span class=\"hljs-type\">BTNode</span> <span class=\"hljs-variable\">root</span> <span class=\"hljs-operator\">=</span> tree.root;\n        root.left = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n        root.right = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n\n        <span class=\"hljs-type\">BTNode</span> <span class=\"hljs-variable\">left</span> <span class=\"hljs-operator\">=</span> root.left;\n        <span class=\"hljs-type\">BTNode</span> <span class=\"hljs-variable\">right</span> <span class=\"hljs-operator\">=</span> root.right;\n\n        left.left = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n        left.right = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n        right.left = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n        right.right = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n\n        right.right.left = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n\n        left.left.left = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BTNode</span>(<span class=\"hljs-number\">0</span>);\n\n        <span class=\"hljs-keyword\">return</span> tree;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Main\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-comment\">// We create a new object to check the binary trees for balance</span>\n        <span class=\"hljs-type\">CheckIfBinaryTreeBalanced</span> <span class=\"hljs-variable\">balanceCheck</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">CheckIfBinaryTreeBalanced</span>();\n\n        <span class=\"hljs-comment\">// Build a balanced and unbalanced binary tree</span>\n        <span class=\"hljs-type\">BinaryTree</span> <span class=\"hljs-variable\">balancedTree</span> <span class=\"hljs-operator\">=</span> balanceCheck.buildBalancedTree();\n        <span class=\"hljs-type\">BinaryTree</span> <span class=\"hljs-variable\">unbalancedTree</span> <span class=\"hljs-operator\">=</span> balanceCheck.buildUnbalancedTree();\n\n        <span class=\"hljs-comment\">// Run basic tests on the algorithms to check for balance</span>\n        <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">isBalancedRB</span> <span class=\"hljs-operator\">=</span> balanceCheck.isBalancedRecursive(balancedTree); <span class=\"hljs-comment\">// true</span>\n        <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">isBalancedRU</span> <span class=\"hljs-operator\">=</span> balanceCheck.isBalancedRecursive(unbalancedTree); <span class=\"hljs-comment\">// false</span>\n        <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">isBalancedIB</span> <span class=\"hljs-operator\">=</span> balanceCheck.isBalancedIterative(balancedTree); <span class=\"hljs-comment\">// true</span>\n        <span class=\"hljs-type\">boolean</span> <span class=\"hljs-variable\">isBalancedIU</span> <span class=\"hljs-operator\">=</span> balanceCheck.isBalancedIterative(unbalancedTree); <span class=\"hljs-comment\">// false</span>\n\n        <span class=\"hljs-comment\">// Print the results</span>\n        System.out.println(<span class=\"hljs-string\">&quot;isBalancedRB: &quot;</span> + isBalancedRB);\n        System.out.println(<span class=\"hljs-string\">&quot;isBalancedRU: &quot;</span> + isBalancedRU);\n        System.out.println(<span class=\"hljs-string\">&quot;isBalancedIB: &quot;</span> + isBalancedIB);\n        System.out.println(<span class=\"hljs-string\">&quot;isBalancedIU: &quot;</span> + isBalancedIU);\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Ian Cowan",
      "email": "38896380+iccowan@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}