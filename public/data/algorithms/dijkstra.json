{
  "slug": "dijkstra",
  "name": "Dijkstra",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "graphs/dijkstra.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/graphs/dijkstra.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;\npseudo-code\n\nDIJKSTRA(graph G, start vertex s, destination vertex d):\n\n//all nodes initially unexplored\n\n1 -  let H = min heap data structure, initialized with 0 and s [here 0 indicates\n     the distance from start vertex s]\n2 -  while H is non-empty:\n3 -    remove the first node and cost of H, call it U and cost\n4 -    if U has been previously explored:\n5 -      go to the while loop, line 2 //Once a node is explored there is no need\n         to make it again\n6 -    mark U as explored\n7 -    if U is d:\n8 -      return cost // total cost from start to destination vertex\n9 -    for each edge(U, V): c=cost of edge(U,V) // for V in graph[U]\n10 -     if V explored:\n11 -       go to next V in line 9\n12 -     total_cost = cost + c\n13 -     add (total_cost,V) to H\n\nYou can think at cost as a distance where Dijkstra finds the shortest distance\nbetween vertices s and v in a graph G. The use of a min heap as H guarantees\nthat if a vertex has already been explored there will be no other path with\nshortest distance, that happens because heapq.heappop will always return the\nnext vertex with the shortest distance, considering that the heap stores not\nonly the distance between previous vertex and current vertex but the entire\ndistance between each vertex that makes up the path from start vertex to target\nvertex.\n&quot;&quot;&quot;</span>\n<span class=\"hljs-keyword\">import</span> heapq\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">dijkstra</span>(<span class=\"hljs-params\">graph, start, end</span>):\n    <span class=\"hljs-string\">&quot;&quot;&quot;Return the cost of the shortest path between vertices start and end.\n\n    &gt;&gt;&gt; dijkstra(G, &quot;E&quot;, &quot;C&quot;)\n    6\n    &gt;&gt;&gt; dijkstra(G2, &quot;E&quot;, &quot;F&quot;)\n    3\n    &gt;&gt;&gt; dijkstra(G3, &quot;E&quot;, &quot;F&quot;)\n    3\n    &quot;&quot;&quot;</span>\n\n    heap = [(<span class=\"hljs-number\">0</span>, start)]  <span class=\"hljs-comment\"># cost from start node,end node</span>\n    visited = <span class=\"hljs-built_in\">set</span>()\n    <span class=\"hljs-keyword\">while</span> heap:\n        (cost, u) = heapq.heappop(heap)\n        <span class=\"hljs-keyword\">if</span> u <span class=\"hljs-keyword\">in</span> visited:\n            <span class=\"hljs-keyword\">continue</span>\n        visited.add(u)\n        <span class=\"hljs-keyword\">if</span> u == end:\n            <span class=\"hljs-keyword\">return</span> cost\n        <span class=\"hljs-keyword\">for</span> v, c <span class=\"hljs-keyword\">in</span> graph[u]:\n            <span class=\"hljs-keyword\">if</span> v <span class=\"hljs-keyword\">in</span> visited:\n                <span class=\"hljs-keyword\">continue</span>\n            <span class=\"hljs-built_in\">next</span> = cost + c\n            heapq.heappush(heap, (<span class=\"hljs-built_in\">next</span>, v))\n    <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>\n\n\nG = {\n    <span class=\"hljs-string\">&quot;A&quot;</span>: [[<span class=\"hljs-string\">&quot;B&quot;</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-string\">&quot;C&quot;</span>, <span class=\"hljs-number\">5</span>]],\n    <span class=\"hljs-string\">&quot;B&quot;</span>: [[<span class=\"hljs-string\">&quot;A&quot;</span>, <span class=\"hljs-number\">2</span>], [<span class=\"hljs-string\">&quot;D&quot;</span>, <span class=\"hljs-number\">3</span>], [<span class=\"hljs-string\">&quot;E&quot;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&quot;F&quot;</span>, <span class=\"hljs-number\">1</span>]],\n    <span class=\"hljs-string\">&quot;C&quot;</span>: [[<span class=\"hljs-string\">&quot;A&quot;</span>, <span class=\"hljs-number\">5</span>], [<span class=\"hljs-string\">&quot;F&quot;</span>, <span class=\"hljs-number\">3</span>]],\n    <span class=\"hljs-string\">&quot;D&quot;</span>: [[<span class=\"hljs-string\">&quot;B&quot;</span>, <span class=\"hljs-number\">3</span>]],\n    <span class=\"hljs-string\">&quot;E&quot;</span>: [[<span class=\"hljs-string\">&quot;B&quot;</span>, <span class=\"hljs-number\">4</span>], [<span class=\"hljs-string\">&quot;F&quot;</span>, <span class=\"hljs-number\">3</span>]],\n    <span class=\"hljs-string\">&quot;F&quot;</span>: [[<span class=\"hljs-string\">&quot;C&quot;</span>, <span class=\"hljs-number\">3</span>], [<span class=\"hljs-string\">&quot;E&quot;</span>, <span class=\"hljs-number\">3</span>]],\n}\n\n<span class=\"hljs-string\">r&quot;&quot;&quot;\nLayout of G2:\n\nE -- 1 --&gt; B -- 1 --&gt; C -- 1 --&gt; D -- 1 --&gt; F\n \\                                         /\\\n  \\                                        ||\n    ----------------- 3 --------------------\n&quot;&quot;&quot;</span>\nG2 = {\n    <span class=\"hljs-string\">&quot;B&quot;</span>: [[<span class=\"hljs-string\">&quot;C&quot;</span>, <span class=\"hljs-number\">1</span>]],\n    <span class=\"hljs-string\">&quot;C&quot;</span>: [[<span class=\"hljs-string\">&quot;D&quot;</span>, <span class=\"hljs-number\">1</span>]],\n    <span class=\"hljs-string\">&quot;D&quot;</span>: [[<span class=\"hljs-string\">&quot;F&quot;</span>, <span class=\"hljs-number\">1</span>]],\n    <span class=\"hljs-string\">&quot;E&quot;</span>: [[<span class=\"hljs-string\">&quot;B&quot;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&quot;F&quot;</span>, <span class=\"hljs-number\">3</span>]],\n    <span class=\"hljs-string\">&quot;F&quot;</span>: [],\n}\n\n<span class=\"hljs-string\">r&quot;&quot;&quot;\nLayout of G3:\n\nE -- 1 --&gt; B -- 1 --&gt; C -- 1 --&gt; D -- 1 --&gt; F\n \\                                         /\\\n  \\                                        ||\n    -------- 2 ---------&gt; G ------- 1 ------\n&quot;&quot;&quot;</span>\nG3 = {\n    <span class=\"hljs-string\">&quot;B&quot;</span>: [[<span class=\"hljs-string\">&quot;C&quot;</span>, <span class=\"hljs-number\">1</span>]],\n    <span class=\"hljs-string\">&quot;C&quot;</span>: [[<span class=\"hljs-string\">&quot;D&quot;</span>, <span class=\"hljs-number\">1</span>]],\n    <span class=\"hljs-string\">&quot;D&quot;</span>: [[<span class=\"hljs-string\">&quot;F&quot;</span>, <span class=\"hljs-number\">1</span>]],\n    <span class=\"hljs-string\">&quot;E&quot;</span>: [[<span class=\"hljs-string\">&quot;B&quot;</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-string\">&quot;G&quot;</span>, <span class=\"hljs-number\">2</span>]],\n    <span class=\"hljs-string\">&quot;F&quot;</span>: [],\n    <span class=\"hljs-string\">&quot;G&quot;</span>: [[<span class=\"hljs-string\">&quot;F&quot;</span>, <span class=\"hljs-number\">1</span>]],\n}\n\nshortDistance = dijkstra(G, <span class=\"hljs-string\">&quot;E&quot;</span>, <span class=\"hljs-string\">&quot;C&quot;</span>)\n<span class=\"hljs-built_in\">print</span>(shortDistance)  <span class=\"hljs-comment\"># E -- 3 --&gt; F -- 3 --&gt; C == 6</span>\n\nshortDistance = dijkstra(G2, <span class=\"hljs-string\">&quot;E&quot;</span>, <span class=\"hljs-string\">&quot;F&quot;</span>)\n<span class=\"hljs-built_in\">print</span>(shortDistance)  <span class=\"hljs-comment\"># E -- 3 --&gt; F == 3</span>\n\nshortDistance = dijkstra(G3, <span class=\"hljs-string\">&quot;E&quot;</span>, <span class=\"hljs-string\">&quot;F&quot;</span>)\n<span class=\"hljs-built_in\">print</span>(shortDistance)  <span class=\"hljs-comment\"># E -- 2 --&gt; G -- 1 --&gt; F == 3</span>\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">import</span> doctest\n\n    doctest.testmod()\n"
    },
    "javascript": {
      "dir": "Graphs/Dijkstra.js",
      "url": "https://github.com/TheAlgorithms/javascript/tree/master/Graphs/Dijkstra.js",
      "code": "<span class=\"hljs-comment\">/**\n * Author: Samarth Jain\n * Dijkstra&#x27;s Algorithm implementation in JavaScript\n * Dijkstra&#x27;s Algorithm calculates the minimum distance between two nodes.\n * It is used to find the shortest path.\n * It uses graph data structure.\n */</span>\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">createGraph</span> (V, E) {\n  <span class=\"hljs-comment\">// V - Number of vertices in graph</span>\n  <span class=\"hljs-comment\">// E - Number of edges in graph (u,v,w)</span>\n  <span class=\"hljs-keyword\">const</span> adjList = [] <span class=\"hljs-comment\">// Adjacency list</span>\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) {\n    adjList.<span class=\"hljs-title function_\">push</span>([])\n  }\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; E.<span class=\"hljs-property\">length</span>; i++) {\n    adjList[E[i][<span class=\"hljs-number\">0</span>]].<span class=\"hljs-title function_\">push</span>([E[i][<span class=\"hljs-number\">1</span>], E[i][<span class=\"hljs-number\">2</span>]])\n    adjList[E[i][<span class=\"hljs-number\">1</span>]].<span class=\"hljs-title function_\">push</span>([E[i][<span class=\"hljs-number\">0</span>], E[i][<span class=\"hljs-number\">2</span>]])\n  }\n  <span class=\"hljs-keyword\">return</span> adjList\n}\n\n<span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">djikstra</span> (graph, V, src) {\n  <span class=\"hljs-keyword\">const</span> vis = <span class=\"hljs-title class_\">Array</span>(V).<span class=\"hljs-title function_\">fill</span>(<span class=\"hljs-number\">0</span>)\n  <span class=\"hljs-keyword\">const</span> dist = []\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) dist.<span class=\"hljs-title function_\">push</span>([<span class=\"hljs-number\">10000</span>, -<span class=\"hljs-number\">1</span>])\n  dist[src][<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>\n\n  <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; V - <span class=\"hljs-number\">1</span>; i++) {\n    <span class=\"hljs-keyword\">let</span> mn = -<span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = <span class=\"hljs-number\">0</span>; j &lt; V; j++) {\n      <span class=\"hljs-keyword\">if</span> (vis[j] === <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-keyword\">if</span> (mn === -<span class=\"hljs-number\">1</span> || dist[j][<span class=\"hljs-number\">0</span>] &lt; dist[mn][<span class=\"hljs-number\">0</span>]) mn = j\n      }\n    }\n\n    vis[mn] = <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> j = <span class=\"hljs-number\">0</span>; j &lt; graph[mn].<span class=\"hljs-property\">length</span>; j++) {\n      <span class=\"hljs-keyword\">const</span> edge = graph[mn][j]\n      <span class=\"hljs-keyword\">if</span> (vis[edge[<span class=\"hljs-number\">0</span>]] === <span class=\"hljs-number\">0</span> &amp;&amp; dist[edge[<span class=\"hljs-number\">0</span>]][<span class=\"hljs-number\">0</span>] &gt; dist[mn][<span class=\"hljs-number\">0</span>] + edge[<span class=\"hljs-number\">1</span>]) {\n        dist[edge[<span class=\"hljs-number\">0</span>]][<span class=\"hljs-number\">0</span>] = dist[mn][<span class=\"hljs-number\">0</span>] + edge[<span class=\"hljs-number\">1</span>]\n        dist[edge[<span class=\"hljs-number\">0</span>]][<span class=\"hljs-number\">1</span>] = mn\n      }\n    }\n  }\n\n  <span class=\"hljs-keyword\">return</span> dist\n}\n\n<span class=\"hljs-keyword\">export</span> { createGraph, djikstra }\n\n<span class=\"hljs-comment\">// const V = 9</span>\n<span class=\"hljs-comment\">// const E = [</span>\n<span class=\"hljs-comment\">//   [0, 1, 4],</span>\n<span class=\"hljs-comment\">//   [0, 7, 8],</span>\n<span class=\"hljs-comment\">//   [1, 7, 11],</span>\n<span class=\"hljs-comment\">//   [1, 2, 8],</span>\n<span class=\"hljs-comment\">//   [7, 8, 7],</span>\n<span class=\"hljs-comment\">//   [6, 7, 1],</span>\n<span class=\"hljs-comment\">//   [2, 8, 2],</span>\n<span class=\"hljs-comment\">//   [6, 8, 6],</span>\n<span class=\"hljs-comment\">//   [5, 6, 2],</span>\n<span class=\"hljs-comment\">//   [2, 5, 4],</span>\n<span class=\"hljs-comment\">//   [2, 3, 7],</span>\n<span class=\"hljs-comment\">//   [3, 5, 14],</span>\n<span class=\"hljs-comment\">//   [3, 4, 9],</span>\n<span class=\"hljs-comment\">//   [4, 5, 10]</span>\n<span class=\"hljs-comment\">// ]</span>\n\n<span class=\"hljs-comment\">// const graph = createGraph(V, E)</span>\n<span class=\"hljs-comment\">// const distances = djikstra(graph, V, 0)</span>\n\n<span class=\"hljs-comment\">/**\n * The first value in the array determines the minimum distance and the\n * second value represents the parent node from which the minimum distance has been calculated\n */</span>\n"
    },
    "c-plus-plus": {
      "dir": "graph/dijkstra.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph/dijkstra.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @brief [Graph Dijkstras Shortest Path Algorithm\n * (Dijkstra&#x27;s Shortest Path)]\n * (https://en.wikipedia.org/wiki/Dijkstra%27s_algorithm)\n *\n * @author [Ayaan Khan](http://github.com/ayaankhan98)\n *\n * @details\n * Dijkstra&#x27;s Algorithm is used to find the shortest path from a source\n * vertex to all other reachable vertex in the graph.\n * The algorithm initially assumes all the nodes are unreachable from the\n * given source vertex so we mark the distances of all vertices as INF\n * (infinity) from source vertex (INF / infinity denotes unable to reach).\n *\n * in similar fashion with BFS we assume the distance of source vertex as 0\n * and pushes the vertex in a priority queue with it&#x27;s distance.\n * we maintain the priority queue as a min heap so that we can get the\n * minimum element at the top of heap\n *\n * Basically what we do in this algorithm is that we try to minimize the\n * distances of all the reachable vertices from the current vertex, look\n * at the code below to understand in better way.\n *\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;limits&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;memory&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;utility&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">int64_t</span> INF = std::numeric_limits&lt;<span class=\"hljs-type\">int64_t</span>&gt;::<span class=\"hljs-built_in\">max</span>();\n\n<span class=\"hljs-comment\">/**\n * @namespace graph\n * @brief Graph Algorithms\n */</span>\n\n<span class=\"hljs-keyword\">namespace</span> graph {\n<span class=\"hljs-comment\">/**\n * @brief Function that add edge between two nodes or vertices of graph\n *\n * @param u any node or vertex of graph\n * @param v any node or vertex of graph\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addEdge</span><span class=\"hljs-params\">(std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;&gt;&gt; *adj, <span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> v,\n             <span class=\"hljs-type\">int</span> w)</span> </span>{\n    (*adj)[u - <span class=\"hljs-number\">1</span>].<span class=\"hljs-built_in\">push_back</span>(std::<span class=\"hljs-built_in\">make_pair</span>(v - <span class=\"hljs-number\">1</span>, w));\n    <span class=\"hljs-comment\">// (*adj)[v - 1].push_back(std::make_pair(u - 1, w));</span>\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Function runs the dijkstra algorithm for some source vertex and\n * target vertex in the graph and returns the shortest distance of target\n * from the source.\n *\n * @param adj input graph\n * @param s source vertex\n * @param t target vertex\n *\n * @return shortest distance if target is reachable from source else -1 in\n * case if target is not reachable from source.\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">dijkstra</span><span class=\"hljs-params\">(std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;&gt;&gt; *adj, <span class=\"hljs-type\">int</span> s, <span class=\"hljs-type\">int</span> t)</span> </span>{\n    <span class=\"hljs-comment\">/// n denotes the number of vertices in graph</span>\n    <span class=\"hljs-type\">int</span> n = adj-&gt;<span class=\"hljs-built_in\">size</span>();\n\n    <span class=\"hljs-comment\">/// setting all the distances initially to INF</span>\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; <span class=\"hljs-title\">dist</span><span class=\"hljs-params\">(n, INF)</span></span>;\n\n    <span class=\"hljs-comment\">/// creating a min heap using priority queue</span>\n    <span class=\"hljs-comment\">/// first element of pair contains the distance</span>\n    <span class=\"hljs-comment\">/// second element of pair contains the vertex</span>\n    std::priority_queue&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;, std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;&gt;,\n                        std::greater&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;&gt;&gt;\n        pq;\n\n    <span class=\"hljs-comment\">/// pushing the source vertex &#x27;s&#x27; with 0 distance in min heap</span>\n    pq.<span class=\"hljs-built_in\">push</span>(std::<span class=\"hljs-built_in\">make_pair</span>(<span class=\"hljs-number\">0</span>, s));\n\n    <span class=\"hljs-comment\">/// marking the distance of source as 0</span>\n    dist[s] = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-keyword\">while</span> (!pq.<span class=\"hljs-built_in\">empty</span>()) {\n        <span class=\"hljs-comment\">/// second element of pair denotes the node / vertex</span>\n        <span class=\"hljs-type\">int</span> currentNode = pq.<span class=\"hljs-built_in\">top</span>().second;\n\n        <span class=\"hljs-comment\">/// first element of pair denotes the distance</span>\n        <span class=\"hljs-type\">int</span> currentDist = pq.<span class=\"hljs-built_in\">top</span>().first;\n\n        pq.<span class=\"hljs-built_in\">pop</span>();\n\n        <span class=\"hljs-comment\">/// for all the reachable vertex from the currently exploring vertex</span>\n        <span class=\"hljs-comment\">/// we will try to minimize the distance</span>\n        <span class=\"hljs-keyword\">for</span> (std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; edge : (*adj)[currentNode]) {\n            <span class=\"hljs-comment\">/// minimizing distances</span>\n            <span class=\"hljs-keyword\">if</span> (currentDist + edge.second &lt; dist[edge.first]) {\n                dist[edge.first] = currentDist + edge.second;\n                pq.<span class=\"hljs-built_in\">push</span>(std::<span class=\"hljs-built_in\">make_pair</span>(dist[edge.first], edge.first));\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">if</span> (dist[t] != INF) {\n        <span class=\"hljs-keyword\">return</span> dist[t];\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n}\n}  <span class=\"hljs-comment\">// namespace graph</span>\n\n<span class=\"hljs-comment\">/** Function to test the Algorithm */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">tests</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Initiatinig Predefined Tests...&quot;</span> &lt;&lt; std::endl;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Initiating Test 1...&quot;</span> &lt;&lt; std::endl;\n    std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">adj1</span>(\n        <span class=\"hljs-number\">4</span>, std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;&gt;());\n    graph::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj1, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>);\n    graph::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj1, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n    graph::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj1, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>);\n    graph::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj1, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>);\n\n    <span class=\"hljs-type\">int</span> s = <span class=\"hljs-number\">1</span>, t = <span class=\"hljs-number\">3</span>;\n    <span class=\"hljs-built_in\">assert</span>(graph::<span class=\"hljs-built_in\">dijkstra</span>(&amp;adj1, s - <span class=\"hljs-number\">1</span>, t - <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">3</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1 Passed...&quot;</span> &lt;&lt; std::endl;\n\n    s = <span class=\"hljs-number\">4</span>, t = <span class=\"hljs-number\">3</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Initiating Test 2...&quot;</span> &lt;&lt; std::endl;\n    <span class=\"hljs-built_in\">assert</span>(graph::<span class=\"hljs-built_in\">dijkstra</span>(&amp;adj1, s - <span class=\"hljs-number\">1</span>, t - <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">5</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2 Passed...&quot;</span> &lt;&lt; std::endl;\n\n    std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">adj2</span>(\n        <span class=\"hljs-number\">5</span>, std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;&gt;());\n    graph::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>);\n    graph::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>);\n    graph::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>);\n    graph::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>);\n    graph::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>);\n    graph::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>);\n    graph::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>);\n    graph::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>);\n    graph::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj2, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>);\n\n    s = <span class=\"hljs-number\">1</span>, t = <span class=\"hljs-number\">5</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Initiating Test 3...&quot;</span> &lt;&lt; std::endl;\n    <span class=\"hljs-built_in\">assert</span>(graph::<span class=\"hljs-built_in\">dijkstra</span>(&amp;adj2, s - <span class=\"hljs-number\">1</span>, t - <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">6</span>);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 3 Passed...&quot;</span> &lt;&lt; std::endl;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;All Test Passed...&quot;</span> &lt;&lt; std::endl &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/** Main function */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">// running predefined tests</span>\n    <span class=\"hljs-built_in\">tests</span>();\n\n    <span class=\"hljs-type\">int</span> vertices = <span class=\"hljs-built_in\">int</span>(), edges = <span class=\"hljs-built_in\">int</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the number of vertices : &quot;</span>;\n    std::cin &gt;&gt; vertices;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Enter the number of edges : &quot;</span>;\n    std::cin &gt;&gt; edges;\n\n    std::vector&lt;std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">adj</span>(\n        vertices, std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt;&gt;());\n\n    <span class=\"hljs-type\">int</span> u = <span class=\"hljs-built_in\">int</span>(), v = <span class=\"hljs-built_in\">int</span>(), w = <span class=\"hljs-built_in\">int</span>();\n    <span class=\"hljs-keyword\">while</span> (edges--) {\n        std::cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;\n        graph::<span class=\"hljs-built_in\">addEdge</span>(&amp;adj, u, v, w);\n    }\n\n    <span class=\"hljs-type\">int</span> s = <span class=\"hljs-built_in\">int</span>(), t = <span class=\"hljs-built_in\">int</span>();\n    std::cin &gt;&gt; s &gt;&gt; t;\n    <span class=\"hljs-type\">int</span> dist = graph::<span class=\"hljs-built_in\">dijkstra</span>(&amp;adj, s - <span class=\"hljs-number\">1</span>, t - <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-keyword\">if</span> (dist == <span class=\"hljs-number\">-1</span>) {\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Target not reachable from source&quot;</span> &lt;&lt; std::endl;\n    } <span class=\"hljs-keyword\">else</span> {\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Shortest Path Distance : &quot;</span> &lt;&lt; dist &lt;&lt; std::endl;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "java": {
      "dir": "src/main/java/com/thealgorithms/others/Dijkstra.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src/main/java/com/thealgorithms/others/Dijkstra.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.others;\n\n<span class=\"hljs-comment\">/**\n * Dijkstra&#x27;s algorithm,is a graph search algorithm that solves the\n * single-source shortest path problem for a graph with nonnegative edge path\n * costs, producing a shortest path tree.\n *\n * &lt;p&gt;\n * <span class=\"hljs-doctag\">NOTE:</span> The inputs to Dijkstra&#x27;s algorithm are a directed and weighted graph\n * consisting of 2 or more nodes, generally represented by an adjacency matrix\n * or list, and a start node.\n *\n * &lt;p&gt;\n * Original source of code:\n * https://rosettacode.org/wiki/Dijkstra%27s_algorithm#Java Also most of the\n * comments are from RosettaCode.\n */</span>\n<span class=\"hljs-keyword\">import</span> java.util.*;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Dijkstra</span> {\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> Graph.Edge[] GRAPH = {\n        <span class=\"hljs-comment\">// Distance from node &quot;a&quot; to node &quot;b&quot; is 7.</span>\n        <span class=\"hljs-comment\">// In the current Graph there is no way to move the other way (e,g, from &quot;b&quot; to &quot;a&quot;),</span>\n        <span class=\"hljs-comment\">// a new edge would be needed for that</span>\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Graph</span>.Edge(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-number\">7</span>),\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Graph</span>.Edge(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-number\">9</span>),\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Graph</span>.Edge(<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;f&quot;</span>, <span class=\"hljs-number\">14</span>),\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Graph</span>.Edge(<span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-number\">10</span>),\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Graph</span>.Edge(<span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">15</span>),\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Graph</span>.Edge(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-number\">11</span>),\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Graph</span>.Edge(<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-string\">&quot;f&quot;</span>, <span class=\"hljs-number\">2</span>),\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Graph</span>.Edge(<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-string\">&quot;e&quot;</span>, <span class=\"hljs-number\">6</span>),\n        <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Graph</span>.Edge(<span class=\"hljs-string\">&quot;e&quot;</span>, <span class=\"hljs-string\">&quot;f&quot;</span>, <span class=\"hljs-number\">9</span>),};\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">START</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;a&quot;</span>;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">END</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-string\">&quot;e&quot;</span>;\n\n    <span class=\"hljs-comment\">/**\n     * main function Will run the code with &quot;GRAPH&quot; that was defined above.\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-type\">Graph</span> <span class=\"hljs-variable\">g</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Graph</span>(GRAPH);\n        g.dijkstra(START);\n        g.printPath(END);\n        <span class=\"hljs-comment\">// g.printAllPaths();</span>\n    }\n}\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span> {\n    <span class=\"hljs-comment\">// mapping of vertex names to Vertex objects, built from a set of Edges</span>\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> Map&lt;String, Vertex&gt; graph;\n\n    <span class=\"hljs-comment\">/**\n     * One edge of the graph (only used by Graph constructor)\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Edge</span> {\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> String v1, v2;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> dist;\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Edge</span><span class=\"hljs-params\">(String v1, String v2, <span class=\"hljs-type\">int</span> dist)</span> {\n            <span class=\"hljs-built_in\">this</span>.v1 = v1;\n            <span class=\"hljs-built_in\">this</span>.v2 = v2;\n            <span class=\"hljs-built_in\">this</span>.dist = dist;\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * One vertex of the graph, complete with mappings to neighbouring vertices\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Vertex</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title class_\">Comparable</span>&lt;Vertex&gt; {\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> String name;\n        <span class=\"hljs-comment\">// MAX_VALUE assumed to be infinity</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">dist</span> <span class=\"hljs-operator\">=</span> Integer.MAX_VALUE;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">Vertex</span> <span class=\"hljs-variable\">previous</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> Map&lt;Vertex, Integer&gt; neighbours = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Vertex</span><span class=\"hljs-params\">(String name)</span> {\n            <span class=\"hljs-built_in\">this</span>.name = name;\n        }\n\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printPath</span><span class=\"hljs-params\">()</span> {\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span> == <span class=\"hljs-built_in\">this</span>.previous) {\n                System.out.printf(<span class=\"hljs-string\">&quot;%s&quot;</span>, <span class=\"hljs-built_in\">this</span>.name);\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.previous == <span class=\"hljs-literal\">null</span>) {\n                System.out.printf(<span class=\"hljs-string\">&quot;%s(unreached)&quot;</span>, <span class=\"hljs-built_in\">this</span>.name);\n            } <span class=\"hljs-keyword\">else</span> {\n                <span class=\"hljs-built_in\">this</span>.previous.printPath();\n                System.out.printf(<span class=\"hljs-string\">&quot; -&gt; %s(%d)&quot;</span>, <span class=\"hljs-built_in\">this</span>.name, <span class=\"hljs-built_in\">this</span>.dist);\n            }\n        }\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">compareTo</span><span class=\"hljs-params\">(Vertex other)</span> {\n            <span class=\"hljs-keyword\">if</span> (dist == other.dist) {\n                <span class=\"hljs-keyword\">return</span> name.compareTo(other.name);\n            }\n\n            <span class=\"hljs-keyword\">return</span> Integer.compare(dist, other.dist);\n        }\n\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">equals</span><span class=\"hljs-params\">(Object object)</span> {\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span> == object) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n            }\n            <span class=\"hljs-keyword\">if</span> (object == <span class=\"hljs-literal\">null</span> || getClass() != object.getClass()) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n            }\n            <span class=\"hljs-keyword\">if</span> (!<span class=\"hljs-built_in\">super</span>.equals(object)) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n            }\n\n            <span class=\"hljs-type\">Vertex</span> <span class=\"hljs-variable\">vertex</span> <span class=\"hljs-operator\">=</span> (Vertex) object;\n\n            <span class=\"hljs-keyword\">if</span> (dist != vertex.dist) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n            }\n            <span class=\"hljs-keyword\">if</span> (name != <span class=\"hljs-literal\">null</span> ? !name.equals(vertex.name) : vertex.name != <span class=\"hljs-literal\">null</span>) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n            }\n            <span class=\"hljs-keyword\">if</span> (previous != <span class=\"hljs-literal\">null</span> ? !previous.equals(vertex.previous) : vertex.previous != <span class=\"hljs-literal\">null</span>) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n            }\n            <span class=\"hljs-keyword\">if</span> (neighbours != <span class=\"hljs-literal\">null</span> ? !neighbours.equals(vertex.neighbours) : vertex.neighbours != <span class=\"hljs-literal\">null</span>) {\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n            }\n\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n        }\n\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">hashCode</span><span class=\"hljs-params\">()</span> {\n            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">result</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">super</span>.hashCode();\n            result = <span class=\"hljs-number\">31</span> * result + (name != <span class=\"hljs-literal\">null</span> ? name.hashCode() : <span class=\"hljs-number\">0</span>);\n            result = <span class=\"hljs-number\">31</span> * result + dist;\n            result = <span class=\"hljs-number\">31</span> * result + (previous != <span class=\"hljs-literal\">null</span> ? previous.hashCode() : <span class=\"hljs-number\">0</span>);\n            result = <span class=\"hljs-number\">31</span> * result + (neighbours != <span class=\"hljs-literal\">null</span> ? neighbours.hashCode() : <span class=\"hljs-number\">0</span>);\n            <span class=\"hljs-keyword\">return</span> result;\n        }\n\n        <span class=\"hljs-meta\">@Override</span>\n        <span class=\"hljs-keyword\">public</span> String <span class=\"hljs-title function_\">toString</span><span class=\"hljs-params\">()</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">&quot;(&quot;</span> + name + <span class=\"hljs-string\">&quot;, &quot;</span> + dist + <span class=\"hljs-string\">&quot;)&quot;</span>;\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Builds a graph from a set of edges\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Graph</span><span class=\"hljs-params\">(Edge[] edges)</span> {\n        graph = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;(edges.length);\n\n        <span class=\"hljs-comment\">// one pass to find all vertices</span>\n        <span class=\"hljs-keyword\">for</span> (Edge e : edges) {\n            <span class=\"hljs-keyword\">if</span> (!graph.containsKey(e.v1)) {\n                graph.put(e.v1, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vertex</span>(e.v1));\n            }\n            <span class=\"hljs-keyword\">if</span> (!graph.containsKey(e.v2)) {\n                graph.put(e.v2, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vertex</span>(e.v2));\n            }\n        }\n\n        <span class=\"hljs-comment\">// another pass to set neighbouring vertices</span>\n        <span class=\"hljs-keyword\">for</span> (Edge e : edges) {\n            graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);\n            <span class=\"hljs-comment\">// graph.get(e.v2).neighbours.put(graph.get(e.v1), e.dist); // also do this for an undirected</span>\n            <span class=\"hljs-comment\">// graph</span>\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Runs dijkstra using a specified source vertex\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">dijkstra</span><span class=\"hljs-params\">(String startName)</span> {\n        <span class=\"hljs-keyword\">if</span> (!graph.containsKey(startName)) {\n            System.err.printf(<span class=\"hljs-string\">&quot;Graph doesn&#x27;t contain start vertex \\&quot;%s\\&quot;%n&quot;</span>, startName);\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">Vertex</span> <span class=\"hljs-variable\">source</span> <span class=\"hljs-operator\">=</span> graph.get(startName);\n        NavigableSet&lt;Vertex&gt; q = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">TreeSet</span>&lt;&gt;();\n\n        <span class=\"hljs-comment\">// set-up vertices</span>\n        <span class=\"hljs-keyword\">for</span> (Vertex v : graph.values()) {\n            v.previous = v == source ? source : <span class=\"hljs-literal\">null</span>;\n            v.dist = v == source ? <span class=\"hljs-number\">0</span> : Integer.MAX_VALUE;\n            q.add(v);\n        }\n\n        dijkstra(q);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Implementation of dijkstra&#x27;s algorithm using a binary heap.\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">dijkstra</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">final</span> NavigableSet&lt;Vertex&gt; q)</span> {\n        Vertex u, v;\n        <span class=\"hljs-keyword\">while</span> (!q.isEmpty()) {\n            <span class=\"hljs-comment\">// vertex with shortest distance (first iteration will return source)</span>\n            u = q.pollFirst();\n            <span class=\"hljs-keyword\">if</span> (u.dist == Integer.MAX_VALUE) {\n                <span class=\"hljs-keyword\">break</span>; <span class=\"hljs-comment\">// we can ignore u (and any other remaining vertices) since they are unreachable</span>\n            }\n            <span class=\"hljs-comment\">// look at distances to each neighbour</span>\n            <span class=\"hljs-keyword\">for</span> (Map.Entry&lt;Vertex, Integer&gt; a : u.neighbours.entrySet()) {\n                v = a.getKey(); <span class=\"hljs-comment\">// the neighbour in this iteration</span>\n\n                <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">alternateDist</span> <span class=\"hljs-operator\">=</span> u.dist + a.getValue();\n                <span class=\"hljs-keyword\">if</span> (alternateDist &lt; v.dist) { <span class=\"hljs-comment\">// shorter path to neighbour found</span>\n                    q.remove(v);\n                    v.dist = alternateDist;\n                    v.previous = u;\n                    q.add(v);\n                }\n            }\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Prints a path from the source to the specified vertex\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printPath</span><span class=\"hljs-params\">(String endName)</span> {\n        <span class=\"hljs-keyword\">if</span> (!graph.containsKey(endName)) {\n            System.err.printf(<span class=\"hljs-string\">&quot;Graph doesn&#x27;t contain end vertex \\&quot;%s\\&quot;%n&quot;</span>, endName);\n            <span class=\"hljs-keyword\">return</span>;\n        }\n\n        graph.get(endName).printPath();\n        System.out.println();\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Prints the path from the source to every vertex (output order is not\n     * guaranteed)\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printAllPaths</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">for</span> (Vertex v : graph.values()) {\n            v.printPath();\n            System.out.println();\n        }\n    }\n}\n"
    },
    "c": {
      "dir": "greedy_approach/dijkstra.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/greedy_approach/dijkstra.c",
      "code": "<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> MAX 20</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> INF 999</span>\n\n<span class=\"hljs-type\">int</span> mat[MAX][MAX];\n<span class=\"hljs-type\">int</span> V;\n\n<span class=\"hljs-type\">int</span> dist[MAX];\n\n<span class=\"hljs-type\">int</span> q[MAX];\n<span class=\"hljs-type\">int</span> qp = <span class=\"hljs-number\">0</span>;\n\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">enqueue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> v)</span> { q[qp++] = v; }\n\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">cf</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *a, <span class=\"hljs-type\">void</span> *b)</span>\n{\n    <span class=\"hljs-type\">int</span> *x = (<span class=\"hljs-type\">int</span> *)a;\n    <span class=\"hljs-type\">int</span> *y = (<span class=\"hljs-type\">int</span> *)b;\n    <span class=\"hljs-keyword\">return</span> *y - *x;\n}\n\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">dequeue</span><span class=\"hljs-params\">()</span>\n{\n    qsort(q, qp, <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>), cf);\n    <span class=\"hljs-keyword\">return</span> q[--qp];\n}\n\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">queue_has_something</span><span class=\"hljs-params\">()</span> { <span class=\"hljs-keyword\">return</span> (qp &gt; <span class=\"hljs-number\">0</span>); }\n\n<span class=\"hljs-type\">int</span> visited[MAX];\n<span class=\"hljs-type\">int</span> vp = <span class=\"hljs-number\">0</span>;\n\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">dijkstra</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> s)</span>\n{\n    dist[s] = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">int</span> i;\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; V; ++i)\n    {\n        <span class=\"hljs-keyword\">if</span> (i != s)\n        {\n            dist[i] = INF;\n        }\n        enqueue(i);\n    }\n    <span class=\"hljs-keyword\">while</span> (queue_has_something())\n    {\n        <span class=\"hljs-type\">int</span> u = dequeue();\n        visited[vp++] = u;\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; V; ++i)\n        {\n            <span class=\"hljs-keyword\">if</span> (mat[u][i])\n            {\n                <span class=\"hljs-keyword\">if</span> (dist[i] &gt; dist[u] + mat[u][i])\n                {\n                    dist[i] = dist[u] + mat[u][i];\n                }\n            }\n        }\n    }\n}\n\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> <span class=\"hljs-type\">const</span> *argv[])</span>\n{\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter the number of vertices: &quot;</span>);\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot; %d&quot;</span>, &amp;V);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter the adj matrix: &quot;</span>);\n    <span class=\"hljs-type\">int</span> i, j;\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; V; ++i)\n    {\n        <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; V; ++j)\n        {\n            <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot; %d&quot;</span>, &amp;mat[i][j]);\n        }\n    }\n\n    dijkstra(<span class=\"hljs-number\">0</span>);\n\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\nNode\\tDist\\n&quot;</span>);\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; V; ++i)\n    {\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d\\t%d\\n&quot;</span>, i, dist[i]);\n    }\n\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "go": {
      "dir": "graph/dijkstra.go",
      "url": "https://github.com/TheAlgorithms/go/tree/master/graph/dijkstra.go",
      "code": "<span class=\"hljs-keyword\">package</span> graph\n\n<span class=\"hljs-keyword\">import</span> <span class=\"hljs-string\">&quot;github.com/TheAlgorithms/Go/sort&quot;</span>\n\n<span class=\"hljs-keyword\">type</span> Item <span class=\"hljs-keyword\">struct</span> {\n\tnode <span class=\"hljs-type\">int</span>\n\tdist <span class=\"hljs-type\">int</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(a Item)</span></span> More(b any) <span class=\"hljs-type\">bool</span> {\n\t<span class=\"hljs-comment\">// reverse direction for minheap</span>\n\t<span class=\"hljs-keyword\">return</span> a.dist &lt; b.(Item).dist\n}\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(a Item)</span></span> Idx() <span class=\"hljs-type\">int</span> {\n\t<span class=\"hljs-keyword\">return</span> a.node\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(g *Graph)</span></span> Dijkstra(start, end <span class=\"hljs-type\">int</span>) (<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">bool</span>) {\n\tvisited := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]<span class=\"hljs-type\">bool</span>)\n\tnodes := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-type\">int</span>]*Item)\n\n\tnodes[start] = &amp;Item{\n\t\tdist: <span class=\"hljs-number\">0</span>,\n\t\tnode: start,\n\t}\n\tpq := sort.MaxHeap{}\n\tpq.Init(<span class=\"hljs-literal\">nil</span>)\n\tpq.Push(*nodes[start])\n\n\tvisit := <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(curr Item)</span></span> {\n\t\tvisited[curr.node] = <span class=\"hljs-literal\">true</span>\n\t\t<span class=\"hljs-keyword\">for</span> n, d := <span class=\"hljs-keyword\">range</span> g.edges[curr.node] {\n\t\t\t<span class=\"hljs-keyword\">if</span> visited[n] {\n\t\t\t\t<span class=\"hljs-keyword\">continue</span>\n\t\t\t}\n\n\t\t\titem := nodes[n]\n\t\t\tdist2 := curr.dist + d\n\t\t\t<span class=\"hljs-keyword\">if</span> item == <span class=\"hljs-literal\">nil</span> {\n\t\t\t\tnodes[n] = &amp;Item{node: n, dist: dist2}\n\t\t\t\tpq.Push(*nodes[n])\n\t\t\t} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> item.dist &gt; dist2 {\n\t\t\t\titem.dist = dist2\n\t\t\t\tpq.Update(*item)\n\t\t\t}\n\t\t}\n\t}\n\n\t<span class=\"hljs-keyword\">for</span> pq.Size() &gt; <span class=\"hljs-number\">0</span> {\n\t\tcurr := pq.Pop().(Item)\n\t\t<span class=\"hljs-keyword\">if</span> curr.node == end {\n\t\t\t<span class=\"hljs-keyword\">break</span>\n\t\t}\n\t\tvisit(curr)\n\t}\n\n\titem := nodes[end]\n\t<span class=\"hljs-keyword\">if</span> item == <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>, <span class=\"hljs-literal\">false</span>\n\t}\n\t<span class=\"hljs-keyword\">return</span> item.dist, <span class=\"hljs-literal\">true</span>\n}\n"
    },
    "rust": {
      "dir": "src/graph/dijkstra.rs",
      "url": "https://github.com/TheAlgorithms/rust/tree/master/src/graph/dijkstra.rs",
      "code": "<span class=\"hljs-keyword\">use</span> std::cmp::Reverse;\n<span class=\"hljs-keyword\">use</span> std::collections::{BTreeMap, BinaryHeap};\n<span class=\"hljs-keyword\">use</span> std::ops::Add;\n\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Graph</span>&lt;V, E&gt; = BTreeMap&lt;V, BTreeMap&lt;V, E&gt;&gt;;\n\n<span class=\"hljs-comment\">// performs Dijsktra&#x27;s algorithm on the given graph from the given start</span>\n<span class=\"hljs-comment\">// the graph is a positively-weighted undirected graph</span>\n<span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">// returns a map that for each reachable vertex associates the distance and the predecessor</span>\n<span class=\"hljs-comment\">// since the start has no predecessor but is reachable, map[start] will be None</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">dijkstra</span>&lt;V: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span>, E: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span> + Add&lt;Output = E&gt;&gt;(\n    graph: &amp;Graph&lt;V, E&gt;,\n    start: &amp;V,\n) <span class=\"hljs-punctuation\">-&gt;</span> BTreeMap&lt;V, <span class=\"hljs-type\">Option</span>&lt;(V, E)&gt;&gt; {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">ans</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">prio</span> = BinaryHeap::<span class=\"hljs-title function_ invoke__\">new</span>();\n\n    <span class=\"hljs-comment\">// start is the special case that doesn&#x27;t have a predecessor</span>\n    ans.<span class=\"hljs-title function_ invoke__\">insert</span>(*start, <span class=\"hljs-literal\">None</span>);\n\n    <span class=\"hljs-title function_ invoke__\">for</span> (new, weight) <span class=\"hljs-keyword\">in</span> &amp;graph[start] {\n        ans.<span class=\"hljs-title function_ invoke__\">insert</span>(*new, <span class=\"hljs-title function_ invoke__\">Some</span>((*start, *weight)));\n        prio.<span class=\"hljs-title function_ invoke__\">push</span>(<span class=\"hljs-title function_ invoke__\">Reverse</span>((*weight, new, start)));\n    }\n\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">Some</span>(<span class=\"hljs-title function_ invoke__\">Reverse</span>((dist_new, new, prev))) = prio.<span class=\"hljs-title function_ invoke__\">pop</span>() {\n        <span class=\"hljs-keyword\">match</span> ans[new] {\n            <span class=\"hljs-comment\">// what we popped is what is in ans, we&#x27;ll compute it</span>\n            <span class=\"hljs-title function_ invoke__\">Some</span>((p, d)) <span class=\"hljs-keyword\">if</span> p == *prev &amp;&amp; d == dist_new =&gt; {}\n            <span class=\"hljs-comment\">// otherwise it&#x27;s not interesting</span>\n            _ =&gt; <span class=\"hljs-keyword\">continue</span>,\n        }\n\n        <span class=\"hljs-title function_ invoke__\">for</span> (next, weight) <span class=\"hljs-keyword\">in</span> &amp;graph[new] {\n            <span class=\"hljs-keyword\">match</span> ans.<span class=\"hljs-title function_ invoke__\">get</span>(next) {\n                <span class=\"hljs-comment\">// if ans[next] is a lower dist than the alternative one, we do nothing</span>\n                <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-title function_ invoke__\">Some</span>((_, dist_next))) <span class=\"hljs-keyword\">if</span> dist_new + *weight &gt;= *dist_next =&gt; {}\n                <span class=\"hljs-comment\">// if ans[next] is None then next is start and so the distance won&#x27;t be changed, it won&#x27;t be added again in prio</span>\n                <span class=\"hljs-title function_ invoke__\">Some</span>(<span class=\"hljs-literal\">None</span>) =&gt; {}\n                <span class=\"hljs-comment\">// the new path is shorter, either new was not in ans or it was farther</span>\n                _ =&gt; {\n                    ans.<span class=\"hljs-title function_ invoke__\">insert</span>(*next, <span class=\"hljs-title function_ invoke__\">Some</span>((*new, *weight + dist_new)));\n                    prio.<span class=\"hljs-title function_ invoke__\">push</span>(<span class=\"hljs-title function_ invoke__\">Reverse</span>((*weight + dist_new, next, new)));\n                }\n            }\n        }\n    }\n\n    ans\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::{dijkstra, Graph};\n    <span class=\"hljs-keyword\">use</span> std::collections::BTreeMap;\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">add_edge</span>&lt;V: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span>, E: <span class=\"hljs-built_in\">Ord</span>&gt;(graph: &amp;<span class=\"hljs-keyword\">mut</span> Graph&lt;V, E&gt;, v1: V, v2: V, c: E) {\n        graph.<span class=\"hljs-title function_ invoke__\">entry</span>(v1).<span class=\"hljs-title function_ invoke__\">or_insert_with</span>(BTreeMap::new).<span class=\"hljs-title function_ invoke__\">insert</span>(v2, c);\n        graph.<span class=\"hljs-title function_ invoke__\">entry</span>(v2).<span class=\"hljs-title function_ invoke__\">or_insert_with</span>(BTreeMap::new);\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">single_vertex</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span>: Graph&lt;<span class=\"hljs-type\">usize</span>, <span class=\"hljs-type\">usize</span>&gt; = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        graph.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>());\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">None</span>);\n\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">dijkstra</span>(&amp;graph, &amp;<span class=\"hljs-number\">0</span>), dists);\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">single_edge</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>);\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_0</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_0.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-literal\">None</span>);\n        dists_0.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>)));\n\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">dijkstra</span>(&amp;graph, &amp;<span class=\"hljs-number\">0</span>), dists_0);\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_1</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_1.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">None</span>);\n\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">dijkstra</span>(&amp;graph, &amp;<span class=\"hljs-number\">1</span>), dists_1);\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">tree_1</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">None</span>);\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..<span class=\"hljs-number\">100</span> {\n            <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, i, i * <span class=\"hljs-number\">2</span>, i * <span class=\"hljs-number\">2</span>);\n            <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, i, i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>, i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>);\n\n            <span class=\"hljs-keyword\">match</span> dists[&amp;i] {\n                <span class=\"hljs-title function_ invoke__\">Some</span>((_, d)) =&gt; {\n                    dists.<span class=\"hljs-title function_ invoke__\">insert</span>(i * <span class=\"hljs-number\">2</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((i, d + i * <span class=\"hljs-number\">2</span>)));\n                    dists.<span class=\"hljs-title function_ invoke__\">insert</span>(i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((i, d + i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>)));\n                }\n                <span class=\"hljs-literal\">None</span> =&gt; {\n                    dists.<span class=\"hljs-title function_ invoke__\">insert</span>(i * <span class=\"hljs-number\">2</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((i, i * <span class=\"hljs-number\">2</span>)));\n                    dists.<span class=\"hljs-title function_ invoke__\">insert</span>(i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((i, i * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>)));\n                }\n            }\n        }\n\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">dijkstra</span>(&amp;graph, &amp;<span class=\"hljs-number\">1</span>), dists);\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">graph_1</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">12</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-number\">60</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">10</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">20</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-number\">32</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">7</span>);\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_a</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_a.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-literal\">None</span>);\n        dists_a.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">12</span>)));\n        dists_a.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">44</span>)));\n        dists_a.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">32</span>)));\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">dijkstra</span>(&amp;graph, &amp;<span class=\"hljs-string\">&#x27;a&#x27;</span>), dists_a);\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_b</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_b.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-literal\">None</span>);\n        dists_b.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">10</span>)));\n        dists_b.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">22</span>)));\n        dists_b.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">54</span>)));\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">dijkstra</span>(&amp;graph, &amp;<span class=\"hljs-string\">&#x27;b&#x27;</span>), dists_b);\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_c</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_c.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-literal\">None</span>);\n        dists_c.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">20</span>)));\n        dists_c.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">32</span>)));\n        dists_c.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-number\">30</span>)));\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">dijkstra</span>(&amp;graph, &amp;<span class=\"hljs-string\">&#x27;c&#x27;</span>), dists_c);\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_d</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_d.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-literal\">None</span>);\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">dijkstra</span>(&amp;graph, &amp;<span class=\"hljs-string\">&#x27;d&#x27;</span>), dists_d);\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">dists_e</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        dists_e.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-literal\">None</span>);\n        dists_e.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;e&#x27;</span>, <span class=\"hljs-number\">7</span>)));\n        dists_e.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;a&#x27;</span>, <span class=\"hljs-number\">19</span>)));\n        dists_e.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;d&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">51</span>)));\n        dists_e.<span class=\"hljs-title function_ invoke__\">insert</span>(<span class=\"hljs-string\">&#x27;b&#x27;</span>, <span class=\"hljs-title function_ invoke__\">Some</span>((<span class=\"hljs-string\">&#x27;c&#x27;</span>, <span class=\"hljs-number\">39</span>)));\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">dijkstra</span>(&amp;graph, &amp;<span class=\"hljs-string\">&#x27;e&#x27;</span>), dists_e);\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Pierre Gimalac",
      "email": "pierre.gimalac@gmail.com",
      "commits": 1
    },
    {
      "name": "Ritik Bhandari",
      "email": "ritikbhandari68@gmail.com",
      "commits": 1
    },
    {
      "name": "Metta Ong",
      "email": "ongspxm@gmail.com",
      "commits": 1
    },
    {
      "name": "Idan BananI",
      "email": "idanb121@gmail.com",
      "commits": 1
    },
    {
      "name": "Eric Lavault",
      "email": "39483232+lvlte@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Keshav Bohra",
      "email": "keshav2016@gmail.com",
      "commits": 1
    },
    {
      "name": "ParthS007",
      "email": "parth1989shandilya@gmail.com",
      "commits": 1
    },
    {
      "name": "Aitor Fidalgo Sánchez",
      "email": "64830228+aitorfi@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Maria Lungeanu",
      "email": "Maria.Lungeanu@anritsu.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Bruno Simas Hadlich",
      "email": "brunosimashadlich@gmail.com",
      "commits": 1
    },
    {
      "name": "zachzhu2016",
      "email": "48337051+zachzhu2016@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Reshad Hasan",
      "email": "reshadhasan555@gmail.com",
      "commits": 1
    },
    {
      "name": "Rafael García Cuéllar",
      "email": "r.gc@hotmail.es",
      "commits": 1
    },
    {
      "name": "cclauss",
      "email": "cclauss@bluewin.ch",
      "commits": 1
    },
    {
      "name": "ashu01",
      "email": "as01hu@gmail.com",
      "commits": 1
    },
    {
      "name": "AlexDvorak",
      "email": "opti.jawsome@gmail.com",
      "commits": 2
    },
    {
      "name": "Christian Bender",
      "email": "christianbender89@web.de",
      "commits": 2
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 2
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 3
    },
    {
      "name": "Nidheesh Pandey",
      "email": "nidheeshpandey@gmail.com",
      "commits": 3
    },
    {
      "name": "rmakynen",
      "email": "rmakynen@Mikrohalli-pc43.student.yo.oulu.fi",
      "commits": 3
    },
    {
      "name": "ayaankhan98",
      "email": "ayaankhan98@gmail.com",
      "commits": 4
    },
    {
      "name": "rmakynen",
      "email": "43169683+rmakynen@users.noreply.github.com",
      "commits": 4
    },
    {
      "name": "Libin Yang",
      "email": "szuyanglb@outlook.com",
      "commits": 5
    },
    {
      "name": "arpanjain97",
      "email": "arpanjain97@gmail.com",
      "commits": 5
    }
  ],
  "explanationUrl": {}
}