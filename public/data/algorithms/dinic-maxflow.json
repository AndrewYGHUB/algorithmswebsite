{
  "slug": "dinic-maxflow",
  "name": "Dinic Maxflow",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "rust": {
      "dir": "src/graph/dinic_maxflow.rs",
      "url": "https://github.com/TheAlgorithms/rust/tree/master/src/graph/dinic_maxflow.rs",
      "code": "<span class=\"hljs-keyword\">use</span> std::collections::VecDeque;\n<span class=\"hljs-keyword\">use</span> std::ops::{Add, AddAssign, Neg, Sub, SubAssign};\n\n<span class=\"hljs-comment\">// We assume that graph vertices are numbered from 1 to n.</span>\n\n<span class=\"hljs-comment\">/// Adjacency matrix</span>\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Graph</span> = <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">usize</span>&gt;&gt;;\n\n<span class=\"hljs-comment\">/// We assume that T::default() gives &quot;zero&quot; flow and T supports negative values</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">FlowEdge</span>&lt;T&gt; {\n    <span class=\"hljs-keyword\">pub</span> sink: <span class=\"hljs-type\">usize</span>,\n    <span class=\"hljs-keyword\">pub</span> capacity: T,\n    <span class=\"hljs-keyword\">pub</span> flow: T,\n}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">FlowResultEdge</span>&lt;T&gt; {\n    <span class=\"hljs-keyword\">pub</span> source: <span class=\"hljs-type\">usize</span>,\n    <span class=\"hljs-keyword\">pub</span> sink: <span class=\"hljs-type\">usize</span>,\n    <span class=\"hljs-keyword\">pub</span> flow: T,\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T: <span class=\"hljs-built_in\">Clone</span> + <span class=\"hljs-built_in\">Copy</span> + Add + AddAssign + Sub&lt;Output = T&gt; + SubAssign + <span class=\"hljs-built_in\">Ord</span> + Neg + <span class=\"hljs-built_in\">Default</span>&gt;\n    FlowEdge&lt;T&gt;\n{\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">new</span>(sink: <span class=\"hljs-type\">usize</span>, capacity: T) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\n        FlowEdge {\n            sink,\n            capacity,\n            flow: T::<span class=\"hljs-title function_ invoke__\">default</span>(),\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DinicMaxFlow</span>&lt;T&gt; {\n    <span class=\"hljs-comment\">/// BFS Level of each vertex. starts from 1</span>\n    level: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">usize</span>&gt;,\n\n    <span class=\"hljs-comment\">/// The index of the last visited edge connected to each vertex</span>\n    <span class=\"hljs-keyword\">pub</span> last_edge: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">usize</span>&gt;,\n\n    <span class=\"hljs-comment\">/// Holds wether the solution has already been calculated</span>\n    network_solved: <span class=\"hljs-type\">bool</span>,\n\n    <span class=\"hljs-keyword\">pub</span> source: <span class=\"hljs-type\">usize</span>,\n    <span class=\"hljs-keyword\">pub</span> sink: <span class=\"hljs-type\">usize</span>,\n\n    <span class=\"hljs-comment\">/// Number of edges added to the residual network</span>\n    <span class=\"hljs-keyword\">pub</span> num_edges: <span class=\"hljs-type\">usize</span>,\n    <span class=\"hljs-keyword\">pub</span> num_vertices: <span class=\"hljs-type\">usize</span>,\n\n    <span class=\"hljs-keyword\">pub</span> adj: Graph,\n\n    <span class=\"hljs-comment\">/// The list of flow edges</span>\n    <span class=\"hljs-keyword\">pub</span> edges: <span class=\"hljs-type\">Vec</span>&lt;FlowEdge&lt;T&gt;&gt;,\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T: <span class=\"hljs-built_in\">Clone</span> + <span class=\"hljs-built_in\">Copy</span> + Add + AddAssign + Sub&lt;Output = T&gt; + SubAssign + Neg + <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Default</span>&gt;\n    DinicMaxFlow&lt;T&gt;\n{\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">new</span>(source: <span class=\"hljs-type\">usize</span>, sink: <span class=\"hljs-type\">usize</span>, num_vertices: <span class=\"hljs-type\">usize</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\n        DinicMaxFlow {\n            level: <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>; num_vertices + <span class=\"hljs-number\">1</span>],\n            last_edge: <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>; num_vertices + <span class=\"hljs-number\">1</span>],\n            network_solved: <span class=\"hljs-literal\">false</span>,\n            source,\n            sink,\n            num_edges: <span class=\"hljs-number\">0</span>,\n            num_vertices,\n            adj: <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-built_in\">vec!</span>[]; num_vertices + <span class=\"hljs-number\">1</span>],\n            edges: <span class=\"hljs-built_in\">vec!</span>[],\n        }\n    }\n    <span class=\"hljs-meta\">#[inline]</span>\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, source: <span class=\"hljs-type\">usize</span>, sink: <span class=\"hljs-type\">usize</span>, capacity: T) {\n        <span class=\"hljs-keyword\">self</span>.edges.<span class=\"hljs-title function_ invoke__\">push</span>(FlowEdge::<span class=\"hljs-title function_ invoke__\">new</span>(sink, capacity));\n        <span class=\"hljs-comment\">// Add the reverse edge with zero capacity</span>\n        <span class=\"hljs-keyword\">self</span>.edges.<span class=\"hljs-title function_ invoke__\">push</span>(FlowEdge::<span class=\"hljs-title function_ invoke__\">new</span>(source, T::<span class=\"hljs-title function_ invoke__\">default</span>()));\n        <span class=\"hljs-comment\">// We inserted the m&#x27;th edge from source to sink</span>\n        <span class=\"hljs-keyword\">self</span>.adj[source].<span class=\"hljs-title function_ invoke__\">push</span>(<span class=\"hljs-keyword\">self</span>.num_edges);\n        <span class=\"hljs-keyword\">self</span>.adj[sink].<span class=\"hljs-title function_ invoke__\">push</span>(<span class=\"hljs-keyword\">self</span>.num_edges + <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-keyword\">self</span>.num_edges += <span class=\"hljs-number\">2</span>;\n    }\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">bfs</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">bool</span> {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">q</span>: VecDeque&lt;<span class=\"hljs-type\">usize</span>&gt; = VecDeque::<span class=\"hljs-title function_ invoke__\">new</span>();\n        q.<span class=\"hljs-title function_ invoke__\">push_back</span>(<span class=\"hljs-keyword\">self</span>.source);\n\n        <span class=\"hljs-keyword\">while</span> !q.<span class=\"hljs-title function_ invoke__\">is_empty</span>() {\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">v</span> = q.<span class=\"hljs-title function_ invoke__\">pop_front</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n            <span class=\"hljs-keyword\">for</span> &amp;e <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">self</span>.adj[v].<span class=\"hljs-title function_ invoke__\">iter</span>() {\n                <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.edges[e].capacity &lt;= <span class=\"hljs-keyword\">self</span>.edges[e].flow {\n                    <span class=\"hljs-keyword\">continue</span>;\n                }\n                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">u</span> = <span class=\"hljs-keyword\">self</span>.edges[e].sink;\n                <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.level[u] != <span class=\"hljs-number\">0</span> {\n                    <span class=\"hljs-keyword\">continue</span>;\n                }\n                <span class=\"hljs-keyword\">self</span>.level[u] = <span class=\"hljs-keyword\">self</span>.level[v] + <span class=\"hljs-number\">1</span>;\n                q.<span class=\"hljs-title function_ invoke__\">push_back</span>(u);\n            }\n        }\n\n        <span class=\"hljs-keyword\">self</span>.level[<span class=\"hljs-keyword\">self</span>.sink] != <span class=\"hljs-number\">0</span>\n    }\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">dfs</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, v: <span class=\"hljs-type\">usize</span>, pushed: T) <span class=\"hljs-punctuation\">-&gt;</span> T {\n        <span class=\"hljs-comment\">// We have pushed nothing, or we are at the sink</span>\n        <span class=\"hljs-keyword\">if</span> v == <span class=\"hljs-keyword\">self</span>.sink {\n            <span class=\"hljs-keyword\">return</span> pushed;\n        }\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">e_pos</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">self</span>.last_edge[v]..<span class=\"hljs-keyword\">self</span>.adj[v].<span class=\"hljs-title function_ invoke__\">len</span>() {\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">e</span> = <span class=\"hljs-keyword\">self</span>.adj[v][e_pos];\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">u</span> = <span class=\"hljs-keyword\">self</span>.edges[e].sink;\n            <span class=\"hljs-title function_ invoke__\">if</span> (<span class=\"hljs-keyword\">self</span>.level[v] + <span class=\"hljs-number\">1</span>) != <span class=\"hljs-keyword\">self</span>.level[u] || <span class=\"hljs-keyword\">self</span>.edges[e].capacity &lt;= <span class=\"hljs-keyword\">self</span>.edges[e].flow\n            {\n                <span class=\"hljs-keyword\">continue</span>;\n            }\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">down_flow</span> = <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">dfs</span>(\n                u,\n                std::cmp::<span class=\"hljs-title function_ invoke__\">min</span>(pushed, <span class=\"hljs-keyword\">self</span>.edges[e].capacity - <span class=\"hljs-keyword\">self</span>.edges[e].flow),\n            );\n            <span class=\"hljs-keyword\">if</span> down_flow == T::<span class=\"hljs-title function_ invoke__\">default</span>() {\n                <span class=\"hljs-keyword\">continue</span>;\n            }\n            <span class=\"hljs-keyword\">self</span>.last_edge[v] = e_pos;\n            <span class=\"hljs-keyword\">self</span>.edges[e].flow += down_flow;\n            <span class=\"hljs-keyword\">self</span>.edges[e ^ <span class=\"hljs-number\">1</span>].flow -= down_flow;\n            <span class=\"hljs-keyword\">return</span> down_flow;\n        }\n        <span class=\"hljs-keyword\">self</span>.last_edge[v] = <span class=\"hljs-keyword\">self</span>.adj[v].<span class=\"hljs-title function_ invoke__\">len</span>();\n        T::<span class=\"hljs-title function_ invoke__\">default</span>()\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">find_maxflow</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, infinite_flow: T) <span class=\"hljs-punctuation\">-&gt;</span> T {\n        <span class=\"hljs-keyword\">self</span>.network_solved = <span class=\"hljs-literal\">true</span>;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">total_flow</span>: T = T::<span class=\"hljs-title function_ invoke__\">default</span>();\n        <span class=\"hljs-keyword\">loop</span> {\n            <span class=\"hljs-keyword\">self</span>.level.<span class=\"hljs-title function_ invoke__\">fill</span>(<span class=\"hljs-number\">0</span>);\n            <span class=\"hljs-keyword\">self</span>.level[<span class=\"hljs-keyword\">self</span>.source] = <span class=\"hljs-number\">1</span>;\n            <span class=\"hljs-comment\">// There is no longer a path from source to sink in the residual</span>\n            <span class=\"hljs-comment\">// network</span>\n            <span class=\"hljs-keyword\">if</span> !<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">bfs</span>() {\n                <span class=\"hljs-keyword\">break</span>;\n            }\n            <span class=\"hljs-keyword\">self</span>.last_edge.<span class=\"hljs-title function_ invoke__\">fill</span>(<span class=\"hljs-number\">0</span>);\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">next_flow</span> = <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">dfs</span>(<span class=\"hljs-keyword\">self</span>.source, infinite_flow);\n            <span class=\"hljs-keyword\">while</span> next_flow != T::<span class=\"hljs-title function_ invoke__\">default</span>() {\n                total_flow += next_flow;\n                next_flow = <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">dfs</span>(<span class=\"hljs-keyword\">self</span>.source, infinite_flow);\n            }\n        }\n        total_flow\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">get_flow_edges</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, infinite_flow: T) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Vec</span>&lt;FlowResultEdge&lt;T&gt;&gt; {\n        <span class=\"hljs-keyword\">if</span> !<span class=\"hljs-keyword\">self</span>.network_solved {\n            <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">find_maxflow</span>(infinite_flow);\n        }\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">result</span> = Vec::<span class=\"hljs-title function_ invoke__\">new</span>();\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">v</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..<span class=\"hljs-keyword\">self</span>.adj.<span class=\"hljs-title function_ invoke__\">len</span>() {\n            <span class=\"hljs-keyword\">for</span> &amp;e_ind <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">self</span>.adj[v].<span class=\"hljs-title function_ invoke__\">iter</span>() {\n                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">e</span> = &amp;<span class=\"hljs-keyword\">self</span>.edges[e_ind];\n                <span class=\"hljs-comment\">// Make sure that reverse edges from residual network are not</span>\n                <span class=\"hljs-comment\">// included</span>\n                <span class=\"hljs-keyword\">if</span> e.flow &gt; T::<span class=\"hljs-title function_ invoke__\">default</span>() {\n                    result.<span class=\"hljs-title function_ invoke__\">push</span>(FlowResultEdge {\n                        source: v,\n                        sink: e.sink,\n                        flow: e.flow,\n                    });\n                }\n            }\n        }\n        result\n    }\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::*;\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">small_graph</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">flow</span>: DinicMaxFlow&lt;<span class=\"hljs-type\">i32</span>&gt; = DinicMaxFlow::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">6</span>);\n        flow.<span class=\"hljs-title function_ invoke__\">add_edge</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">16</span>);\n        flow.<span class=\"hljs-title function_ invoke__\">add_edge</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">13</span>);\n        flow.<span class=\"hljs-title function_ invoke__\">add_edge</span>(<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">12</span>);\n        flow.<span class=\"hljs-title function_ invoke__\">add_edge</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">9</span>);\n        flow.<span class=\"hljs-title function_ invoke__\">add_edge</span>(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">20</span>);\n        flow.<span class=\"hljs-title function_ invoke__\">add_edge</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>);\n        flow.<span class=\"hljs-title function_ invoke__\">add_edge</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">14</span>);\n        flow.<span class=\"hljs-title function_ invoke__\">add_edge</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>);\n        flow.<span class=\"hljs-title function_ invoke__\">add_edge</span>(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">4</span>);\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">max_flow</span> = flow.<span class=\"hljs-title function_ invoke__\">find_maxflow</span>(i32::MAX);\n        <span class=\"hljs-built_in\">assert_eq!</span>(max_flow, <span class=\"hljs-number\">23</span>);\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">sm_out</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>; <span class=\"hljs-number\">7</span>];\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">sm_in</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>; <span class=\"hljs-number\">7</span>];\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">flow_edges</span> = flow.<span class=\"hljs-title function_ invoke__\">get_flow_edges</span>(i32::MAX);\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">e</span> <span class=\"hljs-keyword\">in</span> flow_edges {\n            sm_out[e.source] += e.flow;\n            sm_in[e.sink] += e.flow;\n        }\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">2</span>..=<span class=\"hljs-number\">5</span> {\n            <span class=\"hljs-built_in\">assert_eq!</span>(sm_in[i], sm_out[i]);\n        }\n        <span class=\"hljs-built_in\">assert_eq!</span>(sm_in[<span class=\"hljs-number\">1</span>], <span class=\"hljs-number\">0</span>);\n        <span class=\"hljs-built_in\">assert_eq!</span>(sm_out[<span class=\"hljs-number\">1</span>], max_flow);\n        <span class=\"hljs-built_in\">assert_eq!</span>(sm_in[<span class=\"hljs-number\">6</span>], max_flow);\n        <span class=\"hljs-built_in\">assert_eq!</span>(sm_out[<span class=\"hljs-number\">6</span>], <span class=\"hljs-number\">0</span>);\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Erfan Khadem",
      "email": "45465346+er888kh@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}