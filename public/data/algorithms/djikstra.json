{
  "slug": "djikstra",
  "name": "Djikstra",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "julia": {
      "dir": "src/graph/djikstra.jl",
      "url": "https://github.com/TheAlgorithms/julia/tree/master/src/graph/djikstra.jl",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;\n    dijkstra(graph::Vector{Vector{Tuple{Int,Int}}}, source::Int)\n\nGiven a directed graph with weights on the arcs and a source vertex, the dijkstra algorithm\ncalculates the distance from the source to all other vertices, and the solution tree associated\nwith those distances. The solution tree is given by a vector `prev` which stores the source of the\narc that arrives at each vertex. By definition: distance[source] = prev[source] = 0. If a vertex v\nis not reachable from the source, then distance[v] = prev[v] = -1.\n\n# Arguments:\n- `graph`: a directed graph with weights on the arcs\n- `source`: the source vertex from which the distances will be calculated\n\n# Example\n```jldoctest\ngraph = [\n    [(2, 8), (3, 6), (4, 4)],\n    [(3, 1), (5, 5)],\n    [(5, 4)],\n    [(2, 3), (5, 9)],\n    [(1, 2), (3, 2), (4, 5)],\n    [(1, 1), (4, 3)],\n]\ndistances, prev = dijkstra(graph, 1)\n\nprintln(&quot;v | dist | path&quot;)\nfor v in eachindex(graph)\n    distance = distances[v] == -1 ? &quot;  NR&quot; : lpad(distances[v], 4) # NR: Non Reachable\n    path = join(get_dijkstra_path(prev, v), &quot; -&gt; &quot;)\n    println(&quot;\\$v | \\$distance | \\$path&quot;)\nend\n\n# output\n\nv | dist | path\n1 |    0 | 1\n2 |    7 | 1 -&gt; 4 -&gt; 2\n3 |    6 | 1 -&gt; 3\n4 |    4 | 1 -&gt; 4\n5 |   10 | 1 -&gt; 3 -&gt; 5\n6 |   NR | \n```\n\nContributed By: [Gabriel Soares](https://github.com/gosoares)\n&quot;&quot;&quot;</span>\n<span class=\"hljs-keyword\">function</span> dijkstra(graph::<span class=\"hljs-built_in\">Vector</span>{<span class=\"hljs-built_in\">Vector</span>{<span class=\"hljs-built_in\">Tuple</span>{<span class=\"hljs-built_in\">Int</span>,<span class=\"hljs-built_in\">Int</span>}}}, source::<span class=\"hljs-built_in\">Int</span>)\n    <span class=\"hljs-comment\"># V = {1, 2, ..., length(graph)}: set of vertices</span>\n    <span class=\"hljs-comment\"># A = {(i, j): i and j are adjacents; i,j in V}: set of arcs</span>\n    <span class=\"hljs-comment\"># graph[i] = {(j, distance[i to j]): (i, j) in A}: adjacency list</span>\n\n    <span class=\"hljs-comment\"># distance[j] min distance from source to j</span>\n    distance::<span class=\"hljs-built_in\">Vector</span>{<span class=\"hljs-built_in\">Int</span>} = fill(typemax(<span class=\"hljs-built_in\">Int</span>), length(graph))\n    prev::<span class=\"hljs-built_in\">Vector</span>{<span class=\"hljs-built_in\">Int</span>} = fill(-<span class=\"hljs-number\">1</span>, length(graph))\n    visited::<span class=\"hljs-built_in\">Vector</span>{<span class=\"hljs-built_in\">Bool</span>} = falses(length(graph))\n    pq = MinHeap{<span class=\"hljs-built_in\">Tuple</span>{<span class=\"hljs-built_in\">Int</span>,<span class=\"hljs-built_in\">Int</span>}}() <span class=\"hljs-comment\"># (distance, vertex) | priority queue</span>\n\n    distance[source] = <span class=\"hljs-number\">0</span>\n    prev[source] = <span class=\"hljs-number\">0</span> <span class=\"hljs-comment\"># to mark the source</span>\n    push!(pq, (<span class=\"hljs-number\">0</span>, source))\n\n    <span class=\"hljs-keyword\">while</span> !isempty(pq)\n        <span class=\"hljs-comment\"># get the vertex that was not yet visited and the distance from the source is minimal</span>\n        dv, v = pop!(pq)\n        visited[v] &amp;&amp; <span class=\"hljs-keyword\">continue</span>\n        visited[v] = <span class=\"hljs-literal\">true</span>\n\n        <span class=\"hljs-keyword\">for</span> (u, dvu) <span class=\"hljs-keyword\">in</span> graph[v] <span class=\"hljs-comment\"># dvu: distance from v to u</span>\n            <span class=\"hljs-comment\"># check if u can be reached through v with a smaller distance than the current</span>\n            <span class=\"hljs-keyword\">if</span> !visited[u] &amp;&amp; dv + dvu &lt; distance[u]\n                distance[u] = dv + dvu\n                prev[u] = v\n                push!(pq, (distance[u], u))\n            <span class=\"hljs-keyword\">end</span>\n        <span class=\"hljs-keyword\">end</span>\n    <span class=\"hljs-keyword\">end</span>\n\n    replace!(distance, typemax(<span class=\"hljs-built_in\">Int</span>) =&gt; -<span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\"># distance[v] = -1 means that v is not reachable from source</span>\n    <span class=\"hljs-keyword\">return</span> distance, prev\n<span class=\"hljs-keyword\">end</span>\n\n<span class=\"hljs-string\">&quot;&quot;&quot;\n    get_dijkstra_path(tree::Vector{Int}, dest::Int)\n\nGiven a solution `tree` from the [`dijkstra`](@ref) algorithm, extract the path from the source to\n`dest`, including them.\n\n# Arguments:\n- `tree`: solution tree from the [`dijkstra`](@ref) algorithm\n- `dest`: path&#x27;s destionation vertex\n&quot;&quot;&quot;</span>\n<span class=\"hljs-keyword\">function</span> get_dijkstra_path(tree::<span class=\"hljs-built_in\">Vector</span>{<span class=\"hljs-built_in\">Int</span>}, dest::<span class=\"hljs-built_in\">Int</span>)\n    path = <span class=\"hljs-built_in\">Int</span>[]\n    tree[dest] == -<span class=\"hljs-number\">1</span> &amp;&amp; <span class=\"hljs-keyword\">return</span> path <span class=\"hljs-comment\"># not reachable</span>\n\n    <span class=\"hljs-keyword\">while</span> dest != <span class=\"hljs-number\">0</span>\n        push!(path, dest)\n        dest = tree[dest]\n    <span class=\"hljs-keyword\">end</span>\n    <span class=\"hljs-keyword\">return</span> reverse!(path)\n<span class=\"hljs-keyword\">end</span>\n"
    }
  },
  "contributors": [
    {
      "name": "Gabriel Soares",
      "email": "soaresggm@gmail.com",
      "commits": 1
    },
    {
      "name": "sagnik-chatterjee",
      "email": "chatterjeesagnik88@gmail.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}