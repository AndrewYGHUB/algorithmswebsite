{
  "slug": "fast-fourier-transform",
  "name": "Fast Fourier Transform",
  "categories": [
    "numericalmethods"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "numerical_methods/fast_fourier_transform.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/numerical_methods/fast_fourier_transform.cpp",
      "code": "<span class=\"hljs-comment\">/**\r\n * @file\r\n * @brief [A fast Fourier transform\r\n * (FFT)](https://medium.com/@aiswaryamathur/understanding-fast-fouriertransform-from-scratch-to-solve-polynomial-multiplication-8018d511162f)\r\n * is an algorithm that computes the\r\n * discrete Fourier transform (DFT) of a sequence, or its inverse (IDFT).\r\n * @details\r\n * This\r\n * algorithm has application in use case scenario where a user wants to find\r\n points of a\r\n * function\r\n * in a short time by just using the coefficients of the polynomial\r\n * function.\r\n * It can be also used to find inverse fourier transform by just switching the\r\n value of omega.\r\n * Time complexity\r\n * this algorithm computes the DFT in O(nlogn) time in comparison to traditional\r\n O(n^2).\r\n * @author [Ameya Chawla](https://github.com/ameyachawlaggsipu)\r\n */</span>\r\n\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>   <span class=\"hljs-comment\">/// for assert</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span>     <span class=\"hljs-comment\">/// for mathematical-related functions</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;complex&gt;</span>   <span class=\"hljs-comment\">/// for storing points and coefficents</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">/// for IO operations</span></span>\r\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>    <span class=\"hljs-comment\">/// for std::vector</span></span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @namespace numerical_methods\r\n * @brief Numerical algorithms/methods\r\n */</span>\r\n<span class=\"hljs-keyword\">namespace</span> numerical_methods {\r\n<span class=\"hljs-comment\">/**\r\n * @brief FastFourierTransform is a recursive function which returns list of\r\n * complex numbers\r\n * @param p List of Coefficents in form of complex numbers\r\n * @param n Count of elements in list p\r\n * @returns p if n==1\r\n * @returns y if n!=1\r\n */</span>\r\n<span class=\"hljs-function\">std::complex&lt;<span class=\"hljs-type\">double</span>&gt; *<span class=\"hljs-title\">FastFourierTransform</span><span class=\"hljs-params\">(std::complex&lt;<span class=\"hljs-type\">double</span>&gt; *p, <span class=\"hljs-type\">uint8_t</span> n)</span> </span>{\r\n    <span class=\"hljs-keyword\">if</span> (n == <span class=\"hljs-number\">1</span>) {\r\n        <span class=\"hljs-keyword\">return</span> p;  <span class=\"hljs-comment\">/// Base Case To return</span>\r\n    }\r\n\r\n    <span class=\"hljs-type\">double</span> pi = <span class=\"hljs-number\">2</span> * <span class=\"hljs-built_in\">asin</span>(<span class=\"hljs-number\">1.0</span>);  <span class=\"hljs-comment\">/// Declaring value of pi</span>\r\n\r\n    std::complex&lt;<span class=\"hljs-type\">double</span>&gt; om = std::<span class=\"hljs-built_in\">complex</span>&lt;<span class=\"hljs-type\">double</span>&gt;(\r\n        <span class=\"hljs-built_in\">cos</span>(<span class=\"hljs-number\">2</span> * pi / n), <span class=\"hljs-built_in\">sin</span>(<span class=\"hljs-number\">2</span> * pi / n));  <span class=\"hljs-comment\">/// Calculating value of omega</span>\r\n\r\n    <span class=\"hljs-keyword\">auto</span> *pe = <span class=\"hljs-keyword\">new</span> std::complex&lt;<span class=\"hljs-type\">double</span>&gt;[n / <span class=\"hljs-number\">2</span>];  <span class=\"hljs-comment\">/// Coefficients of even power</span>\r\n\r\n    <span class=\"hljs-keyword\">auto</span> *po = <span class=\"hljs-keyword\">new</span> std::complex&lt;<span class=\"hljs-type\">double</span>&gt;[n / <span class=\"hljs-number\">2</span>];  <span class=\"hljs-comment\">/// Coefficients of odd power</span>\r\n\r\n    <span class=\"hljs-type\">int</span> k1 = <span class=\"hljs-number\">0</span>, k2 = <span class=\"hljs-number\">0</span>;\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; n; j++) {\r\n        <span class=\"hljs-keyword\">if</span> (j % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>) {\r\n            pe[k1++] = p[j];  <span class=\"hljs-comment\">/// Assigning values of even Coefficients</span>\r\n\r\n        } <span class=\"hljs-keyword\">else</span> {\r\n            po[k2++] = p[j];  <span class=\"hljs-comment\">/// Assigning value of odd Coefficients</span>\r\n        }\r\n    }\r\n\r\n    std::complex&lt;<span class=\"hljs-type\">double</span>&gt; *ye =\r\n        <span class=\"hljs-built_in\">FastFourierTransform</span>(pe, n / <span class=\"hljs-number\">2</span>);  <span class=\"hljs-comment\">/// Recursive Call</span>\r\n\r\n    std::complex&lt;<span class=\"hljs-type\">double</span>&gt; *yo =\r\n        <span class=\"hljs-built_in\">FastFourierTransform</span>(po, n / <span class=\"hljs-number\">2</span>);  <span class=\"hljs-comment\">/// Recursive Call</span>\r\n\r\n    <span class=\"hljs-keyword\">auto</span> *y = <span class=\"hljs-keyword\">new</span> std::complex&lt;<span class=\"hljs-type\">double</span>&gt;[n];  <span class=\"hljs-comment\">/// Final value representation list</span>\r\n\r\n    k1 = <span class=\"hljs-number\">0</span>, k2 = <span class=\"hljs-number\">0</span>;\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n / <span class=\"hljs-number\">2</span>; i++) {\r\n        y[i] =\r\n            ye[k1] + <span class=\"hljs-built_in\">pow</span>(om, i) * yo[k2];  <span class=\"hljs-comment\">/// Updating the first n/2 elements</span>\r\n        y[i + n / <span class=\"hljs-number\">2</span>] =\r\n            ye[k1] - <span class=\"hljs-built_in\">pow</span>(om, i) * yo[k2];  <span class=\"hljs-comment\">/// Updating the last n/2 elements</span>\r\n\r\n        k1++;\r\n        k2++;\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">if</span> (n != <span class=\"hljs-number\">2</span>) {\r\n        <span class=\"hljs-keyword\">delete</span>[] pe;\r\n        <span class=\"hljs-keyword\">delete</span>[] po;\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">delete</span>[] ye;  <span class=\"hljs-comment\">/// Deleting dynamic array ye</span>\r\n    <span class=\"hljs-keyword\">delete</span>[] yo;  <span class=\"hljs-comment\">/// Deleting dynamic array yo</span>\r\n    <span class=\"hljs-keyword\">return</span> y;\r\n}\r\n\r\n}  <span class=\"hljs-comment\">// namespace numerical_methods</span>\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Self-test implementations\r\n * @details\r\n * Declaring two test cases and checking for the error\r\n * in predicted and true value is less than 0.000000000001.\r\n * @returns void\r\n */</span>\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\r\n    <span class=\"hljs-comment\">/* descriptions of the following test */</span>\r\n\r\n    <span class=\"hljs-keyword\">auto</span> *t1 = <span class=\"hljs-keyword\">new</span> std::complex&lt;<span class=\"hljs-type\">double</span>&gt;[<span class=\"hljs-number\">2</span>];  <span class=\"hljs-comment\">/// Test case 1</span>\r\n    <span class=\"hljs-keyword\">auto</span> *t2 = <span class=\"hljs-keyword\">new</span> std::complex&lt;<span class=\"hljs-type\">double</span>&gt;[<span class=\"hljs-number\">4</span>];  <span class=\"hljs-comment\">/// Test case 2</span>\r\n\r\n    t1[<span class=\"hljs-number\">0</span>] = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>};\r\n    t1[<span class=\"hljs-number\">1</span>] = {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>};\r\n    t2[<span class=\"hljs-number\">0</span>] = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>};\r\n    t2[<span class=\"hljs-number\">1</span>] = {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>};\r\n    t2[<span class=\"hljs-number\">2</span>] = {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">0</span>};\r\n    t2[<span class=\"hljs-number\">3</span>] = {<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">0</span>};\r\n\r\n    <span class=\"hljs-type\">uint8_t</span> n1 = <span class=\"hljs-number\">2</span>;\r\n    <span class=\"hljs-type\">uint8_t</span> n2 = <span class=\"hljs-number\">4</span>;\r\n    std::vector&lt;std::complex&lt;<span class=\"hljs-type\">double</span>&gt;&gt; r1 = {\r\n        {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">0</span>}, {<span class=\"hljs-number\">-1</span>, <span class=\"hljs-number\">0</span>}};  <span class=\"hljs-comment\">/// True Answer for test case 1</span>\r\n\r\n    std::vector&lt;std::complex&lt;<span class=\"hljs-type\">double</span>&gt;&gt; r2 = {\r\n        {<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">0</span>}, {<span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">-2</span>}, {<span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">0</span>}, {<span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">2</span>}};  <span class=\"hljs-comment\">/// True Answer for test case 2</span>\r\n\r\n    std::complex&lt;<span class=\"hljs-type\">double</span>&gt; *o1 = numerical_methods::<span class=\"hljs-built_in\">FastFourierTransform</span>(t1, n1);\r\n    std::complex&lt;<span class=\"hljs-type\">double</span>&gt; *t3 =\r\n        o1;  <span class=\"hljs-comment\">/// Temporary variable used to delete memory location of o1</span>\r\n    std::complex&lt;<span class=\"hljs-type\">double</span>&gt; *o2 = numerical_methods::<span class=\"hljs-built_in\">FastFourierTransform</span>(t2, n2);\r\n    std::complex&lt;<span class=\"hljs-type\">double</span>&gt; *t4 =\r\n        o2;  <span class=\"hljs-comment\">/// Temporary variable used to delete memory location of o2</span>\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint8_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; n1; i++) {\r\n        <span class=\"hljs-built_in\">assert</span>((r1[i].<span class=\"hljs-built_in\">real</span>() - o1-&gt;<span class=\"hljs-built_in\">real</span>() &lt; <span class=\"hljs-number\">0.000000000001</span>) &amp;&amp;\r\n               (r1[i].<span class=\"hljs-built_in\">imag</span>() - o1-&gt;<span class=\"hljs-built_in\">imag</span>() &lt;\r\n                <span class=\"hljs-number\">0.000000000001</span>));  <span class=\"hljs-comment\">/// Comparing for both real and imaginary</span>\r\n                                   <span class=\"hljs-comment\">/// values for test case 1</span>\r\n        o1++;\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint8_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; n2; i++) {\r\n        <span class=\"hljs-built_in\">assert</span>((r2[i].<span class=\"hljs-built_in\">real</span>() - o2-&gt;<span class=\"hljs-built_in\">real</span>() &lt; <span class=\"hljs-number\">0.000000000001</span>) &amp;&amp;\r\n               (r2[i].<span class=\"hljs-built_in\">imag</span>() - o2-&gt;<span class=\"hljs-built_in\">imag</span>() &lt;\r\n                <span class=\"hljs-number\">0.000000000001</span>));  <span class=\"hljs-comment\">/// Comparing for both real and imaginary</span>\r\n                                   <span class=\"hljs-comment\">/// values for test case 2</span>\r\n        o2++;\r\n    }\r\n\r\n    <span class=\"hljs-keyword\">delete</span>[] t1;\r\n    <span class=\"hljs-keyword\">delete</span>[] t2;\r\n    <span class=\"hljs-keyword\">delete</span>[] t3;\r\n    <span class=\"hljs-keyword\">delete</span>[] t4;\r\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;All tests have successfully passed!\\n&quot;</span>;\r\n}\r\n\r\n<span class=\"hljs-comment\">/**\r\n * @brief Main function\r\n * @param argc commandline argument count (ignored)\r\n * @param argv commandline array of arguments (ignored)\r\n * calls automated test function to test the working of fast fourier transform.\r\n * @returns 0 on exit\r\n */</span>\r\n\r\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> <span class=\"hljs-type\">const</span> *argv[])</span> </span>{\r\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">//  run self-test implementations</span>\r\n             <span class=\"hljs-comment\">//  with 2 defined test cases</span>\r\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\r\n}\r\n"
    },
    "rust": {
      "dir": "src/math/fast_fourier_transform.rs",
      "url": "https://github.com/TheAlgorithms/rust/tree/master/src/math/fast_fourier_transform.rs",
      "code": "<span class=\"hljs-keyword\">use</span> std::ops::{Add, Mul, MulAssign, Sub};\n\n<span class=\"hljs-comment\">// f64 complex</span>\n<span class=\"hljs-meta\">#[derive(Clone, Copy, Debug)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Complex64</span> {\n    <span class=\"hljs-keyword\">pub</span> re: <span class=\"hljs-type\">f64</span>,\n    <span class=\"hljs-keyword\">pub</span> im: <span class=\"hljs-type\">f64</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Complex64</span> {\n    <span class=\"hljs-meta\">#[inline]</span>\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">new</span>(re: <span class=\"hljs-type\">f64</span>, im: <span class=\"hljs-type\">f64</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-keyword\">Self</span> { re, im }\n    }\n\n    <span class=\"hljs-meta\">#[inline]</span>\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">square_norm</span>(&amp;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">f64</span> {\n        <span class=\"hljs-keyword\">self</span>.re * <span class=\"hljs-keyword\">self</span>.re + <span class=\"hljs-keyword\">self</span>.im * <span class=\"hljs-keyword\">self</span>.im\n    }\n\n    <span class=\"hljs-meta\">#[inline]</span>\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">norm</span>(&amp;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">f64</span> {\n        <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">square_norm</span>().<span class=\"hljs-title function_ invoke__\">sqrt</span>()\n    }\n\n    <span class=\"hljs-meta\">#[inline]</span>\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">inverse</span>(&amp;<span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> Complex64 {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">nrm</span> = <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">square_norm</span>();\n        Complex64 {\n            re: <span class=\"hljs-keyword\">self</span>.re / nrm,\n            im: -<span class=\"hljs-keyword\">self</span>.im / nrm,\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Default</span> <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Complex64</span> {\n    <span class=\"hljs-meta\">#[inline]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">default</span>() <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-keyword\">Self</span> { re: <span class=\"hljs-number\">0.0</span>, im: <span class=\"hljs-number\">0.0</span> }\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Add</span>&lt;Complex64&gt; <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Complex64</span> {\n    <span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Output</span> = Complex64;\n\n    <span class=\"hljs-meta\">#[inline]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">add</span>(<span class=\"hljs-keyword\">self</span>, other: Complex64) <span class=\"hljs-punctuation\">-&gt;</span> Complex64 {\n        Complex64 {\n            re: <span class=\"hljs-keyword\">self</span>.re + other.re,\n            im: <span class=\"hljs-keyword\">self</span>.im + other.im,\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Sub</span>&lt;Complex64&gt; <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Complex64</span> {\n    <span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Output</span> = Complex64;\n\n    <span class=\"hljs-meta\">#[inline]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">sub</span>(<span class=\"hljs-keyword\">self</span>, other: Complex64) <span class=\"hljs-punctuation\">-&gt;</span> Complex64 {\n        Complex64 {\n            re: <span class=\"hljs-keyword\">self</span>.re - other.re,\n            im: <span class=\"hljs-keyword\">self</span>.im - other.im,\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">Mul</span>&lt;Complex64&gt; <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Complex64</span> {\n    <span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Output</span> = Complex64;\n\n    <span class=\"hljs-meta\">#[inline]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">mul</span>(<span class=\"hljs-keyword\">self</span>, other: Complex64) <span class=\"hljs-punctuation\">-&gt;</span> Complex64 {\n        Complex64 {\n            re: <span class=\"hljs-keyword\">self</span>.re * other.re - <span class=\"hljs-keyword\">self</span>.im * other.im,\n            im: <span class=\"hljs-keyword\">self</span>.re * other.im + <span class=\"hljs-keyword\">self</span>.im * other.re,\n        }\n    }\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">MulAssign</span>&lt;Complex64&gt; <span class=\"hljs-keyword\">for</span> <span class=\"hljs-title class_\">Complex64</span> {\n    <span class=\"hljs-meta\">#[inline]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">mul_assign</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, other: Complex64) {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">tmp</span> = <span class=\"hljs-keyword\">self</span>.re * other.im + <span class=\"hljs-keyword\">self</span>.im * other.re;\n        <span class=\"hljs-keyword\">self</span>.re = <span class=\"hljs-keyword\">self</span>.re * other.re - <span class=\"hljs-keyword\">self</span>.im * other.im;\n        <span class=\"hljs-keyword\">self</span>.im = tmp;\n    }\n}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">fast_fourier_transform_input_permutation</span>(length: <span class=\"hljs-type\">usize</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">usize</span>&gt; {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">result</span> = Vec::<span class=\"hljs-title function_ invoke__\">new</span>();\n    result.<span class=\"hljs-title function_ invoke__\">reserve_exact</span>(length);\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..length {\n        result.<span class=\"hljs-title function_ invoke__\">push</span>(i);\n    }\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">reverse</span> = <span class=\"hljs-number\">0_usize</span>;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">position</span> = <span class=\"hljs-number\">1_usize</span>;\n    <span class=\"hljs-keyword\">while</span> position &lt; length {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">bit</span> = length &gt;&gt; <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">while</span> bit &amp; reverse != <span class=\"hljs-number\">0</span> {\n            reverse ^= bit;\n            bit &gt;&gt;= <span class=\"hljs-number\">1</span>;\n        }\n        reverse ^= bit;\n        <span class=\"hljs-comment\">// This is equivalent to adding 1 to a reversed number</span>\n        <span class=\"hljs-keyword\">if</span> position &lt; reverse {\n            <span class=\"hljs-comment\">// Only swap each element once</span>\n            result.<span class=\"hljs-title function_ invoke__\">swap</span>(position, reverse);\n        }\n        position += <span class=\"hljs-number\">1</span>;\n    }\n    result\n}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">fast_fourier_transform</span>(input: &amp;[<span class=\"hljs-type\">f64</span>], input_permutation: &amp;[<span class=\"hljs-type\">usize</span>]) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Vec</span>&lt;Complex64&gt; {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">n</span> = input.<span class=\"hljs-title function_ invoke__\">len</span>();\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">result</span> = Vec::<span class=\"hljs-title function_ invoke__\">new</span>();\n    result.<span class=\"hljs-title function_ invoke__\">reserve_exact</span>(n);\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">position</span> <span class=\"hljs-keyword\">in</span> input_permutation {\n        result.<span class=\"hljs-title function_ invoke__\">push</span>(Complex64::<span class=\"hljs-title function_ invoke__\">new</span>(input[*position], <span class=\"hljs-number\">0.0</span>));\n    }\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">segment_length</span> = <span class=\"hljs-number\">1_usize</span>;\n    <span class=\"hljs-keyword\">while</span> segment_length &lt; n {\n        segment_length &lt;&lt;= <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">angle</span>: <span class=\"hljs-type\">f64</span> = std::f64::consts::TAU / segment_length <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">f64</span>;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">w_len</span> = Complex64::<span class=\"hljs-title function_ invoke__\">new</span>(angle.<span class=\"hljs-title function_ invoke__\">cos</span>(), angle.<span class=\"hljs-title function_ invoke__\">sin</span>());\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">segment_start</span> <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-number\">0</span>..n).<span class=\"hljs-title function_ invoke__\">step_by</span>(segment_length) {\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">w</span> = Complex64::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">0.0</span>);\n            <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">position</span> <span class=\"hljs-keyword\">in</span> segment_start..(segment_start + segment_length / <span class=\"hljs-number\">2</span>) {\n                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">a</span> = result[position];\n                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">b</span> = result[position + segment_length / <span class=\"hljs-number\">2</span>] * w;\n                result[position] = a + b;\n                result[position + segment_length / <span class=\"hljs-number\">2</span>] = a - b;\n                w *= w_len;\n            }\n        }\n    }\n    result\n}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">inverse_fast_fourier_transform</span>(\n    input: &amp;[Complex64],\n    input_permutation: &amp;[<span class=\"hljs-type\">usize</span>],\n) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">f64</span>&gt; {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">n</span> = input.<span class=\"hljs-title function_ invoke__\">len</span>();\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">result</span> = Vec::<span class=\"hljs-title function_ invoke__\">new</span>();\n    result.<span class=\"hljs-title function_ invoke__\">reserve_exact</span>(n);\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">position</span> <span class=\"hljs-keyword\">in</span> input_permutation {\n        result.<span class=\"hljs-title function_ invoke__\">push</span>(input[*position]);\n    }\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">segment_length</span> = <span class=\"hljs-number\">1_usize</span>;\n    <span class=\"hljs-keyword\">while</span> segment_length &lt; n {\n        segment_length &lt;&lt;= <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">angle</span>: <span class=\"hljs-type\">f64</span> = -std::f64::consts::TAU / segment_length <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">f64</span>;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">w_len</span> = Complex64::<span class=\"hljs-title function_ invoke__\">new</span>(angle.<span class=\"hljs-title function_ invoke__\">cos</span>(), angle.<span class=\"hljs-title function_ invoke__\">sin</span>());\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">segment_start</span> <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-number\">0</span>..n).<span class=\"hljs-title function_ invoke__\">step_by</span>(segment_length) {\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">w</span> = Complex64::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">0.0</span>);\n            <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">position</span> <span class=\"hljs-keyword\">in</span> segment_start..(segment_start + segment_length / <span class=\"hljs-number\">2</span>) {\n                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">a</span> = result[position];\n                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">b</span> = result[position + segment_length / <span class=\"hljs-number\">2</span>] * w;\n                result[position] = a + b;\n                result[position + segment_length / <span class=\"hljs-number\">2</span>] = a - b;\n                w *= w_len;\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">scale</span> = <span class=\"hljs-number\">1.0</span> / n <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">f64</span>;\n    result.<span class=\"hljs-title function_ invoke__\">iter</span>().<span class=\"hljs-title function_ invoke__\">map</span>(|x| x.re * scale).<span class=\"hljs-title function_ invoke__\">collect</span>()\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::*;\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">almost_equal</span>(a: <span class=\"hljs-type\">f64</span>, b: <span class=\"hljs-type\">f64</span>, epsilon: <span class=\"hljs-type\">f64</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">bool</span> {\n        (a - b).<span class=\"hljs-title function_ invoke__\">abs</span>() &lt; epsilon\n    }\n\n    <span class=\"hljs-keyword\">const</span> EPSILON: <span class=\"hljs-type\">f64</span> = <span class=\"hljs-number\">1e-6</span>;\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">small_polynomial_returns_self</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">polynomial</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.0f64</span>, <span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">2.5</span>];\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">permutation</span> = <span class=\"hljs-title function_ invoke__\">fast_fourier_transform_input_permutation</span>(polynomial.<span class=\"hljs-title function_ invoke__\">len</span>());\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">fft</span> = <span class=\"hljs-title function_ invoke__\">fast_fourier_transform</span>(&amp;polynomial, &amp;permutation);\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">ifft</span> = <span class=\"hljs-title function_ invoke__\">inverse_fast_fourier_transform</span>(&amp;fft, &amp;permutation);\n        <span class=\"hljs-title function_ invoke__\">for</span> (x, y) <span class=\"hljs-keyword\">in</span> ifft.<span class=\"hljs-title function_ invoke__\">iter</span>().<span class=\"hljs-title function_ invoke__\">zip</span>(polynomial.<span class=\"hljs-title function_ invoke__\">iter</span>()) {\n            <span class=\"hljs-built_in\">assert!</span>(<span class=\"hljs-title function_ invoke__\">almost_equal</span>(*x, *y, EPSILON));\n        }\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">square_small_polynomial</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">polynomial</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.0f64</span>, <span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">2.0</span>];\n        polynomial.<span class=\"hljs-title function_ invoke__\">append</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0.0</span>; <span class=\"hljs-number\">4</span>]);\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">permutation</span> = <span class=\"hljs-title function_ invoke__\">fast_fourier_transform_input_permutation</span>(polynomial.<span class=\"hljs-title function_ invoke__\">len</span>());\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">fft</span> = <span class=\"hljs-title function_ invoke__\">fast_fourier_transform</span>(&amp;polynomial, &amp;permutation);\n        fft.<span class=\"hljs-title function_ invoke__\">iter_mut</span>().<span class=\"hljs-title function_ invoke__\">for_each</span>(|num| *num *= *num);\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">ifft</span> = <span class=\"hljs-title function_ invoke__\">inverse_fast_fourier_transform</span>(&amp;fft, &amp;permutation);\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">expected</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">2.0</span>, <span class=\"hljs-number\">1.0</span>, <span class=\"hljs-number\">4.0</span>, <span class=\"hljs-number\">4.0</span>, <span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">4.0</span>, <span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">0.0</span>];\n        <span class=\"hljs-title function_ invoke__\">for</span> (x, y) <span class=\"hljs-keyword\">in</span> ifft.<span class=\"hljs-title function_ invoke__\">iter</span>().<span class=\"hljs-title function_ invoke__\">zip</span>(expected.<span class=\"hljs-title function_ invoke__\">iter</span>()) {\n            <span class=\"hljs-built_in\">assert!</span>(<span class=\"hljs-title function_ invoke__\">almost_equal</span>(*x, *y, EPSILON));\n        }\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-meta\">#[ignore]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">square_big_polynomial</span>() {\n        <span class=\"hljs-comment\">// This test case takes ~1050ms on my machine in unoptimized mode,</span>\n        <span class=\"hljs-comment\">// but it takes ~70ms in release mode.</span>\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">n</span> = <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">17</span>; <span class=\"hljs-comment\">// ~100_000</span>\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">polynomial</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1.0f64</span>; n];\n        polynomial.<span class=\"hljs-title function_ invoke__\">append</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0.0f64</span>; n]);\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">permutation</span> = <span class=\"hljs-title function_ invoke__\">fast_fourier_transform_input_permutation</span>(polynomial.<span class=\"hljs-title function_ invoke__\">len</span>());\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">fft</span> = <span class=\"hljs-title function_ invoke__\">fast_fourier_transform</span>(&amp;polynomial, &amp;permutation);\n        fft.<span class=\"hljs-title function_ invoke__\">iter_mut</span>().<span class=\"hljs-title function_ invoke__\">for_each</span>(|num| *num *= *num);\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">ifft</span> = <span class=\"hljs-title function_ invoke__\">inverse_fast_fourier_transform</span>(&amp;fft, &amp;permutation);\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">expected</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0.0</span>; n &lt;&lt; <span class=\"hljs-number\">1</span>];\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..((n &lt;&lt; <span class=\"hljs-number\">1</span>) - <span class=\"hljs-number\">1</span>) {\n            expected[i] = std::cmp::<span class=\"hljs-title function_ invoke__\">min</span>(i + <span class=\"hljs-number\">1</span>, (n &lt;&lt; <span class=\"hljs-number\">1</span>) - <span class=\"hljs-number\">1</span> - i) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">f64</span>;\n        }\n        <span class=\"hljs-title function_ invoke__\">for</span> (x, y) <span class=\"hljs-keyword\">in</span> ifft.<span class=\"hljs-title function_ invoke__\">iter</span>().<span class=\"hljs-title function_ invoke__\">zip</span>(expected.<span class=\"hljs-title function_ invoke__\">iter</span>()) {\n            <span class=\"hljs-built_in\">assert!</span>(<span class=\"hljs-title function_ invoke__\">almost_equal</span>(*x, *y, EPSILON));\n        }\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "2kindsofcs",
      "email": "42531877+2kindsofcs@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Ameya Chawla",
      "email": "88154798+ameyachawlaggsipu@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Erfan Khadem",
      "email": "45465346+er888kh@users.noreply.github.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}