{
  "slug": "fibonacci-heap",
  "name": "Fibonacci Heap",
  "categories": [
    "datastructures",
    "heaps"
  ],
  "body": {},
  "implementations": {
    "java": {
      "dir": "src/main/java/com/thealgorithms/datastructures/heaps/FibonacciHeap.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src/main/java/com/thealgorithms/datastructures/heaps/FibonacciHeap.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.datastructures.heaps;\n\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">FibonacciHeap</span> {\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-variable\">GOLDEN_RATIO</span> <span class=\"hljs-operator\">=</span> (<span class=\"hljs-number\">1</span> + Math.sqrt(<span class=\"hljs-number\">5</span>)) / <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-keyword\">private</span> HeapNode min;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">totalLinks</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">totalCuts</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">numOfTrees</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">numOfHeapNodes</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">markedHeapNoodesCounter</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-comment\">/*\n     * a constructor for an empty Heap\n     * set the min to be null\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">FibonacciHeap</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-built_in\">this</span>.min = <span class=\"hljs-literal\">null</span>;\n    }\n\n    <span class=\"hljs-comment\">/*\n     * a constructor for a Heap with one element\n     * set the min to be the HeapNode with the given key\n     * @pre key&gt;=0\n     * @post empty == false\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">FibonacciHeap</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> {\n        <span class=\"hljs-built_in\">this</span>.min = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HeapNode</span>(key);\n        <span class=\"hljs-built_in\">this</span>.numOfTrees++;\n        <span class=\"hljs-built_in\">this</span>.numOfHeapNodes++;\n    }\n\n    <span class=\"hljs-comment\">/*\n     * check if the heap is empty\n     * $ret == true - if the tree is empty\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">empty</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-built_in\">this</span>.min == <span class=\"hljs-literal\">null</span>);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Creates a node (of type HeapNode) which contains the given key, and inserts it into the heap.\n     *\n     * <span class=\"hljs-doctag\">@pre</span> key&gt;=0\n     * <span class=\"hljs-doctag\">@post</span> (numOfnodes = = $prev numOfnodes + 1)\n     * <span class=\"hljs-doctag\">@post</span> empty == false\n     * $ret = the HeapNode we inserted\n     */</span>\n    <span class=\"hljs-keyword\">public</span> HeapNode <span class=\"hljs-title function_\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> {\n        <span class=\"hljs-type\">HeapNode</span> <span class=\"hljs-variable\">toInsert</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HeapNode</span>(key);              <span class=\"hljs-comment\">//creates the node</span>\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.empty()) {\n            <span class=\"hljs-built_in\">this</span>.min = toInsert;\n        } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-comment\">//tree is not empty</span>\n            min.setNext(toInsert);\n            <span class=\"hljs-built_in\">this</span>.updateMin(toInsert);\n        }\n        <span class=\"hljs-built_in\">this</span>.numOfHeapNodes++;\n        <span class=\"hljs-built_in\">this</span>.numOfTrees++;\n        <span class=\"hljs-keyword\">return</span> toInsert;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Delete the node containing the minimum key in the heap\n     * updates new min\n     *\n     * <span class=\"hljs-doctag\">@post</span> (numOfnodes = = $prev numOfnodes - 1)\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">deleteMin</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.empty()) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.numOfHeapNodes == <span class=\"hljs-number\">1</span>) { <span class=\"hljs-comment\">//if there is only one tree</span>\n            <span class=\"hljs-built_in\">this</span>.min = <span class=\"hljs-literal\">null</span>;\n            <span class=\"hljs-built_in\">this</span>.numOfTrees--;\n            <span class=\"hljs-built_in\">this</span>.numOfHeapNodes--;\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        <span class=\"hljs-comment\">//change all children&#x27;s parent to null//</span>\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.min.child != <span class=\"hljs-literal\">null</span>) { <span class=\"hljs-comment\">//min has a child</span>\n            <span class=\"hljs-type\">HeapNode</span> <span class=\"hljs-variable\">child</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">this</span>.min.child;\n            <span class=\"hljs-type\">HeapNode</span> <span class=\"hljs-variable\">tmpChild</span> <span class=\"hljs-operator\">=</span> child;\n            child.parent = <span class=\"hljs-literal\">null</span>;\n            <span class=\"hljs-keyword\">while</span> (child.next != tmpChild) {\n                child = child.next;\n                child.parent = <span class=\"hljs-literal\">null</span>;\n            }\n        }\n        <span class=\"hljs-comment\">//delete the node//</span>\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.numOfTrees &gt; <span class=\"hljs-number\">1</span>) {\n            (<span class=\"hljs-built_in\">this</span>.min.prev).next = <span class=\"hljs-built_in\">this</span>.min.next;\n            (<span class=\"hljs-built_in\">this</span>.min.next).prev = <span class=\"hljs-built_in\">this</span>.min.prev;\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.min.child != <span class=\"hljs-literal\">null</span>) {\n                (<span class=\"hljs-built_in\">this</span>.min.prev).setNext(<span class=\"hljs-built_in\">this</span>.min.child);\n            }\n        } <span class=\"hljs-keyword\">else</span> { <span class=\"hljs-comment\">//this.numOfTrees = 1</span>\n            <span class=\"hljs-built_in\">this</span>.min = <span class=\"hljs-built_in\">this</span>.min.child;\n        }\n        <span class=\"hljs-built_in\">this</span>.numOfHeapNodes--;\n        <span class=\"hljs-built_in\">this</span>.successiveLink(<span class=\"hljs-built_in\">this</span>.min.getNext());\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Return the node of the heap whose key is minimal.\n     * $ret == null if (empty==true)\n     */</span>\n    <span class=\"hljs-keyword\">public</span> HeapNode <span class=\"hljs-title function_\">findMin</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.min;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Meld the heap with heap2\n     *\n     * <span class=\"hljs-doctag\">@pre</span> heap2 != null\n     * <span class=\"hljs-doctag\">@post</span> (numOfnodes = = $prev numOfnodes + heap2.numOfnodes)\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">meld</span><span class=\"hljs-params\">(FibonacciHeap heap2)</span> {\n        <span class=\"hljs-keyword\">if</span> (heap2.empty()) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.empty()) {\n            <span class=\"hljs-built_in\">this</span>.min = heap2.min;\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-built_in\">this</span>.min.setNext(heap2.min);\n            <span class=\"hljs-built_in\">this</span>.updateMin(heap2.min);\n        }\n        <span class=\"hljs-built_in\">this</span>.numOfTrees += heap2.numOfTrees;\n        <span class=\"hljs-built_in\">this</span>.numOfHeapNodes += heap2.numOfHeapNodes;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Return the number of elements in the heap\n     * $ret == 0 if heap is empty\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">size</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.numOfHeapNodes;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Return a counters array, where the value of the i-th index is the number of trees with rank i in the heap.\n     * returns an empty array for an empty heap\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span>[] countersRep() {\n        <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.empty()) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[<span class=\"hljs-number\">0</span>];     <span class=\"hljs-comment\">///return an empty array</span>\n        }\n        <span class=\"hljs-type\">int</span>[] rankArray = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[(<span class=\"hljs-type\">int</span>) Math.floor(Math.log(<span class=\"hljs-built_in\">this</span>.size()) / Math.log(GOLDEN_RATIO)) + <span class=\"hljs-number\">1</span>];  <span class=\"hljs-comment\">//creates the array</span>\n        rankArray[<span class=\"hljs-built_in\">this</span>.min.rank]++;\n        <span class=\"hljs-type\">HeapNode</span> <span class=\"hljs-variable\">curr</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">this</span>.min.next;\n        <span class=\"hljs-keyword\">while</span> (curr != <span class=\"hljs-built_in\">this</span>.min) {\n            rankArray[curr.rank]++;\n            curr = curr.next;\n        }\n        <span class=\"hljs-keyword\">return</span> rankArray;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Deletes the node x from the heap (using decreaseKey(x) to -1)\n     *\n     * <span class=\"hljs-doctag\">@pre</span> heap contains x\n     * <span class=\"hljs-doctag\">@post</span> (numOfnodes = = $prev numOfnodes - 1)\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">delete</span><span class=\"hljs-params\">(HeapNode x)</span> {\n        <span class=\"hljs-built_in\">this</span>.decreaseKey(x, x.getKey() + <span class=\"hljs-number\">1</span>);         <span class=\"hljs-comment\">//change key to be the minimal (-1)</span>\n        <span class=\"hljs-built_in\">this</span>.deleteMin();                           <span class=\"hljs-comment\">//delete it</span>\n    }\n\n    <span class=\"hljs-comment\">/**\n     * The function decreases the key of the node x by delta.\n     *\n     * <span class=\"hljs-doctag\">@pre</span> x.key &gt;= delta (we don&#x27;t realize it when calling from delete())\n     * <span class=\"hljs-doctag\">@pre</span> heap contains x\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">decreaseKey</span><span class=\"hljs-params\">(HeapNode x, <span class=\"hljs-type\">int</span> delta)</span> {\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">newKey</span> <span class=\"hljs-operator\">=</span> x.getKey() - delta;\n        x.key = newKey;\n        <span class=\"hljs-keyword\">if</span> (x.isRoot()) {<span class=\"hljs-comment\">//no parent to x</span>\n            <span class=\"hljs-built_in\">this</span>.updateMin(x);\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (x.getKey() &gt;= x.parent.getKey()) {\n            <span class=\"hljs-keyword\">return</span>;\n        } <span class=\"hljs-comment\">//we don&#x27;t need to cut</span>\n        <span class=\"hljs-type\">HeapNode</span> <span class=\"hljs-variable\">prevParent</span> <span class=\"hljs-operator\">=</span> x.parent;\n        <span class=\"hljs-built_in\">this</span>.cut(x);\n        <span class=\"hljs-built_in\">this</span>.cascadingCuts(prevParent);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * returns the current potential of the heap, which is:\n     * Potential = #trees + 2*#markedNodes\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">potential</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> numOfTrees + (<span class=\"hljs-number\">2</span> * markedHeapNoodesCounter);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * This static function returns the total number of link operations made during the run-time of the program.\n     * A link operation is the operation which gets as input two trees of the same rank, and generates a tree of\n     * rank bigger by one.\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">totalLinks</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> totalLinks;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * This static function returns the total number of cut operations made during the run-time of the program.\n     * A cut operation is the operation which disconnects a subtree from its parent (during decreaseKey/delete methods).\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">totalCuts</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> totalCuts;\n    }\n\n    <span class=\"hljs-comment\">/*\n     * updates the min of the heap (if needed)\n     * @pre this.min == @param (posMin) if and only if (posMin.key &lt; this.min.key)\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">updateMin</span><span class=\"hljs-params\">(HeapNode posMin)</span> {\n        <span class=\"hljs-keyword\">if</span> (posMin.getKey() &lt; <span class=\"hljs-built_in\">this</span>.min.getKey()) {\n            <span class=\"hljs-built_in\">this</span>.min = posMin;\n        }\n    }\n\n    <span class=\"hljs-comment\">/*\n     * Recursively &quot;runs&quot; all the way up from @param (curr) and mark the nodes.\n     * stop the recursion if we had arrived to a marked node or to a root.\n     * if we arrived to a marked node, we cut it and continue recursively.\n     * called after a node was cut.\n     * @post (numOfnodes == $prev numOfnodes)\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">cascadingCuts</span><span class=\"hljs-params\">(HeapNode curr)</span> {\n        <span class=\"hljs-keyword\">if</span> (!curr.isMarked()) {                      <span class=\"hljs-comment\">//stop the recursion</span>\n            curr.mark();\n            <span class=\"hljs-keyword\">if</span> (!curr.isRoot()) <span class=\"hljs-built_in\">this</span>.markedHeapNoodesCounter++;\n            <span class=\"hljs-keyword\">return</span>;\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">if</span> (curr.isRoot()) {\n                <span class=\"hljs-keyword\">return</span>;\n            }\n            <span class=\"hljs-type\">HeapNode</span> <span class=\"hljs-variable\">prevParent</span> <span class=\"hljs-operator\">=</span> curr.parent;\n            <span class=\"hljs-built_in\">this</span>.cut(curr);\n            <span class=\"hljs-built_in\">this</span>.cascadingCuts(prevParent);\n        }\n    }\n\n    <span class=\"hljs-comment\">/*\n     * cut a node (and his &quot;subtree&quot;) from his origin tree and connect it to the heap as a new tree.\n     * called after a node was cut.\n     * @post (numOfnodes == $prev numOfnodes)\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">cut</span><span class=\"hljs-params\">(HeapNode curr)</span> {\n        curr.parent.rank--;\n        <span class=\"hljs-keyword\">if</span> (curr.marked) {\n            <span class=\"hljs-built_in\">this</span>.markedHeapNoodesCounter--;\n            curr.marked = <span class=\"hljs-literal\">false</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (curr.parent.child == curr) { <span class=\"hljs-comment\">//we should change the parent&#x27;s child</span>\n            <span class=\"hljs-keyword\">if</span> (curr.next == curr) { <span class=\"hljs-comment\">//curr do not have brothers</span>\n                curr.parent.child = <span class=\"hljs-literal\">null</span>;\n            } <span class=\"hljs-keyword\">else</span> {<span class=\"hljs-comment\">//curr have brothers</span>\n                curr.parent.child = curr.next;\n            }\n        }\n        curr.prev.next = curr.next;\n        curr.next.prev = curr.prev;\n        curr.next = curr;\n        curr.prev = curr;\n        curr.parent = <span class=\"hljs-literal\">null</span>;\n        <span class=\"hljs-built_in\">this</span>.min.setNext(curr);\n        <span class=\"hljs-built_in\">this</span>.updateMin(curr);\n        <span class=\"hljs-built_in\">this</span>.numOfTrees++;\n        totalCuts++;\n    }\n\n\n    <span class=\"hljs-comment\">/*\n     *\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">successiveLink</span><span class=\"hljs-params\">(HeapNode curr)</span> {\n        HeapNode[] buckets = <span class=\"hljs-built_in\">this</span>.toBuckets(curr);\n        <span class=\"hljs-built_in\">this</span>.min = <span class=\"hljs-built_in\">this</span>.fromBuckets(buckets);\n    }\n\n    <span class=\"hljs-comment\">/*\n     *\n     */</span>\n    <span class=\"hljs-keyword\">private</span> HeapNode[] toBuckets(HeapNode curr) {\n        HeapNode[] buckets = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HeapNode</span>[(<span class=\"hljs-type\">int</span>) Math.floor(Math.log(<span class=\"hljs-built_in\">this</span>.size()) / Math.log(GOLDEN_RATIO)) + <span class=\"hljs-number\">1</span>];\n        curr.prev.next = <span class=\"hljs-literal\">null</span>;\n        HeapNode tmpCurr;\n        <span class=\"hljs-keyword\">while</span> (curr != <span class=\"hljs-literal\">null</span>) {\n            tmpCurr = curr;\n            curr = curr.next;\n            tmpCurr.next = tmpCurr;\n            tmpCurr.prev = tmpCurr;\n            <span class=\"hljs-keyword\">while</span> (buckets[tmpCurr.rank] != <span class=\"hljs-literal\">null</span>) {\n                tmpCurr = <span class=\"hljs-built_in\">this</span>.link(tmpCurr, buckets[tmpCurr.rank]);\n                buckets[tmpCurr.rank - <span class=\"hljs-number\">1</span>] = <span class=\"hljs-literal\">null</span>;\n            }\n            buckets[tmpCurr.rank] = tmpCurr;\n        }\n        <span class=\"hljs-keyword\">return</span> buckets;\n    }\n\n    <span class=\"hljs-comment\">/*\n     *\n     */</span>\n    <span class=\"hljs-keyword\">private</span> HeapNode <span class=\"hljs-title function_\">fromBuckets</span><span class=\"hljs-params\">(HeapNode[] buckets)</span> {\n        <span class=\"hljs-type\">HeapNode</span> <span class=\"hljs-variable\">tmpMin</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n        <span class=\"hljs-built_in\">this</span>.numOfTrees = <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; buckets.length; i++) {\n            <span class=\"hljs-keyword\">if</span> (buckets[i] != <span class=\"hljs-literal\">null</span>) {\n                <span class=\"hljs-built_in\">this</span>.numOfTrees++;\n                <span class=\"hljs-keyword\">if</span> (tmpMin == <span class=\"hljs-literal\">null</span>) {\n                    tmpMin = buckets[i];\n                    tmpMin.next = tmpMin;\n                    tmpMin.prev = tmpMin;\n                } <span class=\"hljs-keyword\">else</span> {\n                    tmpMin.setNext(buckets[i]);\n                    <span class=\"hljs-keyword\">if</span> (buckets[i].getKey() &lt; tmpMin.getKey()) {\n                        tmpMin = buckets[i];\n                    }\n                }\n            }\n        }\n        <span class=\"hljs-keyword\">return</span> tmpMin;\n    }\n\n    <span class=\"hljs-comment\">/*\n     * link between two nodes (and their trees)\n     * defines the smaller node to be the parent\n     */</span>\n    <span class=\"hljs-keyword\">private</span> HeapNode <span class=\"hljs-title function_\">link</span><span class=\"hljs-params\">(HeapNode c1, HeapNode c2)</span> {\n        <span class=\"hljs-keyword\">if</span> (c1.getKey() &gt; c2.getKey()) {\n            <span class=\"hljs-type\">HeapNode</span> <span class=\"hljs-variable\">c3</span> <span class=\"hljs-operator\">=</span> c1;\n            c1 = c2;\n            c2 = c3;\n        }\n        <span class=\"hljs-keyword\">if</span> (c1.child == <span class=\"hljs-literal\">null</span>) {\n            c1.child = c2;\n        } <span class=\"hljs-keyword\">else</span> {\n            c1.child.setNext(c2);\n        }\n        c2.parent = c1;\n        c1.rank++;\n        totalLinks++;\n        <span class=\"hljs-keyword\">return</span> c1;\n    }\n\n\n    <span class=\"hljs-comment\">/**\n     * public class HeapNode\n     * each HeapNode belongs to a heap (Inner class)\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HeapNode</span> {\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> key;\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> rank;\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">boolean</span> marked;\n        <span class=\"hljs-keyword\">private</span> HeapNode child;\n        <span class=\"hljs-keyword\">private</span> HeapNode next;\n        <span class=\"hljs-keyword\">private</span> HeapNode prev;\n        <span class=\"hljs-keyword\">private</span> HeapNode parent;\n\n        <span class=\"hljs-comment\">/*\n         * a constructor for a heapNode withe key @param (key)\n         * prev == next == this\n         * parent == child == null\n         */</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">HeapNode</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> key)</span> {\n            <span class=\"hljs-built_in\">this</span>.key = key;\n            <span class=\"hljs-built_in\">this</span>.marked = <span class=\"hljs-literal\">false</span>;\n            <span class=\"hljs-built_in\">this</span>.next = <span class=\"hljs-built_in\">this</span>;\n            <span class=\"hljs-built_in\">this</span>.prev = <span class=\"hljs-built_in\">this</span>;\n        }\n\n        <span class=\"hljs-comment\">/*\n         * returns the key of the node.\n         */</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getKey</span><span class=\"hljs-params\">()</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.key;\n        }\n\n\n        <span class=\"hljs-comment\">/*\n         * checks whether the node is marked\n         * $ret = true if one child has been cut\n         */</span>\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isMarked</span><span class=\"hljs-params\">()</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.marked;\n        }\n\n        <span class=\"hljs-comment\">/*\n         * mark a node (after a child was cut)\n         * @inv root.mark() == false.\n         */</span>\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">mark</span><span class=\"hljs-params\">()</span> {\n            <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">this</span>.isRoot()) {\n                <span class=\"hljs-keyword\">return</span>;\n            }  <span class=\"hljs-comment\">//check if the node is a root</span>\n            <span class=\"hljs-built_in\">this</span>.marked = <span class=\"hljs-literal\">true</span>;\n        }\n\n        <span class=\"hljs-comment\">/*\n         * add the node @param (newNext) to be between this and this.next\n         * works fine also if @param (newNext) does not &quot;stands&quot; alone\n         */</span>\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">setNext</span><span class=\"hljs-params\">(HeapNode newNext)</span> {\n            <span class=\"hljs-type\">HeapNode</span> <span class=\"hljs-variable\">tmpNext</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-built_in\">this</span>.next;\n            <span class=\"hljs-built_in\">this</span>.next = newNext;\n            <span class=\"hljs-built_in\">this</span>.next.prev.next = tmpNext;\n            tmpNext.prev = newNext.prev;\n            <span class=\"hljs-built_in\">this</span>.next.prev = <span class=\"hljs-built_in\">this</span>;\n        }\n\n        <span class=\"hljs-comment\">/*\n         * returns the next node to this node\n         */</span>\n        <span class=\"hljs-keyword\">private</span> HeapNode <span class=\"hljs-title function_\">getNext</span><span class=\"hljs-params\">()</span> {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.next;\n        }\n\n        <span class=\"hljs-comment\">/*\n         * check if the node is a root\n         * root definition - this.parent == null (uppest in his tree)\n         */</span>\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">isRoot</span><span class=\"hljs-params\">()</span> {\n            <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-built_in\">this</span>.parent == <span class=\"hljs-literal\">null</span>);\n        }\n    }\n}\n"
    },
    "c-sharp": {
      "dir": "./DataStructures/Heap/FibonacciHeap/FibonacciHeap.cs",
      "url": "https:/github.com/TheAlgorithms/C-Sharp/tree/master/DataStructures/Heap/FibonacciHeap/FibonacciHeap.cs",
      "code": "<span class=\"hljs-keyword\">using</span> System;\n<span class=\"hljs-keyword\">using</span> System.Collections.Generic;\n<span class=\"hljs-keyword\">using</span> System.Linq;\n\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">DataStructures.Heap.FibonacciHeap</span>\n{\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     A generic implementation of a Fibonacci heap.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;remarks&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;para&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         A Fibonacci heap is similar to a standard binary heap</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;see cref=&quot;DataStructures.Heap.BinaryHeap{T}&quot; /&gt;</span>, however it uses concepts</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         of amortized analysis to provide theoretical speedups on common operations like</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         insert, union, and decrease-key while maintaining the same speed on all other</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         operations.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;/para&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;para&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         In practice, Fibonacci heaps are more complicated than binary heaps and require</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         a large input problems before the benifits of the theoretical speed up</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         begin to show.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;/para&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;para&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         References:</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         [1] Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest,</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         and Clifford Stein. 2009. Introduction to Algorithms, Third Edition (3rd. ed.).</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         The MIT Press.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;/para&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/remarks&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;typeparam name=&quot;T&quot;&gt;</span>Type of elements in binary heap.<span class=\"hljs-doctag\">&lt;/typeparam&gt;</span></span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">FibonacciHeap</span>&lt;<span class=\"hljs-title\">T</span>&gt; <span class=\"hljs-keyword\">where</span> <span class=\"hljs-title\">T</span> : <span class=\"hljs-title\">IComparable</span>\n    {\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Gets or sets the count of the number of nodes in the Fibonacci heap.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> Count { <span class=\"hljs-keyword\">get</span>; <span class=\"hljs-keyword\">set</span>; }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Gets or sets a reference to the MinItem. The MinItem and all of its siblings</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     comprise the root list, a list of trees that satisfy the heap property and</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     are joined in a circularly doubly linked list.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-keyword\">private</span> FHeapNode&lt;T&gt;? MinItem { <span class=\"hljs-keyword\">get</span>; <span class=\"hljs-keyword\">set</span>; }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Add item <span class=\"hljs-doctag\">&lt;c&gt;</span>x<span class=\"hljs-doctag\">&lt;/c&gt;</span> to this Fibonacci heap.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;remarks&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     To add an item to a Fibonacci heap, we simply add it to the &quot;root list&quot;,</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     a circularly doubly linked list where our minimum item sits. Since adding</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     items to a linked list takes O(1) time, the overall time to perform this</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     operation is O(1).</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/remarks&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;x&quot;&gt;</span>An item to push onto the heap.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     A reference to the item as it is in the heap. This is used for</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     operations like decresing key.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> FHeapNode&lt;T&gt; <span class=\"hljs-title\">Push</span>(<span class=\"hljs-params\">T x</span>)</span>\n        {\n            Count++;\n\n            <span class=\"hljs-keyword\">var</span> newItem = <span class=\"hljs-keyword\">new</span> FHeapNode&lt;T&gt;(x);\n\n            <span class=\"hljs-keyword\">if</span> (MinItem == <span class=\"hljs-literal\">null</span>)\n            {\n                MinItem = newItem;\n            }\n            <span class=\"hljs-keyword\">else</span>\n            {\n                MinItem.AddRight(newItem);\n\n                <span class=\"hljs-keyword\">if</span> (newItem.Key.CompareTo(MinItem.Key) &lt; <span class=\"hljs-number\">0</span>)\n                {\n                    MinItem = newItem;\n                }\n            }\n\n            <span class=\"hljs-keyword\">return</span> newItem;\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Combines all the elements of two fibonacci heaps.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;remarks&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     To union two Fibonacci heaps is a single fibonacci heap is a single heap</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     that contains all the elements of both heaps. This can be done in O(1) time</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     by concatenating the root lists together.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     For more details on how two circularly linked lists are concatenated, see</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;see cref=&quot;FHeapNode{T}.ConcatenateRight&quot; /&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Finally, check to see which of <span class=\"hljs-doctag\">&lt;c&gt;</span>this.MinItem<span class=\"hljs-doctag\">&lt;/c&gt;</span> and <span class=\"hljs-doctag\">&lt;c&gt;</span>other.MinItem<span class=\"hljs-doctag\">&lt;/c&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     is smaller, and set <span class=\"hljs-doctag\">&lt;c&gt;</span>this.MinItem<span class=\"hljs-doctag\">&lt;/c&gt;</span> accordingly</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     This operation destroys <span class=\"hljs-doctag\">&lt;c&gt;</span>other<span class=\"hljs-doctag\">&lt;/c&gt;</span>.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/remarks&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;other&quot;&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Another heap whose elements we wish to add to this heap.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     The other heap will be destroyed as a result.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Union</span>(<span class=\"hljs-params\">FibonacciHeap&lt;T&gt; other</span>)</span>\n        {\n            <span class=\"hljs-comment\">// If there are no items in the other heap, then there is nothing to do.</span>\n            <span class=\"hljs-keyword\">if</span> (other.MinItem == <span class=\"hljs-literal\">null</span>)\n            {\n                <span class=\"hljs-keyword\">return</span>;\n            }\n\n            <span class=\"hljs-comment\">// If this heap is empty, simply set it equal to the other heap</span>\n            <span class=\"hljs-keyword\">if</span> (MinItem == <span class=\"hljs-literal\">null</span>)\n            {\n                <span class=\"hljs-comment\">// Set this heap to the other one</span>\n                MinItem = other.MinItem;\n                Count = other.Count;\n\n                <span class=\"hljs-comment\">// Destroy the other heap</span>\n                other.MinItem = <span class=\"hljs-literal\">null</span>;\n                other.Count = <span class=\"hljs-number\">0</span>;\n\n                <span class=\"hljs-keyword\">return</span>;\n            }\n\n            Count += other.Count;\n\n            <span class=\"hljs-comment\">// &lt;see cref=&quot;DataStructures.FibonacciHeap{T}.FHeapNode.ConcatenateRight(DataStructures.FibonacciHeap{T}.FHeapNode)&quot;/&gt;</span>\n            MinItem.ConcatenateRight(other.MinItem);\n\n            <span class=\"hljs-comment\">// Set the MinItem to the smaller of the two MinItems</span>\n            <span class=\"hljs-keyword\">if</span> (other.MinItem.Key.CompareTo(MinItem.Key) &lt; <span class=\"hljs-number\">0</span>)\n            {\n                MinItem = other.MinItem;\n            }\n\n            other.MinItem = <span class=\"hljs-literal\">null</span>;\n            other.Count = <span class=\"hljs-number\">0</span>;\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Return the MinItem and remove it from the heap.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;remarks&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     This function (with all of its helper functions) is the most complicated</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     part of the Fibonacci Heap. However, it can be broken down into a few steps.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;list type=&quot;number&quot;&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;item&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>             Add the children of MinItem to the root list. Either one of these children,</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>             or another of the items in the root list is a candidate to become the new</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>             MinItem.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;/item&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;item&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>             Remove the MinItem from the root list and appoint a new MinItem temporarily.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;/item&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;item&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>             <span class=\"hljs-doctag\">&lt;see cref=&quot;Consolidate&quot; /&gt;</span> what&#x27;s left</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>             of the heap.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;/item&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;/list&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/remarks&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>The minimum item from the heap.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title\">Pop</span>()</span>\n        {\n            FHeapNode&lt;T&gt;? z = <span class=\"hljs-literal\">null</span>;\n            <span class=\"hljs-keyword\">if</span> (MinItem == <span class=\"hljs-literal\">null</span>)\n            {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> InvalidOperationException(<span class=\"hljs-string\">&quot;Heap is empty!&quot;</span>);\n            }\n\n            z = MinItem;\n\n            <span class=\"hljs-comment\">// Since z is leaving the heap, add its children to the root list</span>\n            <span class=\"hljs-keyword\">if</span> (z.Child != <span class=\"hljs-literal\">null</span>)\n            {\n                <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-function\"><span class=\"hljs-keyword\">var</span> x <span class=\"hljs-keyword\">in</span> <span class=\"hljs-title\">SiblingIterator</span>(<span class=\"hljs-params\">z.Child</span>))</span>\n                {\n                    x.Parent = <span class=\"hljs-literal\">null</span>;\n                }\n\n                <span class=\"hljs-comment\">// This effectively adds each child x to the root list</span>\n                z.ConcatenateRight(z.Child);\n            }\n\n            <span class=\"hljs-keyword\">if</span> (Count == <span class=\"hljs-number\">1</span>)\n            {\n                MinItem = <span class=\"hljs-literal\">null</span>;\n                Count = <span class=\"hljs-number\">0</span>;\n                <span class=\"hljs-keyword\">return</span> z.Key;\n            }\n\n            <span class=\"hljs-comment\">// Temporarily reassign MinItem to an arbitrary item in the root</span>\n            <span class=\"hljs-comment\">// list</span>\n            MinItem = MinItem.Right;\n\n            <span class=\"hljs-comment\">// Remove the old MinItem from the root list altogether</span>\n            z.Remove();\n\n            <span class=\"hljs-comment\">// Consolidate the heap</span>\n            Consolidate();\n\n            Count -= <span class=\"hljs-number\">1</span>;\n\n            <span class=\"hljs-keyword\">return</span> z.Key;\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     A method to see what&#x27;s on top of the heap without changing its structure.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Returns the top element without popping it from the structure of</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     the heap.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> T <span class=\"hljs-title\">Peek</span>()</span>\n        {\n            <span class=\"hljs-keyword\">if</span> (MinItem == <span class=\"hljs-literal\">null</span>)\n            {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> InvalidOperationException(<span class=\"hljs-string\">&quot;The heap is empty&quot;</span>);\n            }\n\n            <span class=\"hljs-keyword\">return</span> MinItem.Key;\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Reduce the key of x to be k.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;remarks&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     k must be less than x.Key, increasing the key of an item is not supported.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/remarks&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;x&quot;&gt;</span>The item you want to reduce in value.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;k&quot;&gt;</span>The new value for the item.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">DecreaseKey</span>(<span class=\"hljs-params\">FHeapNode&lt;T&gt; x, T k</span>)</span>\n        {\n            <span class=\"hljs-keyword\">if</span> (MinItem == <span class=\"hljs-literal\">null</span>)\n            {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ArgumentException(<span class=\"hljs-string\">$&quot;<span class=\"hljs-subst\">{<span class=\"hljs-keyword\">nameof</span>(x)}</span> is not from the heap&quot;</span>);\n            }\n\n            <span class=\"hljs-keyword\">if</span> (x.Key == <span class=\"hljs-literal\">null</span>)\n            {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ArgumentException(<span class=\"hljs-string\">&quot;x has no value&quot;</span>);\n            }\n\n            <span class=\"hljs-keyword\">if</span> (k.CompareTo(x.Key) &gt; <span class=\"hljs-number\">0</span>)\n            {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> InvalidOperationException(<span class=\"hljs-string\">&quot;Value cannot be increased&quot;</span>);\n            }\n\n            x.Key = k;\n            <span class=\"hljs-keyword\">var</span> y = x.Parent;\n            <span class=\"hljs-keyword\">if</span> (y != <span class=\"hljs-literal\">null</span> &amp;&amp; x.Key.CompareTo(y.Key) &lt; <span class=\"hljs-number\">0</span>)\n            {\n                Cut(x, y);\n                CascadingCut(y);\n            }\n\n            <span class=\"hljs-keyword\">if</span> (x.Key.CompareTo(MinItem.Key) &lt; <span class=\"hljs-number\">0</span>)\n            {\n                MinItem = x;\n            }\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Remove x from the child list of y.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;x&quot;&gt;</span>A child of y we just decreased the value of.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;y&quot;&gt;</span>The now former parent of x.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Cut</span>(<span class=\"hljs-params\">FHeapNode&lt;T&gt; x, FHeapNode&lt;T&gt; y</span>)</span>\n        {\n            <span class=\"hljs-keyword\">if</span> (MinItem == <span class=\"hljs-literal\">null</span>)\n            {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> InvalidOperationException(<span class=\"hljs-string\">&quot;Heap malformed&quot;</span>);\n            }\n\n            <span class=\"hljs-keyword\">if</span> (y.Degree == <span class=\"hljs-number\">1</span>)\n            {\n                y.Child = <span class=\"hljs-literal\">null</span>;\n                MinItem.AddRight(x);\n            }\n            <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (y.Degree &gt; <span class=\"hljs-number\">1</span>)\n            {\n                x.Remove();\n            }\n            <span class=\"hljs-keyword\">else</span>\n            {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> InvalidOperationException(<span class=\"hljs-string\">&quot;Heap malformed&quot;</span>);\n            }\n\n            y.Degree--;\n            x.Mark = <span class=\"hljs-literal\">false</span>;\n            x.Parent = <span class=\"hljs-literal\">null</span>;\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Rebalances the heap after the decrease operation takes place.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;y&quot;&gt;</span>An item that may no longer obey the heap property.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">CascadingCut</span>(<span class=\"hljs-params\">FHeapNode&lt;T&gt; y</span>)</span>\n        {\n            <span class=\"hljs-keyword\">var</span> z = y.Parent;\n            <span class=\"hljs-keyword\">if</span> (z != <span class=\"hljs-literal\">null</span>)\n            {\n                <span class=\"hljs-keyword\">if</span> (!y.Mark)\n                {\n                    y.Mark = <span class=\"hljs-literal\">true</span>;\n                }\n                <span class=\"hljs-keyword\">else</span>\n                {\n                    Cut(y, z);\n                    CascadingCut(z);\n                }\n            }\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;para&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         Consolidate is analogous to Heapify in <span class=\"hljs-doctag\">&lt;see cref=&quot;DataStructures.Heap.BinaryHeap{T}&quot; /&gt;</span>.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;/para&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;para&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         First, an array <span class=\"hljs-doctag\">&lt;c&gt;</span>A<span class=\"hljs-doctag\">&lt;/c&gt;</span> [0...D(H.n)] is created where H.n is the number</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         of items in this heap, and D(x) is the max degree any node can have in a</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         Fibonacci heap with x nodes.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;/para&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;para&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         For each node <span class=\"hljs-doctag\">&lt;c&gt;</span>x<span class=\"hljs-doctag\">&lt;/c&gt;</span> in the root list, try to add it to <span class=\"hljs-doctag\">&lt;c&gt;</span>A[d]<span class=\"hljs-doctag\">&lt;/c&gt;</span> where</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         d is the degree of <span class=\"hljs-doctag\">&lt;c&gt;</span>x<span class=\"hljs-doctag\">&lt;/c&gt;</span>.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         If there is already a node in <span class=\"hljs-doctag\">&lt;c&gt;</span>A[d]<span class=\"hljs-doctag\">&lt;/c&gt;</span>, call it <span class=\"hljs-doctag\">&lt;c&gt;</span>y<span class=\"hljs-doctag\">&lt;/c&gt;</span>, and make</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;c&gt;</span>y<span class=\"hljs-doctag\">&lt;/c&gt;</span> a child of <span class=\"hljs-doctag\">&lt;c&gt;</span>x<span class=\"hljs-doctag\">&lt;/c&gt;</span>. (Swap <span class=\"hljs-doctag\">&lt;c&gt;</span>x<span class=\"hljs-doctag\">&lt;/c&gt;</span> and <span class=\"hljs-doctag\">&lt;c&gt;</span>y<span class=\"hljs-doctag\">&lt;/c&gt;</span> beforehand if</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;c&gt;</span>x<span class=\"hljs-doctag\">&lt;/c&gt;</span> is greater than <span class=\"hljs-doctag\">&lt;c&gt;</span>y<span class=\"hljs-doctag\">&lt;/c&gt;</span>). Now that <span class=\"hljs-doctag\">&lt;c&gt;</span>x<span class=\"hljs-doctag\">&lt;/c&gt;</span> has one more child,</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         remove if from <span class=\"hljs-doctag\">&lt;c&gt;</span>A[d]<span class=\"hljs-doctag\">&lt;/c&gt;</span> and add it to <span class=\"hljs-doctag\">&lt;c&gt;</span>A[d+1]<span class=\"hljs-doctag\">&lt;/c&gt;</span> to reflect that its</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         degree is one more. Loop this behavior until we find an empty spot to put</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         <span class=\"hljs-doctag\">&lt;c&gt;</span>x<span class=\"hljs-doctag\">&lt;/c&gt;</span>.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;/para&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;para&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         With <span class=\"hljs-doctag\">&lt;c&gt;</span>A<span class=\"hljs-doctag\">&lt;/c&gt;</span> all filled, empty the root list of the heap. And add each item</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         from <span class=\"hljs-doctag\">&lt;c&gt;</span>A<span class=\"hljs-doctag\">&lt;/c&gt;</span> into the root list, one by one, making sure to keep track of</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>         which is smallest.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;/para&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Consolidate</span>()</span>\n        {\n            <span class=\"hljs-keyword\">if</span> (MinItem == <span class=\"hljs-literal\">null</span>)\n            {\n                <span class=\"hljs-keyword\">return</span>;\n            }\n\n            <span class=\"hljs-comment\">// There&#x27;s a fact in Intro to Algorithms:</span>\n            <span class=\"hljs-comment\">// &quot;the max degree of any node in an n-node fibonacci heap is O(lg(n)).</span>\n            <span class=\"hljs-comment\">// In particular, we shall show that D(n) &lt;= floor(log_phi(n)) where phi is</span>\n            <span class=\"hljs-comment\">// the golden ratio, defined in equation 3.24 as phi = (1 + sqrt(5))/2&quot;</span>\n            <span class=\"hljs-comment\">//</span>\n            <span class=\"hljs-comment\">// For a proof, see [1]</span>\n            <span class=\"hljs-keyword\">var</span> maxDegree = <span class=\"hljs-number\">1</span> + (<span class=\"hljs-built_in\">int</span>)Math.Log(Count, (<span class=\"hljs-number\">1</span> + Math.Sqrt(<span class=\"hljs-number\">5</span>)) / <span class=\"hljs-number\">2</span>);\n\n            <span class=\"hljs-comment\">// Create slots for every possible node degree of x</span>\n            <span class=\"hljs-keyword\">var</span> a = <span class=\"hljs-keyword\">new</span> FHeapNode&lt;T&gt;?[maxDegree];\n            <span class=\"hljs-keyword\">var</span> siblings = SiblingIterator(MinItem).ToList();\n            <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> w <span class=\"hljs-keyword\">in</span> siblings)\n            {\n                <span class=\"hljs-keyword\">var</span> x = w;\n                <span class=\"hljs-keyword\">var</span> d = x.Degree;\n\n                <span class=\"hljs-keyword\">var</span> y = a[d];\n\n                <span class=\"hljs-comment\">// While A[d] is not empty, we can&#x27;t blindly put x here</span>\n                <span class=\"hljs-keyword\">while</span> (y != <span class=\"hljs-literal\">null</span>)\n                {\n                    <span class=\"hljs-keyword\">if</span> (x.Key.CompareTo(y.Key) &gt; <span class=\"hljs-number\">0</span>)\n                    {\n                        <span class=\"hljs-comment\">// Exchange x and y</span>\n                        <span class=\"hljs-keyword\">var</span> temp = x;\n                        x = y;\n                        y = temp;\n                    }\n\n                    <span class=\"hljs-comment\">// Make y a child of x</span>\n                    FibHeapLink(y, x);\n\n                    <span class=\"hljs-comment\">// Empty out this spot since x now has a higher degree</span>\n                    a[d] = <span class=\"hljs-literal\">null</span>;\n\n                    <span class=\"hljs-comment\">// Add 1 to x&#x27;s degree before going back into the loop</span>\n                    d++;\n\n                    y = a[d];\n                }\n\n                <span class=\"hljs-comment\">// Now that there&#x27;s an empty spot for x, place it there</span>\n                a[d] = x;\n            }\n\n            ReconstructHeap(a);\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Reconstructs the heap based on the array of node degrees created by the consolidate step.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;a&quot;&gt;</span>An array of FHeapNodes where a[i] represents a node of degree i.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ReconstructHeap</span>(<span class=\"hljs-params\">FHeapNode&lt;T&gt;?[] a</span>)</span>\n        {\n            <span class=\"hljs-comment\">// Once all items are in A, empty out the root list</span>\n            MinItem = <span class=\"hljs-literal\">null</span>;\n\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; a.Length; i++)\n            {\n                <span class=\"hljs-keyword\">var</span> r = a[i];\n                <span class=\"hljs-keyword\">if</span> (r == <span class=\"hljs-literal\">null</span>)\n                {\n                    <span class=\"hljs-keyword\">continue</span>;\n                }\n\n                <span class=\"hljs-keyword\">if</span> (MinItem == <span class=\"hljs-literal\">null</span>)\n                {\n                    <span class=\"hljs-comment\">// If the root list is completely empty, make this the new</span>\n                    <span class=\"hljs-comment\">// MinItem</span>\n                    MinItem = r;\n\n                    <span class=\"hljs-comment\">// Make a new root list with just this item. Make sure to make</span>\n                    <span class=\"hljs-comment\">// it its own list.</span>\n                    MinItem.SetSiblings(MinItem, MinItem);\n                    MinItem.Parent = <span class=\"hljs-literal\">null</span>;\n                }\n                <span class=\"hljs-keyword\">else</span>\n                {\n                    <span class=\"hljs-comment\">// Add A[i] to the root list</span>\n                    MinItem.AddRight(r);\n\n                    <span class=\"hljs-comment\">// If this item is smaller, make it the new min item</span>\n                    <span class=\"hljs-keyword\">if</span> (MinItem.Key.CompareTo(r.Key) &gt; <span class=\"hljs-number\">0</span>)\n                    {\n                        MinItem = a[i];\n                    }\n                }\n            }\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Make y a child of x.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;y&quot;&gt;</span>A node to become the child of x.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;x&quot;&gt;</span>A node to become the parent of y.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">FibHeapLink</span>(<span class=\"hljs-params\">FHeapNode&lt;T&gt; y, FHeapNode&lt;T&gt; x</span>)</span>\n        {\n            y.Remove();\n            x.AddChild(y);\n            y.Mark = <span class=\"hljs-literal\">false</span>;\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     A helper function to iterate through all the siblings of this node in the</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     circularly doubly linked list.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;node&quot;&gt;</span>A node we want the siblings of.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>An iterator over all of the siblings.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-keyword\">private</span> IEnumerable&lt;FHeapNode&lt;T&gt;&gt; SiblingIterator(FHeapNode&lt;T&gt; node)\n        {\n            <span class=\"hljs-keyword\">var</span> currentNode = node;\n            <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-keyword\">return</span> currentNode;\n\n            currentNode = node.Right;\n            <span class=\"hljs-keyword\">while</span> (currentNode != node)\n            {\n                <span class=\"hljs-keyword\">yield</span> <span class=\"hljs-keyword\">return</span> currentNode;\n                currentNode = currentNode.Right;\n            }\n        }\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Brian Mata",
      "email": "CyberMobius@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Omar",
      "email": "59146036+omarmahamid@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}