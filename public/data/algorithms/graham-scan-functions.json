{
  "slug": "graham-scan-functions",
  "name": "Graham Scan Functions",
  "categories": [
    "geometry"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "geometry/graham_scan_functions.hpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/geometry/graham_scan_functions.hpp",
      "code": "<span class=\"hljs-comment\">/******************************************************************************\n * @file\n * @brief Implementation of the [Convex\n * Hull](https://en.wikipedia.org/wiki/Convex_hull) implementation using [Graham\n * Scan](https://en.wikipedia.org/wiki/Graham_scan)\n * @details\n * In geometry, the convex hull or convex envelope or convex closure of a shape\n * is the smallest convex set that contains it. The convex hull may be defined\n * either as the intersection of all convex sets containing a given subset of a\n * Euclidean space, or equivalently as the set of all convex combinations of\n * points in the subset. For a bounded subset of the plane, the convex hull may\n * be visualized as the shape enclosed by a rubber band stretched around the\n * subset.\n *\n * The worst case time complexity of Jarvis’s Algorithm is O(n^2). Using\n * Graham’s scan algorithm, we can find Convex Hull in O(nLogn) time.\n *\n * ### Implementation\n *\n * Sort points\n * We first find the bottom-most point. The idea is to pre-process\n * points be sorting them with respect to the bottom-most point. Once the points\n * are sorted, they form a simple closed path.\n * The sorting criteria is to use the orientation to compare angles without\n * actually computing them (See the compare() function below) because\n * computation of actual angles would be inefficient since trigonometric\n * functions are not simple to evaluate.\n *\n * Accept or Reject Points\n * Once we have the closed path, the next step is to traverse the path and\n * remove concave points on this path using orientation. The first two points in\n * sorted array are always part of Convex Hull. For remaining points, we keep\n * track of recent three points, and find the angle formed by them. Let the\n * three points be prev(p), curr(c) and next(n). If orientation of these points\n * (considering them in same order) is not counterclockwise, we discard c,\n * otherwise we keep it.\n *\n * @author [Lajat Manekar](https://github.com/Lazeeez)\n *\n *******************************************************************************/</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span>  <span class=\"hljs-comment\">/// for std::swap</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span>    <span class=\"hljs-comment\">/// for mathematics and datatype conversion</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>   <span class=\"hljs-comment\">/// for IO operations</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span>      <span class=\"hljs-comment\">/// for std::stack</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>     <span class=\"hljs-comment\">/// for std::vector</span></span>\n\n<span class=\"hljs-comment\">/******************************************************************************\n * @namespace geometry\n * @brief geometric algorithms\n *******************************************************************************/</span>\n<span class=\"hljs-keyword\">namespace</span> geometry {\n\n<span class=\"hljs-comment\">/******************************************************************************\n * @namespace graham scan\n * @brief convex hull algorithm\n *******************************************************************************/</span>\n<span class=\"hljs-keyword\">namespace</span> grahamscan {\n\n<span class=\"hljs-comment\">/******************************************************************************\n * @struct Point\n * @brief for X and Y co-ordinates of the co-ordinate.\n *******************************************************************************/</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Point</span> {\n    <span class=\"hljs-type\">int</span> x, y;\n};\n\n<span class=\"hljs-comment\">// A global point needed for sorting points with reference</span>\n<span class=\"hljs-comment\">// to  the first point Used in compare function of qsort()</span>\n\nPoint p0;\n\n<span class=\"hljs-comment\">/******************************************************************************\n * @brief A utility function to find next to top in a stack.\n * @param S Stack to be used for the process.\n * @returns @param Point Co-ordinates of the Point &lt;int, int&gt;\n *******************************************************************************/</span>\n<span class=\"hljs-function\">Point <span class=\"hljs-title\">nextToTop</span><span class=\"hljs-params\">(std::stack&lt;Point&gt; *S)</span> </span>{\n    Point p = S-&gt;<span class=\"hljs-built_in\">top</span>();\n    S-&gt;<span class=\"hljs-built_in\">pop</span>();\n    Point res = S-&gt;<span class=\"hljs-built_in\">top</span>();\n    S-&gt;<span class=\"hljs-built_in\">push</span>(p);\n    <span class=\"hljs-keyword\">return</span> res;\n}\n\n<span class=\"hljs-comment\">/******************************************************************************\n * @brief A utility function to return square of distance between p1 and p2.\n * @param p1 Co-ordinates of Point 1 &lt;int, int&gt;.\n * @param p2 Co-ordinates of Point 2 &lt;int, int&gt;.\n * @returns @param int distance between p1 and p2.\n *******************************************************************************/</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">distSq</span><span class=\"hljs-params\">(Point p1, Point p2)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> (p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y);\n}\n\n<span class=\"hljs-comment\">/******************************************************************************\n * @brief To find orientation of ordered triplet (p, q, r).\n * @param p Co-ordinates of Point p &lt;int, int&gt;.\n * @param q Co-ordinates of Point q &lt;int, int&gt;.\n * @param r Co-ordinates of Point r &lt;int, int&gt;.\n * @returns @param int 0 --&gt; p, q and r are collinear, 1 --&gt; Clockwise,\n * 2 --&gt; Counterclockwise\n *******************************************************************************/</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">orientation</span><span class=\"hljs-params\">(Point p, Point q, Point r)</span> </span>{\n    <span class=\"hljs-type\">int</span> val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n\n    <span class=\"hljs-keyword\">if</span> (val == <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// collinear</span>\n    }\n    <span class=\"hljs-keyword\">return</span> (val &gt; <span class=\"hljs-number\">0</span>) ? <span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">2</span>;  <span class=\"hljs-comment\">// clock or counter-clock wise</span>\n}\n\n<span class=\"hljs-comment\">/******************************************************************************\n * @brief A function used by library function qsort() to sort an array of\n * points with respect to the first point\n * @param vp1 Co-ordinates of Point 1 &lt;int, int&gt;.\n * @param vp2 Co-ordinates of Point 2 &lt;int, int&gt;.\n * @returns @param int distance between p1 and p2.\n *******************************************************************************/</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">compare</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span> *vp1, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span> *vp2)</span> </span>{\n    <span class=\"hljs-keyword\">auto</span> *p1 = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">const</span> Point *&gt;(vp1);\n    <span class=\"hljs-keyword\">auto</span> *p2 = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">const</span> Point *&gt;(vp2);\n\n    <span class=\"hljs-comment\">// Find orientation</span>\n    <span class=\"hljs-type\">int</span> o = <span class=\"hljs-built_in\">orientation</span>(p0, *p1, *p2);\n    <span class=\"hljs-keyword\">if</span> (o == <span class=\"hljs-number\">0</span>) {\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-built_in\">distSq</span>(p0, *p2) &gt;= <span class=\"hljs-built_in\">distSq</span>(p0, *p1)) ? <span class=\"hljs-number\">-1</span> : <span class=\"hljs-number\">1</span>;\n    }\n\n    <span class=\"hljs-keyword\">return</span> (o == <span class=\"hljs-number\">2</span>) ? <span class=\"hljs-number\">-1</span> : <span class=\"hljs-number\">1</span>;\n}\n\n<span class=\"hljs-comment\">/******************************************************************************\n * @brief Prints convex hull of a set of n points.\n * @param points vector of Point&lt;int, int&gt; with co-ordinates.\n * @param size Size of the vector.\n * @returns @param vector vector of Conver Hull.\n *******************************************************************************/</span>\n<span class=\"hljs-function\">std::vector&lt;Point&gt; <span class=\"hljs-title\">convexHull</span><span class=\"hljs-params\">(std::vector&lt;Point&gt; points, <span class=\"hljs-type\">uint64_t</span> size)</span> </span>{\n    <span class=\"hljs-comment\">// Find the bottom-most point</span>\n    <span class=\"hljs-type\">int</span> ymin = points[<span class=\"hljs-number\">0</span>].y, min = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; size; i++) {\n        <span class=\"hljs-type\">int</span> y = points[i].y;\n\n        <span class=\"hljs-comment\">// Pick the bottom-most or chose the left-most point in case of tie</span>\n        <span class=\"hljs-keyword\">if</span> ((y &lt; ymin) || (ymin == y &amp;&amp; points[i].x &lt; points[min].x)) {\n            ymin = points[i].y, min = i;\n        }\n    }\n\n    <span class=\"hljs-comment\">// Place the bottom-most point at first position</span>\n    std::<span class=\"hljs-built_in\">swap</span>(points[<span class=\"hljs-number\">0</span>], points[min]);\n\n    <span class=\"hljs-comment\">// Sort n-1 points with respect to the first point. A point p1 comes</span>\n    <span class=\"hljs-comment\">// before p2 in sorted output if p2 has larger polar angle</span>\n    <span class=\"hljs-comment\">// (in counterclockwise direction) than p1.</span>\n    p0 = points[<span class=\"hljs-number\">0</span>];\n    <span class=\"hljs-built_in\">qsort</span>(&amp;points[<span class=\"hljs-number\">1</span>], size - <span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">sizeof</span>(Point), compare);\n\n    <span class=\"hljs-comment\">// If two or more points make same angle with p0, Remove all but the one</span>\n    <span class=\"hljs-comment\">// that is farthest from p0 Remember that, in above sorting, our criteria</span>\n    <span class=\"hljs-comment\">// was to keep the farthest point at the end when more than one points have</span>\n    <span class=\"hljs-comment\">// same angle.</span>\n    <span class=\"hljs-type\">int</span> m = <span class=\"hljs-number\">1</span>;  <span class=\"hljs-comment\">// Initialize size of modified array</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">1</span>; i &lt; size; i++) {\n        <span class=\"hljs-comment\">// Keep removing i while angle of i and i+1 is same with respect to p0</span>\n        <span class=\"hljs-keyword\">while</span> (i &lt; size - <span class=\"hljs-number\">1</span> &amp;&amp; <span class=\"hljs-built_in\">orientation</span>(p0, points[i], points[i + <span class=\"hljs-number\">1</span>]) == <span class=\"hljs-number\">0</span>) {\n            i++;\n        }\n\n        points[m] = points[i];\n        m++;  <span class=\"hljs-comment\">// Update size of modified array</span>\n    }\n\n    <span class=\"hljs-comment\">// If modified array of points has less than 3 points, convex hull is not</span>\n    <span class=\"hljs-comment\">// possible</span>\n    <span class=\"hljs-keyword\">if</span> (m &lt; <span class=\"hljs-number\">3</span>) {\n        <span class=\"hljs-keyword\">return</span> {};\n    };\n\n    <span class=\"hljs-comment\">// Create an empty stack and push first three points to it.</span>\n    std::stack&lt;Point&gt; St;\n    St.<span class=\"hljs-built_in\">push</span>(points[<span class=\"hljs-number\">0</span>]);\n    St.<span class=\"hljs-built_in\">push</span>(points[<span class=\"hljs-number\">1</span>]);\n    St.<span class=\"hljs-built_in\">push</span>(points[<span class=\"hljs-number\">2</span>]);\n\n    <span class=\"hljs-comment\">// Process remaining n-3 points</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">3</span>; i &lt; m; i++) {\n        <span class=\"hljs-comment\">// Keep removing top while the angle formed by</span>\n        <span class=\"hljs-comment\">// points next-to-top, top, and points[i] makes</span>\n        <span class=\"hljs-comment\">// a non-left turn</span>\n        <span class=\"hljs-keyword\">while</span> (St.<span class=\"hljs-built_in\">size</span>() &gt; <span class=\"hljs-number\">1</span> &amp;&amp;\n               <span class=\"hljs-built_in\">orientation</span>(<span class=\"hljs-built_in\">nextToTop</span>(&amp;St), St.<span class=\"hljs-built_in\">top</span>(), points[i]) != <span class=\"hljs-number\">2</span>) {\n            St.<span class=\"hljs-built_in\">pop</span>();\n        }\n        St.<span class=\"hljs-built_in\">push</span>(points[i]);\n    }\n\n    std::vector&lt;Point&gt; result;\n    <span class=\"hljs-comment\">// Now stack has the output points, push them into the resultant vector</span>\n    <span class=\"hljs-keyword\">while</span> (!St.<span class=\"hljs-built_in\">empty</span>()) {\n        Point p = St.<span class=\"hljs-built_in\">top</span>();\n        result.<span class=\"hljs-built_in\">push_back</span>(p);\n        St.<span class=\"hljs-built_in\">pop</span>();\n    }\n\n    <span class=\"hljs-keyword\">return</span> result;  <span class=\"hljs-comment\">// return resultant vector with Convex Hull co-ordinates.</span>\n}\n}  <span class=\"hljs-comment\">// namespace grahamscan</span>\n}  <span class=\"hljs-comment\">// namespace geometry</span>\n"
    }
  },
  "contributors": [
    {
      "name": "Lajat5",
      "email": "64376519+Lazeeez@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}