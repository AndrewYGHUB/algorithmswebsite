{
  "slug": "horn-schunck",
  "name": "Horn Schunck",
  "categories": [
    "computervision"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "computer_vision/horn_schunck.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/computer_vision/horn_schunck.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;\n    The Horn-Schunck method estimates the optical flow for every single pixel of\n    a sequence of images.\n    It works by assuming brightness constancy between two consecutive frames\n    and smoothness in the optical flow.\n\n    Useful resources:\n    Wikipedia: https://en.wikipedia.org/wiki/Horn%E2%80%93Schunck_method\n    Paper: http://image.diku.dk/imagecanon/material/HornSchunckOptical_Flow.pdf\n&quot;&quot;&quot;</span>\n\n<span class=\"hljs-keyword\">from</span> typing <span class=\"hljs-keyword\">import</span> SupportsIndex\n\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">from</span> scipy.ndimage.filters <span class=\"hljs-keyword\">import</span> convolve\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">warp</span>(<span class=\"hljs-params\">\n    image: np.ndarray, horizontal_flow: np.ndarray, vertical_flow: np.ndarray\n</span>) -&gt; np.ndarray:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Warps the pixels of an image into a new image using the horizontal and vertical\n    flows.\n    Pixels that are warped from an invalid location are set to 0.\n\n    Parameters:\n        image: Grayscale image\n        horizontal_flow: Horizontal flow\n        vertical_flow: Vertical flow\n\n    Returns: Warped image\n\n    &gt;&gt;&gt; warp(np.array([[0, 1, 2], [0, 3, 0], [2, 2, 2]]), \\\n    np.array([[0, 1, -1], [-1, 0, 0], [1, 1, 1]]), \\\n    np.array([[0, 0, 0], [0, 1, 0], [0, 0, 1]]))\n    array([[0, 0, 0],\n           [3, 1, 0],\n           [0, 2, 3]])\n    &quot;&quot;&quot;</span>\n    flow = np.stack((horizontal_flow, vertical_flow), <span class=\"hljs-number\">2</span>)\n\n    <span class=\"hljs-comment\"># Create a grid of all pixel coordinates and subtract the flow to get the</span>\n    <span class=\"hljs-comment\"># target pixels coordinates</span>\n    grid = np.stack(\n        np.meshgrid(np.arange(<span class=\"hljs-number\">0</span>, image.shape[<span class=\"hljs-number\">1</span>]), np.arange(<span class=\"hljs-number\">0</span>, image.shape[<span class=\"hljs-number\">0</span>])), <span class=\"hljs-number\">2</span>\n    )\n    grid = np.<span class=\"hljs-built_in\">round</span>(grid - flow).astype(np.int32)\n\n    <span class=\"hljs-comment\"># Find the locations outside of the original image</span>\n    invalid = (grid &lt; <span class=\"hljs-number\">0</span>) | (grid &gt;= np.array([image.shape[<span class=\"hljs-number\">1</span>], image.shape[<span class=\"hljs-number\">0</span>]]))\n    grid[invalid] = <span class=\"hljs-number\">0</span>\n\n    warped = image[grid[:, :, <span class=\"hljs-number\">1</span>], grid[:, :, <span class=\"hljs-number\">0</span>]]\n\n    <span class=\"hljs-comment\"># Set pixels at invalid locations to 0</span>\n    warped[invalid[:, :, <span class=\"hljs-number\">0</span>] | invalid[:, :, <span class=\"hljs-number\">1</span>]] = <span class=\"hljs-number\">0</span>\n\n    <span class=\"hljs-keyword\">return</span> warped\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">horn_schunck</span>(<span class=\"hljs-params\">\n    image0: np.ndarray,\n    image1: np.ndarray,\n    num_iter: SupportsIndex,\n    alpha: <span class=\"hljs-built_in\">float</span> | <span class=\"hljs-literal\">None</span> = <span class=\"hljs-literal\">None</span>,\n</span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[np.ndarray, np.ndarray]:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    This function performs the Horn-Schunck algorithm and returns the estimated\n    optical flow. It is assumed that the input images are grayscale and\n    normalized to be in [0, 1].\n\n    Parameters:\n        image0: First image of the sequence\n        image1: Second image of the sequence\n        alpha: Regularization constant\n        num_iter: Number of iterations performed\n\n    Returns: estimated horizontal &amp; vertical flow\n\n    &gt;&gt;&gt; np.round(horn_schunck(np.array([[0, 0, 2], [0, 0, 2]]), \\\n    np.array([[0, 2, 0], [0, 2, 0]]), alpha=0.1, num_iter=110)).\\\n    astype(np.int32)\n    array([[[ 0, -1, -1],\n            [ 0, -1, -1]],\n    &lt;BLANKLINE&gt;\n           [[ 0,  0,  0],\n            [ 0,  0,  0]]], dtype=int32)\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">if</span> alpha <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\n        alpha = <span class=\"hljs-number\">0.1</span>\n\n    <span class=\"hljs-comment\"># Initialize flow</span>\n    horizontal_flow = np.zeros_like(image0)\n    vertical_flow = np.zeros_like(image0)\n\n    <span class=\"hljs-comment\"># Prepare kernels for the calculation of the derivatives and the average velocity</span>\n    kernel_x = np.array([[-<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>], [-<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>]]) * <span class=\"hljs-number\">0.25</span>\n    kernel_y = np.array([[-<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>], [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>]]) * <span class=\"hljs-number\">0.25</span>\n    kernel_t = np.array([[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>], [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">1</span>]]) * <span class=\"hljs-number\">0.25</span>\n    kernel_laplacian = np.array(\n        [[<span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">12</span>], [<span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">6</span>], [<span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">12</span>]]\n    )\n\n    <span class=\"hljs-comment\"># Iteratively refine the flow</span>\n    <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(num_iter):\n        warped_image = warp(image0, horizontal_flow, vertical_flow)\n        derivative_x = convolve(warped_image, kernel_x) + convolve(image1, kernel_x)\n        derivative_y = convolve(warped_image, kernel_y) + convolve(image1, kernel_y)\n        derivative_t = convolve(warped_image, kernel_t) + convolve(image1, -kernel_t)\n\n        avg_horizontal_velocity = convolve(horizontal_flow, kernel_laplacian)\n        avg_vertical_velocity = convolve(vertical_flow, kernel_laplacian)\n\n        <span class=\"hljs-comment\"># This updates the flow as proposed in the paper (Step 12)</span>\n        update = (\n            derivative_x * avg_horizontal_velocity\n            + derivative_y * avg_vertical_velocity\n            + derivative_t\n        )\n        update = update / (alpha**<span class=\"hljs-number\">2</span> + derivative_x**<span class=\"hljs-number\">2</span> + derivative_y**<span class=\"hljs-number\">2</span>)\n\n        horizontal_flow = avg_horizontal_velocity - derivative_x * update\n        vertical_flow = avg_vertical_velocity - derivative_y * update\n\n    <span class=\"hljs-keyword\">return</span> horizontal_flow, vertical_flow\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">import</span> doctest\n\n    doctest.testmod()\n"
    }
  },
  "contributors": [
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 1
    },
    {
      "name": "Simon",
      "email": "simon.kiefhaber@outlook.de",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}