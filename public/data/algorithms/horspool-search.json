{
  "slug": "horspool-search",
  "name": "Horspool Search",
  "categories": [
    "strings"
  ],
  "body": {},
  "implementations": {
    "java": {
      "dir": "src/main/java/com/thealgorithms/strings/HorspoolSearch.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src/main/java/com/thealgorithms/strings/HorspoolSearch.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.strings;\n\n<span class=\"hljs-keyword\">import</span> java.util.HashMap;\n\n<span class=\"hljs-comment\">/**\n * This class is not thread safe&lt;br&gt;\n * &lt;br&gt;\n * (From wikipedia) In computer science, the Boyer–Moore–Horspool algorithm or\n * Horspool&#x27;s algorithm is an algorithm for finding substrings in strings. It\n * was published by Nigel Horspool in 1980.\n * &lt;br&gt;\n * &lt;a href=https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore%E2%80%93Horspool_algorithm&gt;Wikipedia\n * page&lt;/a&gt;&lt;br&gt;\n * &lt;br&gt;\n *\n * &lt;p&gt;\n * An explanation:&lt;br&gt;\n *\n * &lt;p&gt;\n * The Horspool algorithm is a simplification of the Boyer-Moore algorithm in\n * that it uses only one of the two heuristic methods for increasing the number\n * of characters shifted when finding a bad match in the text. This method is\n * usually called the &quot;bad symbol&quot; or &quot;bad character&quot; shift. The bad symbol\n * shift method is classified as an input enhancement method in the theory of\n * algorithms. Input enhancement is (from wikipedia) the principle that\n * processing a given input to a problem and altering it in a specific way will\n * increase runtime efficiency or space efficiency, or both. Both algorithms try\n * to match the pattern and text comparing the pattern symbols to the text&#x27;s\n * from right to left.&lt;br&gt;\n * &lt;br&gt;\n *\n * &lt;p&gt;\n * In the bad symbol shift method, a table is created prior to the search,\n * called the &quot;bad symbol table&quot;. The bad symbol table contains the shift values\n * for any symbol in the text and pattern. For these symbols, the value is the\n * length of the pattern, if the symbol is not in the first (length - 1) of the\n * pattern. Else it is the distance from its rightmost occurrence in the pattern\n * to the last symbol of the pattern. In practice, we only calculate the values\n * for the ones that exist in the first (length - 1) of the pattern.&lt;br&gt;\n * &lt;br&gt;\n *\n * &lt;p&gt;\n * For more details on the algorithm and the more advanced Boyer-Moore I\n * recommend checking out the wikipedia page and professor Anany Levitin&#x27;s book:\n * Introduction To The Design And Analysis Of Algorithms.\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">HorspoolSearch</span> {\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> HashMap&lt;Character, Integer&gt; shiftValues; <span class=\"hljs-comment\">// bad symbol table</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Integer patternLength;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">comparisons</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// total comparisons in the current/last search</span>\n\n    <span class=\"hljs-comment\">/**\n     * Case sensitive version version of the algorithm\n     *\n     * <span class=\"hljs-doctag\">@param</span> pattern the pattern to be searched for (needle)\n     * <span class=\"hljs-doctag\">@param</span> text the text being searched in (haystack)\n     * <span class=\"hljs-doctag\">@return</span> -1 if not found or first index of the pattern in the text\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">findFirst</span><span class=\"hljs-params\">(String pattern, String text)</span> {\n        <span class=\"hljs-keyword\">return</span> firstOccurrence(pattern, text, <span class=\"hljs-literal\">true</span>);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Case insensitive version version of the algorithm\n     *\n     * <span class=\"hljs-doctag\">@param</span> pattern the pattern to be searched for (needle)\n     * <span class=\"hljs-doctag\">@param</span> text the text being searched in (haystack)\n     * <span class=\"hljs-doctag\">@return</span> -1 if not found or first index of the pattern in the text\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">findFirstInsensitive</span><span class=\"hljs-params\">(String pattern, String text)</span> {\n        <span class=\"hljs-keyword\">return</span> firstOccurrence(pattern, text, <span class=\"hljs-literal\">false</span>);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Utility method that returns comparisons made by last run (mainly for\n     * tests)\n     *\n     * <span class=\"hljs-doctag\">@return</span> number of character comparisons of the last search\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Integer <span class=\"hljs-title function_\">getLastComparisons</span><span class=\"hljs-params\">()</span> {\n        <span class=\"hljs-keyword\">return</span> HorspoolSearch.comparisons;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Fairly standard implementation of the Horspool algorithm. Only the index\n     * of the last character of the pattern on the text is saved and shifted by\n     * the appropriate amount when a mismatch is found. The algorithm stops at\n     * the first match or when the entire text has been exhausted.\n     *\n     * <span class=\"hljs-doctag\">@param</span> pattern String to be matched in the text\n     * <span class=\"hljs-doctag\">@param</span> text text String\n     * <span class=\"hljs-doctag\">@return</span> index of first occurrence of the pattern in the text\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">firstOccurrence</span><span class=\"hljs-params\">(String pattern, String text, <span class=\"hljs-type\">boolean</span> caseSensitive)</span> {\n        shiftValues = calcShiftValues(pattern); <span class=\"hljs-comment\">// build the bad symbol table</span>\n        comparisons = <span class=\"hljs-number\">0</span>; <span class=\"hljs-comment\">// reset comparisons</span>\n\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">textIndex</span>\n                <span class=\"hljs-operator\">=</span> pattern.length() - <span class=\"hljs-number\">1</span>; <span class=\"hljs-comment\">// align pattern with text start and get index of the last character</span>\n\n        <span class=\"hljs-comment\">// while pattern is not out of text bounds</span>\n        <span class=\"hljs-keyword\">while</span> (textIndex &lt; text.length()) {\n\n            <span class=\"hljs-comment\">// try to match pattern with current part of the text starting from last character</span>\n            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> pattern.length() - <span class=\"hljs-number\">1</span>;\n            <span class=\"hljs-keyword\">while</span> (i &gt;= <span class=\"hljs-number\">0</span>) {\n                comparisons++;\n                <span class=\"hljs-type\">char</span> <span class=\"hljs-variable\">patternChar</span> <span class=\"hljs-operator\">=</span> pattern.charAt(i);\n                <span class=\"hljs-type\">char</span> <span class=\"hljs-variable\">textChar</span> <span class=\"hljs-operator\">=</span> text.charAt((textIndex + i) - (pattern.length() - <span class=\"hljs-number\">1</span>));\n                <span class=\"hljs-keyword\">if</span> (!charEquals(patternChar, textChar, caseSensitive)) { <span class=\"hljs-comment\">// bad character, shift pattern</span>\n                    textIndex += getShiftValue(text.charAt(textIndex));\n                    <span class=\"hljs-keyword\">break</span>;\n                }\n                i--;\n            }\n\n            <span class=\"hljs-comment\">// check for full match</span>\n            <span class=\"hljs-keyword\">if</span> (i == -<span class=\"hljs-number\">1</span>) {\n                <span class=\"hljs-keyword\">return</span> textIndex - pattern.length() + <span class=\"hljs-number\">1</span>;\n            }\n        }\n\n        <span class=\"hljs-comment\">// text exhausted, return failure</span>\n        <span class=\"hljs-keyword\">return</span> -<span class=\"hljs-number\">1</span>;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Compares the argument characters\n     *\n     * <span class=\"hljs-doctag\">@param</span> c1 first character\n     * <span class=\"hljs-doctag\">@param</span> c2 second character\n     * <span class=\"hljs-doctag\">@param</span> caseSensitive boolean determining case sensitivity of comparison\n     * <span class=\"hljs-doctag\">@return</span> truth value of the equality comparison\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">boolean</span> <span class=\"hljs-title function_\">charEquals</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> c1, <span class=\"hljs-type\">char</span> c2, <span class=\"hljs-type\">boolean</span> caseSensitive)</span> {\n        <span class=\"hljs-keyword\">if</span> (caseSensitive) {\n            <span class=\"hljs-type\">return</span> <span class=\"hljs-variable\">c1</span> <span class=\"hljs-operator\">=</span>= c2;\n        }\n        <span class=\"hljs-keyword\">return</span> Character.toLowerCase(c1) == Character.toLowerCase(c2);\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Builds the bad symbol table required to run the algorithm. The method\n     * starts from the second to last character of the pattern and moves to the\n     * left. When it meets a new character, it is by definition its rightmost\n     * occurrence and therefore puts the distance from the current index to the\n     * index of the last character into the table. If the character is already\n     * in the table, then it is not a rightmost occurrence, so it continues.\n     *\n     * <span class=\"hljs-doctag\">@param</span> pattern basis for the bad symbol table\n     * <span class=\"hljs-doctag\">@return</span> the bad symbol table\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> HashMap&lt;Character, Integer&gt; <span class=\"hljs-title function_\">calcShiftValues</span><span class=\"hljs-params\">(String pattern)</span> {\n        patternLength = pattern.length();\n        HashMap&lt;Character, Integer&gt; table = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">HashMap</span>&lt;&gt;();\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> pattern.length() - <span class=\"hljs-number\">2</span>;\n                i &gt;= <span class=\"hljs-number\">0</span>;\n                i--) { <span class=\"hljs-comment\">// length - 2 is the index of the second to last character</span>\n            <span class=\"hljs-type\">char</span> <span class=\"hljs-variable\">c</span> <span class=\"hljs-operator\">=</span> pattern.charAt(i);\n            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">finalI</span> <span class=\"hljs-operator\">=</span> i;\n            table.computeIfAbsent(c, k -&gt; pattern.length() - <span class=\"hljs-number\">1</span> - finalI);\n        }\n\n        <span class=\"hljs-keyword\">return</span> table;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Helper function that uses the bad symbol shift table to return the\n     * appropriate shift value for a given character\n     *\n     * <span class=\"hljs-doctag\">@param</span> c character\n     * <span class=\"hljs-doctag\">@return</span> shift value that corresponds to the character argument\n     */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> Integer <span class=\"hljs-title function_\">getShiftValue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span> c)</span> {\n        <span class=\"hljs-keyword\">if</span> (shiftValues.get(c) != <span class=\"hljs-literal\">null</span>) {\n            <span class=\"hljs-keyword\">return</span> shiftValues.get(c);\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span> patternLength;\n        }\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Aitor Fidalgo Sánchez",
      "email": "64830228+aitorfi@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "George B",
      "email": "geompokon@csd.auth.gr",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}