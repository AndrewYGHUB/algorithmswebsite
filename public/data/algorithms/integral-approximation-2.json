{
  "slug": "integral-approximation-2",
  "name": "Integral Approximation 2",
  "categories": [
    "math"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "math/integral_approximation2.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/math/integral_approximation2.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @brief [Monte Carlo\n * Integration](https://en.wikipedia.org/wiki/Monte_Carlo_integration)\n *\n * @details\n * In mathematics, Monte Carlo integration is a technique for numerical\n * integration using random numbers. It is a particular Monte Carlo method that\n * numerically computes a definite integral. While other algorithms usually\n * evaluate the integrand at a regular grid, Monte Carlo randomly chooses points\n * at which the integrand is evaluated. This method is particularly useful for\n * higher-dimensional integrals.\n *\n * This implementation supports arbitrary pdfs.\n * These pdfs are sampled using the [Metropolis-Hastings\n * algorithm](https://en.wikipedia.org/wiki/Metropolisâ€“Hastings_algorithm). This\n * can be swapped out by every other sampling techniques for example the inverse\n * method. Metropolis-Hastings was chosen because it is the most general and can\n * also be extended for a higher dimensional sampling space.\n *\n * @author [Domenic Zingsheim](https://github.com/DerAndereDomenic)\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> _USE_MATH_DEFINES  <span class=\"hljs-comment\">/// for M_PI on windows</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span>           <span class=\"hljs-comment\">/// for math functions</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdint&gt;</span>         <span class=\"hljs-comment\">/// for fixed size data types</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ctime&gt;</span>           <span class=\"hljs-comment\">/// for time to initialize rng</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;functional&gt;</span>      <span class=\"hljs-comment\">/// for function pointers</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>        <span class=\"hljs-comment\">/// for std::cout</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;random&gt;</span>          <span class=\"hljs-comment\">/// for random number generation</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>          <span class=\"hljs-comment\">/// for std::vector</span></span>\n\n<span class=\"hljs-comment\">/**\n * @namespace math\n * @brief Math algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> math {\n<span class=\"hljs-comment\">/**\n * @namespace monte_carlo\n * @brief Functions for the [Monte Carlo\n * Integration](https://en.wikipedia.org/wiki/Monte_Carlo_integration)\n * implementation\n */</span>\n<span class=\"hljs-keyword\">namespace</span> monte_carlo {\n\n<span class=\"hljs-keyword\">using</span> Function = std::function&lt;<span class=\"hljs-built_in\">double</span>(\n    <span class=\"hljs-type\">double</span>&amp;)&gt;;  <span class=\"hljs-comment\">/// short-hand for std::functions used in this implementation</span>\n\n<span class=\"hljs-comment\">/**\n * @brief Generate samples according to some pdf\n * @details This function uses Metropolis-Hastings to generate random numbers.\n * It generates a sequence of random numbers by using a markov chain. Therefore,\n * we need to define a start_point and the number of samples we want to\n * generate. Because the first samples generated by the markov chain may not be\n * distributed according to the given pdf, one can specify how many samples\n * should be discarded before storing samples.\n * @param start_point The starting point of the markov chain\n * @param pdf The pdf to sample\n * @param num_samples The number of samples to generate\n * @param discard How many samples should be discarded at the start\n * @returns A vector of size num_samples with samples distributed according to\n * the pdf\n */</span>\n<span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">generate_samples</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span>&amp; start_point,\n                                     <span class=\"hljs-type\">const</span> Function&amp; pdf,\n                                     <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span>&amp; num_samples,\n                                     <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span>&amp; discard = <span class=\"hljs-number\">100000</span>)</span> </span>{\n    std::vector&lt;<span class=\"hljs-type\">double</span>&gt; samples;\n    samples.<span class=\"hljs-built_in\">reserve</span>(num_samples);\n\n    <span class=\"hljs-type\">double</span> <span class=\"hljs-type\">x_t</span> = start_point;\n\n    std::default_random_engine generator;\n    <span class=\"hljs-function\">std::uniform_real_distribution&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">uniform</span><span class=\"hljs-params\">(<span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">1.0</span>)</span></span>;\n    <span class=\"hljs-function\">std::normal_distribution&lt;<span class=\"hljs-type\">double</span>&gt; <span class=\"hljs-title\">normal</span><span class=\"hljs-params\">(<span class=\"hljs-number\">0.0</span>, <span class=\"hljs-number\">1.0</span>)</span></span>;\n    generator.<span class=\"hljs-built_in\">seed</span>(<span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">nullptr</span>));\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">uint32_t</span> t = <span class=\"hljs-number\">0</span>; t &lt; num_samples + discard; ++t) {\n        <span class=\"hljs-comment\">// Generate a new proposal according to some mutation strategy.</span>\n        <span class=\"hljs-comment\">// This is arbitrary and can be swapped.</span>\n        <span class=\"hljs-type\">double</span> x_dash = <span class=\"hljs-built_in\">normal</span>(generator) + <span class=\"hljs-type\">x_t</span>;\n        <span class=\"hljs-type\">double</span> acceptance_probability = std::<span class=\"hljs-built_in\">min</span>(<span class=\"hljs-built_in\">pdf</span>(x_dash) / <span class=\"hljs-built_in\">pdf</span>(<span class=\"hljs-type\">x_t</span>), <span class=\"hljs-number\">1.0</span>);\n        <span class=\"hljs-type\">double</span> u = <span class=\"hljs-built_in\">uniform</span>(generator);\n\n        <span class=\"hljs-comment\">// Accept &quot;new state&quot; according to the acceptance_probability</span>\n        <span class=\"hljs-keyword\">if</span> (u &lt;= acceptance_probability) {\n            <span class=\"hljs-type\">x_t</span> = x_dash;\n        }\n\n        <span class=\"hljs-keyword\">if</span> (t &gt;= discard) {\n            samples.<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-type\">x_t</span>);\n        }\n    }\n\n    <span class=\"hljs-keyword\">return</span> samples;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Compute an approximation of an integral using Monte Carlo integration\n * @details The integration domain [a,b] is given by the pdf.\n * The pdf has to fulfill the following conditions:\n * 1) for all x \\in [a,b] : p(x) &gt; 0\n * 2) for all x \\not\\in [a,b] : p(x) = 0\n * 3) \\int_a^b p(x) dx = 1\n * @param start_point The start point of the Markov Chain (see generate_samples)\n * @param function The function to integrate\n * @param pdf The pdf to sample\n * @param num_samples The number of samples used to approximate the integral\n * @returns The approximation of the integral according to 1/N \\sum_{i}^N f(x_i)\n * / p(x_i)\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">integral_monte_carlo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span>&amp; start_point, <span class=\"hljs-type\">const</span> Function&amp; function,\n                            <span class=\"hljs-type\">const</span> Function&amp; pdf,\n                            <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">uint32_t</span>&amp; num_samples = <span class=\"hljs-number\">1000000</span>)</span> </span>{\n    <span class=\"hljs-type\">double</span> integral = <span class=\"hljs-number\">0.0</span>;\n    std::vector&lt;<span class=\"hljs-type\">double</span>&gt; samples =\n        <span class=\"hljs-built_in\">generate_samples</span>(start_point, pdf, num_samples);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">double</span> sample : samples) {\n        integral += <span class=\"hljs-built_in\">function</span>(sample) / <span class=\"hljs-built_in\">pdf</span>(sample);\n    }\n\n    <span class=\"hljs-keyword\">return</span> integral / <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(samples.<span class=\"hljs-built_in\">size</span>());\n}\n\n}  <span class=\"hljs-comment\">// namespace monte_carlo</span>\n}  <span class=\"hljs-comment\">// namespace math</span>\n\n<span class=\"hljs-comment\">/**\n * @brief Self-test implementations\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Disclaimer: Because this is a randomized algorithm,&quot;</span>\n              &lt;&lt; std::endl;\n    std::cout\n        &lt;&lt; <span class=\"hljs-string\">&quot;it may happen that singular samples deviate from the true result.&quot;</span>\n        &lt;&lt; std::endl\n        &lt;&lt; std::endl;\n    ;\n\n    math::monte_carlo::Function f;\n    math::monte_carlo::Function pdf;\n    <span class=\"hljs-type\">double</span> integral = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">double</span> lower_bound = <span class=\"hljs-number\">0</span>, upper_bound = <span class=\"hljs-number\">0</span>;\n\n    <span class=\"hljs-comment\">/* \\int_{-2}^{2} -x^2 + 4 dx */</span>\n    f = [&amp;](<span class=\"hljs-type\">double</span>&amp; x) { <span class=\"hljs-keyword\">return</span> -x * x + <span class=\"hljs-number\">4.0</span>; };\n\n    lower_bound = <span class=\"hljs-number\">-2.0</span>;\n    upper_bound = <span class=\"hljs-number\">2.0</span>;\n    pdf = [&amp;](<span class=\"hljs-type\">double</span>&amp; x) {\n        <span class=\"hljs-keyword\">if</span> (x &gt;= lower_bound &amp;&amp; x &lt;= <span class=\"hljs-number\">-1.0</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.1</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (x &lt;= upper_bound &amp;&amp; x &gt;= <span class=\"hljs-number\">1.0</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.1</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (x &gt; <span class=\"hljs-number\">-1.0</span> &amp;&amp; x &lt; <span class=\"hljs-number\">1.0</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.4</span>;\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.0</span>;\n    };\n\n    integral = math::monte_carlo::<span class=\"hljs-built_in\">integral_monte_carlo</span>(\n        (upper_bound - lower_bound) / <span class=\"hljs-number\">2.0</span>, f, pdf);\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;This number should be close to 10.666666: &quot;</span> &lt;&lt; integral\n              &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">/* \\int_{0}^{1} e^x dx */</span>\n    f = [&amp;](<span class=\"hljs-type\">double</span>&amp; x) { <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">exp</span>(x); };\n\n    lower_bound = <span class=\"hljs-number\">0.0</span>;\n    upper_bound = <span class=\"hljs-number\">1.0</span>;\n    pdf = [&amp;](<span class=\"hljs-type\">double</span>&amp; x) {\n        <span class=\"hljs-keyword\">if</span> (x &gt;= lower_bound &amp;&amp; x &lt;= <span class=\"hljs-number\">0.2</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.1</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (x &gt; <span class=\"hljs-number\">0.2</span> &amp;&amp; x &lt;= <span class=\"hljs-number\">0.4</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.4</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (x &gt; <span class=\"hljs-number\">0.4</span> &amp;&amp; x &lt; upper_bound) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1.5</span>;\n        }\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0.0</span>;\n    };\n\n    integral = math::monte_carlo::<span class=\"hljs-built_in\">integral_monte_carlo</span>(\n        (upper_bound - lower_bound) / <span class=\"hljs-number\">2.0</span>, f, pdf);\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;This number should be close to 1.7182818: &quot;</span> &lt;&lt; integral\n              &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">/* \\int_{-\\infty}^{\\infty} sinc(x) dx, sinc(x) = sin(pi * x) / (pi * x)\n       This is a difficult integral because of its infinite domain.\n       Therefore, it may deviate largely from the expected result.\n    */</span>\n    f = [&amp;](<span class=\"hljs-type\">double</span>&amp; x) { <span class=\"hljs-keyword\">return</span> std::<span class=\"hljs-built_in\">sin</span>(M_PI * x) / (M_PI * x); };\n\n    pdf = [&amp;](<span class=\"hljs-type\">double</span>&amp; x) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1.0</span> / std::<span class=\"hljs-built_in\">sqrt</span>(<span class=\"hljs-number\">2.0</span> * M_PI) * std::<span class=\"hljs-built_in\">exp</span>(-x * x / <span class=\"hljs-number\">2.0</span>);\n    };\n\n    integral = math::monte_carlo::<span class=\"hljs-built_in\">integral_monte_carlo</span>(<span class=\"hljs-number\">0.0</span>, f, pdf, <span class=\"hljs-number\">10000000</span>);\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;This number should be close to 1.0: &quot;</span> &lt;&lt; integral\n              &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Main function\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// run self-test implementations</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [],
  "explanationUrl": {}
}