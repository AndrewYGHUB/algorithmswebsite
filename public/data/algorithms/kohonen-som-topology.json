{
  "slug": "kohonen-som-topology",
  "name": "Kohonen Som Topology",
  "categories": [
    "machinelearning"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "machine_learning/kohonen_som_topology.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/machine_learning/kohonen_som_topology.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * \\addtogroup machine_learning Machine Learning Algorithms\n * @{\n * \\file\n * \\author [Krishna Vedala](https://github.com/kvedala)\n *\n * \\brief [Kohonen self organizing\n * map](https://en.wikipedia.org/wiki/Self-organizing_map) (topological map)\n *\n * \\details\n * This example implements a powerful unsupervised learning algorithm called as\n * a self organizing map. The algorithm creates a connected network of weights\n * that closely follows the given data points. This thus creates a topological\n * map of the given data i.e., it maintains the relationship between varipus\n * data points in a much higher dimesional space by creating an equivalent in a\n * 2-dimensional space.\n * &lt;img alt=&quot;Trained topological maps for the test cases in the program&quot;\n * src=&quot;https://raw.githubusercontent.com/TheAlgorithms/C-Plus-Plus/docs/images/machine_learning/2D_Kohonen_SOM.svg&quot;\n * /&gt;\n * \\note This C++ version of the program is considerable slower than its [C\n * counterpart](https://github.com/kvedala/C/blob/master/machine_learning/kohonen_som_trace.c)\n * \\note The compiled code is much slower when compiled with MS Visual C++ 2019\n * than with GCC on windows\n * \\see kohonen_som_trace.cpp\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> _USE_MATH_DEFINES  <span class=\"hljs-comment\">//&lt; required for MS Visual C++</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;array&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cerrno&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstdlib&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;ctime&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;fstream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;valarray&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP  <span class=\"hljs-comment\">// check if OpenMP based parallellization is available</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;omp.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n<span class=\"hljs-comment\">/**\n * Helper function to generate a random number in a given interval.\n * \\n Steps:\n * 1. `r1 = rand() % 100` gets a random number between 0 and 99\n * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99\n * 3. scale and offset the random number to given range of \\f$[a,b]\\f$\n *\n * \\param[in] a lower limit\n * \\param[in] b upper limit\n * \\returns random number in the range \\f$[a,b]\\f$\n */</span>\n<span class=\"hljs-type\">double</span> _random(<span class=\"hljs-type\">double</span> a, <span class=\"hljs-type\">double</span> b) {\n    <span class=\"hljs-keyword\">return</span> ((b - a) * (std::<span class=\"hljs-built_in\">rand</span>() % <span class=\"hljs-number\">100</span>) / <span class=\"hljs-number\">100.f</span>) + a;\n}\n\n<span class=\"hljs-comment\">/**\n * Save a given n-dimensional data martix to file.\n *\n * \\param[in] fname filename to save in (gets overwriten without confirmation)\n * \\param[in] X matrix to save\n * \\returns 0 if all ok\n * \\returns -1 if file creation failed\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">save_2d_data</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fname,\n                 <span class=\"hljs-type\">const</span> std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; &amp;X)</span> </span>{\n    <span class=\"hljs-type\">size_t</span> num_points = X.<span class=\"hljs-built_in\">size</span>();       <span class=\"hljs-comment\">// number of rows</span>\n    <span class=\"hljs-type\">size_t</span> num_features = X[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>();  <span class=\"hljs-comment\">// number of columns</span>\n\n    std::ofstream fp;\n    fp.<span class=\"hljs-built_in\">open</span>(fname);\n    <span class=\"hljs-keyword\">if</span> (!fp.<span class=\"hljs-built_in\">is_open</span>()) {\n        <span class=\"hljs-comment\">// error with opening file to write</span>\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;Error opening file &quot;</span> &lt;&lt; fname &lt;&lt; <span class=\"hljs-string\">&quot;: &quot;</span>\n                  &lt;&lt; std::<span class=\"hljs-built_in\">strerror</span>(errno) &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    }\n\n    <span class=\"hljs-comment\">// for each point in the array</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; num_points; i++) {\n        <span class=\"hljs-comment\">// for each feature in the array</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; num_features; j++) {\n            fp &lt;&lt; X[i][j];               <span class=\"hljs-comment\">// print the feature value</span>\n            <span class=\"hljs-keyword\">if</span> (j &lt; num_features - <span class=\"hljs-number\">1</span>) {  <span class=\"hljs-comment\">// if not the last feature</span>\n                fp &lt;&lt; <span class=\"hljs-string\">&quot;,&quot;</span>;               <span class=\"hljs-comment\">// suffix comma</span>\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_points - <span class=\"hljs-number\">1</span>) {  <span class=\"hljs-comment\">// if not the last row</span>\n            fp &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;            <span class=\"hljs-comment\">// start a new line</span>\n        }\n    }\n\n    fp.<span class=\"hljs-built_in\">close</span>();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * Get minimum value and index of the value in a matrix\n * \\param[in] X matrix to search\n * \\param[in] N number of points in the vector\n * \\param[out] val minimum value found\n * \\param[out] idx_x x-index where minimum value was found\n * \\param[out] idx_y y-index where minimum value was found\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">get_min_2d</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; &amp;X, <span class=\"hljs-type\">double</span> *val,\n                <span class=\"hljs-type\">int</span> *x_idx, <span class=\"hljs-type\">int</span> *y_idx)</span> </span>{\n    val[<span class=\"hljs-number\">0</span>] = INFINITY;  <span class=\"hljs-comment\">// initial min value</span>\n    <span class=\"hljs-type\">size_t</span> N = X.<span class=\"hljs-built_in\">size</span>();\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {  <span class=\"hljs-comment\">// traverse each x-index</span>\n        <span class=\"hljs-keyword\">auto</span> result = std::<span class=\"hljs-built_in\">min_element</span>(std::<span class=\"hljs-built_in\">begin</span>(X[i]), std::<span class=\"hljs-built_in\">end</span>(X[i]));\n        <span class=\"hljs-type\">double</span> d_min = *result;\n        std::<span class=\"hljs-type\">ptrdiff_t</span> j = std::<span class=\"hljs-built_in\">distance</span>(std::<span class=\"hljs-built_in\">begin</span>(X[i]), result);\n\n        <span class=\"hljs-keyword\">if</span> (d_min &lt; val[<span class=\"hljs-number\">0</span>]) {  <span class=\"hljs-comment\">// if a lower value is found</span>\n                               <span class=\"hljs-comment\">// save the value and its index</span>\n            x_idx[<span class=\"hljs-number\">0</span>] = i;\n            y_idx[<span class=\"hljs-number\">0</span>] = j;\n            val[<span class=\"hljs-number\">0</span>] = d_min;\n        }\n    }\n}\n\n<span class=\"hljs-comment\">/** \\namespace machine_learning\n * \\brief Machine learning algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> machine_learning {\n<span class=\"hljs-comment\">/** Minimum average distance of image nodes */</span>\n<span class=\"hljs-keyword\">constexpr</span> <span class=\"hljs-type\">double</span> MIN_DISTANCE = <span class=\"hljs-number\">1e-4</span>;\n\n<span class=\"hljs-comment\">/**\n * Create the distance matrix or\n * [U-matrix](https://en.wikipedia.org/wiki/U-matrix) from the trained\n * 3D weiths matrix and save to disk.\n *\n * \\param [in] fname filename to save in (gets overwriten without\n * confirmation)\n * \\param [in] W model matrix to save\n * \\returns 0 if all ok\n * \\returns -1 if file creation failed\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">save_u_matrix</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fname,\n                  <span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;&gt; &amp;W)</span> </span>{\n    <span class=\"hljs-function\">std::ofstream <span class=\"hljs-title\">fp</span><span class=\"hljs-params\">(fname)</span></span>;\n    <span class=\"hljs-keyword\">if</span> (!fp) {  <span class=\"hljs-comment\">// error with fopen</span>\n        std::cerr &lt;&lt; <span class=\"hljs-string\">&quot;File error (&quot;</span> &lt;&lt; fname &lt;&lt; <span class=\"hljs-string\">&quot;): &quot;</span> &lt;&lt; std::<span class=\"hljs-built_in\">strerror</span>(errno)\n                  &lt;&lt; std::endl;\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    }\n\n    <span class=\"hljs-comment\">// neighborhood range</span>\n    <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> R = <span class=\"hljs-number\">1</span>;\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; W.<span class=\"hljs-built_in\">size</span>(); i++) {         <span class=\"hljs-comment\">// for each x</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; W[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>(); j++) {  <span class=\"hljs-comment\">// for each y</span>\n            <span class=\"hljs-type\">double</span> distance = <span class=\"hljs-number\">0.f</span>;\n\n            <span class=\"hljs-type\">int</span> from_x = std::<span class=\"hljs-built_in\">max</span>&lt;<span class=\"hljs-type\">int</span>&gt;(<span class=\"hljs-number\">0</span>, i - R);\n            <span class=\"hljs-type\">int</span> to_x = std::<span class=\"hljs-built_in\">min</span>&lt;<span class=\"hljs-type\">int</span>&gt;(W.<span class=\"hljs-built_in\">size</span>(), i + R + <span class=\"hljs-number\">1</span>);\n            <span class=\"hljs-type\">int</span> from_y = std::<span class=\"hljs-built_in\">max</span>&lt;<span class=\"hljs-type\">int</span>&gt;(<span class=\"hljs-number\">0</span>, j - R);\n            <span class=\"hljs-type\">int</span> to_y = std::<span class=\"hljs-built_in\">min</span>&lt;<span class=\"hljs-type\">int</span>&gt;(W[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>(), j + R + <span class=\"hljs-number\">1</span>);\n            <span class=\"hljs-type\">int</span> l = <span class=\"hljs-number\">0</span>, m = <span class=\"hljs-number\">0</span>;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp parallel for reduction(+ : distance)</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n            <span class=\"hljs-keyword\">for</span> (l = from_x; l &lt; to_x; l++) {      <span class=\"hljs-comment\">// scan neighborhoor in x</span>\n                <span class=\"hljs-keyword\">for</span> (m = from_y; m &lt; to_y; m++) {  <span class=\"hljs-comment\">// scan neighborhood in y</span>\n                    <span class=\"hljs-keyword\">auto</span> d = W[i][j] - W[l][m];\n                    <span class=\"hljs-type\">double</span> d2 = std::<span class=\"hljs-built_in\">pow</span>(d, <span class=\"hljs-number\">2</span>).<span class=\"hljs-built_in\">sum</span>();\n                    distance += std::<span class=\"hljs-built_in\">sqrt</span>(d2);\n                    <span class=\"hljs-comment\">// distance += d2;</span>\n                }\n            }\n\n            distance /= R * R;          <span class=\"hljs-comment\">// mean distance from neighbors</span>\n            fp &lt;&lt; distance;             <span class=\"hljs-comment\">// print the mean separation</span>\n            <span class=\"hljs-keyword\">if</span> (j &lt; W[<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>) {  <span class=\"hljs-comment\">// if not the last column</span>\n                fp &lt;&lt; <span class=\"hljs-string\">&#x27;,&#x27;</span>;              <span class=\"hljs-comment\">// suffix comma</span>\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> (i &lt; W.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>) {  <span class=\"hljs-comment\">// if not the last row</span>\n            fp &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;          <span class=\"hljs-comment\">// start a new line</span>\n        }\n    }\n\n    fp.<span class=\"hljs-built_in\">close</span>();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * Update weights of the SOM using Kohonen algorithm\n *\n * \\param[in] X data point - N features\n * \\param[in,out] W weights matrix - PxQxN\n * \\param[in,out] D temporary vector to store distances PxQ\n * \\param[in] alpha learning rate \\f$0&lt;\\alpha\\le1\\f$\n * \\param[in] R neighborhood range\n * \\returns minimum distance of sample and trained weights\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">update_weights</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::valarray&lt;<span class=\"hljs-type\">double</span>&gt; &amp;X,\n                      std::vector&lt;std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;&gt; *W,\n                      std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *D, <span class=\"hljs-type\">double</span> alpha,\n                      <span class=\"hljs-type\">int</span> R)</span> </span>{\n    <span class=\"hljs-type\">int</span> x = <span class=\"hljs-number\">0</span>, y = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">int</span> num_out_x = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(W-&gt;<span class=\"hljs-built_in\">size</span>());       <span class=\"hljs-comment\">// output nodes - in X</span>\n    <span class=\"hljs-type\">int</span> num_out_y = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(W[<span class=\"hljs-number\">0</span>][<span class=\"hljs-number\">0</span>].<span class=\"hljs-built_in\">size</span>());  <span class=\"hljs-comment\">// output nodes - in Y</span>\n    <span class=\"hljs-comment\">// int num_features = static_cast&lt;int&gt;(W[0][0][0].size());  //  features =</span>\n    <span class=\"hljs-comment\">// in Z</span>\n    <span class=\"hljs-type\">double</span> d_min = <span class=\"hljs-number\">0.f</span>;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-comment\">// step 1: for each output point</span>\n    <span class=\"hljs-keyword\">for</span> (x = <span class=\"hljs-number\">0</span>; x &lt; num_out_x; x++) {\n        <span class=\"hljs-keyword\">for</span> (y = <span class=\"hljs-number\">0</span>; y &lt; num_out_y; y++) {\n            (*D)[x][y] = <span class=\"hljs-number\">0.f</span>;\n            <span class=\"hljs-comment\">// compute Euclidian distance of each output</span>\n            <span class=\"hljs-comment\">// point from the current sample</span>\n            <span class=\"hljs-keyword\">auto</span> d = ((*W)[x][y] - X);\n            (*D)[x][y] = (d * d).<span class=\"hljs-built_in\">sum</span>();\n            (*D)[x][y] = std::<span class=\"hljs-built_in\">sqrt</span>((*D)[x][y]);\n        }\n    }\n\n    <span class=\"hljs-comment\">// step 2:  get closest node i.e., node with snallest Euclidian distance</span>\n    <span class=\"hljs-comment\">// to the current pattern</span>\n    <span class=\"hljs-type\">int</span> d_min_x = <span class=\"hljs-number\">0</span>, d_min_y = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-built_in\">get_min_2d</span>(*D, &amp;d_min, &amp;d_min_x, &amp;d_min_y);\n\n    <span class=\"hljs-comment\">// step 3a: get the neighborhood range</span>\n    <span class=\"hljs-type\">int</span> from_x = std::<span class=\"hljs-built_in\">max</span>(<span class=\"hljs-number\">0</span>, d_min_x - R);\n    <span class=\"hljs-type\">int</span> to_x = std::<span class=\"hljs-built_in\">min</span>(num_out_x, d_min_x + R + <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-type\">int</span> from_y = std::<span class=\"hljs-built_in\">max</span>(<span class=\"hljs-number\">0</span>, d_min_y - R);\n    <span class=\"hljs-type\">int</span> to_y = std::<span class=\"hljs-built_in\">min</span>(num_out_y, d_min_y + R + <span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-comment\">// step 3b: update the weights of nodes in the</span>\n    <span class=\"hljs-comment\">// neighborhood</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (x = from_x; x &lt; to_x; x++) {\n        <span class=\"hljs-keyword\">for</span> (y = from_y; y &lt; to_y; y++) {\n            <span class=\"hljs-comment\">/* you can enable the following normalization if needed.\n   personally, I found it detrimental to convergence */</span>\n            <span class=\"hljs-comment\">// const double s2pi = sqrt(2.f * M_PI);</span>\n            <span class=\"hljs-comment\">// double normalize = 1.f / (alpha * s2pi);</span>\n\n            <span class=\"hljs-comment\">/* apply scaling inversely proportional to distance from the\n               current node */</span>\n            <span class=\"hljs-type\">double</span> d2 =\n                (d_min_x - x) * (d_min_x - x) + (d_min_y - y) * (d_min_y - y);\n            <span class=\"hljs-type\">double</span> scale_factor = std::<span class=\"hljs-built_in\">exp</span>(-d2 / (<span class=\"hljs-number\">2.f</span> * alpha * alpha));\n\n            (*W)[x][y] += (X - (*W)[x][y]) * alpha * scale_factor;\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> d_min;\n}\n\n<span class=\"hljs-comment\">/**\n * Apply incremental algorithm with updating neighborhood and learning\n * rates on all samples in the given datset.\n *\n * \\param[in] X data set\n * \\param[in,out] W weights matrix\n * \\param[in] alpha_min terminal value of alpha\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">kohonen_som</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; &amp;X,\n                 std::vector&lt;std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;&gt; *W,\n                 <span class=\"hljs-type\">double</span> alpha_min)</span> </span>{\n    <span class=\"hljs-type\">size_t</span> num_samples = X.<span class=\"hljs-built_in\">size</span>();  <span class=\"hljs-comment\">// number of rows</span>\n    <span class=\"hljs-comment\">// size_t num_features = X[0].size();  // number of columns</span>\n    <span class=\"hljs-type\">size_t</span> num_out = W-&gt;<span class=\"hljs-built_in\">size</span>();  <span class=\"hljs-comment\">// output matrix size</span>\n    <span class=\"hljs-type\">size_t</span> R = num_out &gt;&gt; <span class=\"hljs-number\">2</span>, iter = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">double</span> alpha = <span class=\"hljs-number\">1.f</span>;\n\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">D</span>(num_out);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; num_out; i++) D[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(num_out);\n\n    <span class=\"hljs-type\">double</span> dmin = <span class=\"hljs-number\">1.f</span>;        <span class=\"hljs-comment\">// average minimum distance of all samples</span>\n    <span class=\"hljs-type\">double</span> past_dmin = <span class=\"hljs-number\">1.f</span>;   <span class=\"hljs-comment\">// average minimum distance of all samples</span>\n    <span class=\"hljs-type\">double</span> dmin_ratio = <span class=\"hljs-number\">1.f</span>;  <span class=\"hljs-comment\">// change per step</span>\n\n    <span class=\"hljs-comment\">// Loop alpha from 1 to slpha_min</span>\n    <span class=\"hljs-keyword\">for</span> (; alpha &gt; <span class=\"hljs-number\">0</span> &amp;&amp; dmin_ratio &gt; <span class=\"hljs-number\">1e-5</span>; alpha -= <span class=\"hljs-number\">1e-4</span>, iter++) {\n        <span class=\"hljs-comment\">// Loop for each sample pattern in the data set</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> sample = <span class=\"hljs-number\">0</span>; sample &lt; num_samples; sample++) {\n            <span class=\"hljs-comment\">// update weights for the current input pattern sample</span>\n            dmin += <span class=\"hljs-built_in\">update_weights</span>(X[sample], W, &amp;D, alpha, R);\n        }\n\n        <span class=\"hljs-comment\">// every 100th iteration, reduce the neighborhood range</span>\n        <span class=\"hljs-keyword\">if</span> (iter % <span class=\"hljs-number\">300</span> == <span class=\"hljs-number\">0</span> &amp;&amp; R &gt; <span class=\"hljs-number\">1</span>) {\n            R--;\n        }\n\n        dmin /= num_samples;\n\n        <span class=\"hljs-comment\">// termination condition variable -&gt; % change in minimum distance</span>\n        dmin_ratio = (past_dmin - dmin) / past_dmin;\n        <span class=\"hljs-keyword\">if</span> (dmin_ratio &lt; <span class=\"hljs-number\">0</span>) {\n            dmin_ratio = <span class=\"hljs-number\">1.f</span>;\n        }\n        past_dmin = dmin;\n\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;iter: &quot;</span> &lt;&lt; iter &lt;&lt; <span class=\"hljs-string\">&quot;\\t alpha: &quot;</span> &lt;&lt; alpha &lt;&lt; <span class=\"hljs-string\">&quot;\\t R: &quot;</span> &lt;&lt; R\n                  &lt;&lt; <span class=\"hljs-string\">&quot;\\t d_min: &quot;</span> &lt;&lt; dmin_ratio &lt;&lt; <span class=\"hljs-string\">&quot;\\r&quot;</span>;\n    }\n\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;\n}\n\n}  <span class=\"hljs-comment\">// namespace machine_learning</span>\n\n<span class=\"hljs-keyword\">using</span> machine_learning::kohonen_som;\n<span class=\"hljs-keyword\">using</span> machine_learning::save_u_matrix;\n\n<span class=\"hljs-comment\">/** @} */</span>\n\n<span class=\"hljs-comment\">/** Creates a random set of points distributed in four clusters in\n * 3D space with centroids at the points\n * * \\f$(0,5, 0.5, 0.5)\\f$\n * * \\f$(0,5,-0.5, -0.5)\\f$\n * * \\f$(-0,5, 0.5, 0.5)\\f$\n * * \\f$(-0,5,-0.5, -0.5)\\f$\n *\n * \\param[out] data matrix to store data in\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_2d_classes</span><span class=\"hljs-params\">(std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *data)</span> </span>{\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> N = data-&gt;<span class=\"hljs-built_in\">size</span>();\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.3</span>;  <span class=\"hljs-comment\">// radius of cluster</span>\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> num_classes = <span class=\"hljs-number\">4</span>;\n    std::array&lt;std::array&lt;<span class=\"hljs-type\">double</span>, 2&gt;, num_classes&gt; centres = {\n        <span class=\"hljs-comment\">// centres of each class cluster</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">2</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>}),   <span class=\"hljs-comment\">// centre of class 1</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">2</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>}),  <span class=\"hljs-comment\">// centre of class 2</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">2</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>}),  <span class=\"hljs-comment\">// centre of class 3</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">2</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>})  <span class=\"hljs-comment\">// centre of class 4</span>\n    };\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n        <span class=\"hljs-comment\">// select a random class for the point</span>\n        <span class=\"hljs-type\">int</span> cls = std::<span class=\"hljs-built_in\">rand</span>() % num_classes;\n\n        <span class=\"hljs-comment\">// create random coordinates (x,y,z) around the centre of the class</span>\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">0</span>] = _random(centres[cls][<span class=\"hljs-number\">0</span>] - R, centres[cls][<span class=\"hljs-number\">0</span>] + R);\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">1</span>] = _random(centres[cls][<span class=\"hljs-number\">1</span>] - R, centres[cls][<span class=\"hljs-number\">1</span>] + R);\n\n        <span class=\"hljs-comment\">/* The follosing can also be used\n        for (int j = 0; j &lt; 2; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */</span>\n    }\n}\n\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed in four clusters in\n * circumference of a circle and trains an SOM that finds that circular pattern.\n * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)\n * files are created to validate the execution:\n * * `test1.csv`: random test samples points with a circular pattern\n * * `w11.csv`: initial random map\n * * `w12.csv`: trained SOM map\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>, N = <span class=\"hljs-number\">300</span>;\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">30</span>;\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">X</span>(N);\n    std::vector&lt;std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">W</span>(num_out);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; std::<span class=\"hljs-built_in\">max</span>(num_out, N); i++) {\n        <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\n        <span class=\"hljs-keyword\">if</span> (i &lt; N) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\n            X[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\n        }\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\n            W[i] = std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;(num_out);\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; num_out; k++) {\n                W[i][k] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n                <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) {\n                    <span class=\"hljs-comment\">// preallocate with random initial weights</span>\n                    W[i][k][j] = _random(<span class=\"hljs-number\">-10</span>, <span class=\"hljs-number\">10</span>);\n                }\n            }\n        }\n    }\n\n    <span class=\"hljs-built_in\">test_2d_classes</span>(&amp;X);  <span class=\"hljs-comment\">// create test data around circumference of a circle</span>\n    <span class=\"hljs-built_in\">save_2d_data</span>(<span class=\"hljs-string\">&quot;test1.csv&quot;</span>, X);  <span class=\"hljs-comment\">// save test data points</span>\n    <span class=\"hljs-built_in\">save_u_matrix</span>(<span class=\"hljs-string\">&quot;w11.csv&quot;</span>, W);   <span class=\"hljs-comment\">// save initial random weights</span>\n    <span class=\"hljs-built_in\">kohonen_som</span>(X, &amp;W, <span class=\"hljs-number\">1e-4</span>);      <span class=\"hljs-comment\">// train the SOM</span>\n    <span class=\"hljs-built_in\">save_u_matrix</span>(<span class=\"hljs-string\">&quot;w12.csv&quot;</span>, W);   <span class=\"hljs-comment\">// save the resultant weights</span>\n}\n\n<span class=\"hljs-comment\">/** Creates a random set of points distributed in four clusters in\n * 3D space with centroids at the points\n * * \\f$(0,5, 0.5, 0.5)\\f$\n * * \\f$(0,5,-0.5, -0.5)\\f$\n * * \\f$(-0,5, 0.5, 0.5)\\f$\n * * \\f$(-0,5,-0.5, -0.5)\\f$\n *\n * \\param[out] data matrix to store data in\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_3d_classes1</span><span class=\"hljs-params\">(std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *data)</span> </span>{\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">size_t</span> N = data-&gt;<span class=\"hljs-built_in\">size</span>();\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.3</span>;  <span class=\"hljs-comment\">// radius of cluster</span>\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> num_classes = <span class=\"hljs-number\">4</span>;\n    <span class=\"hljs-type\">const</span> std::array&lt;std::array&lt;<span class=\"hljs-type\">double</span>, 3&gt;, num_classes&gt; centres = {\n        <span class=\"hljs-comment\">// centres of each class cluster</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>}),    <span class=\"hljs-comment\">// centre of class 1</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>}),  <span class=\"hljs-comment\">// centre of class 2</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>}),   <span class=\"hljs-comment\">// centre of class 3</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span> - <span class=\"hljs-number\">.5</span>})  <span class=\"hljs-comment\">// centre of class 4</span>\n    };\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n        <span class=\"hljs-comment\">// select a random class for the point</span>\n        <span class=\"hljs-type\">int</span> cls = std::<span class=\"hljs-built_in\">rand</span>() % num_classes;\n\n        <span class=\"hljs-comment\">// create random coordinates (x,y,z) around the centre of the class</span>\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">0</span>] = _random(centres[cls][<span class=\"hljs-number\">0</span>] - R, centres[cls][<span class=\"hljs-number\">0</span>] + R);\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">1</span>] = _random(centres[cls][<span class=\"hljs-number\">1</span>] - R, centres[cls][<span class=\"hljs-number\">1</span>] + R);\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">2</span>] = _random(centres[cls][<span class=\"hljs-number\">2</span>] - R, centres[cls][<span class=\"hljs-number\">2</span>] + R);\n\n        <span class=\"hljs-comment\">/* The follosing can also be used\n        for (int j = 0; j &lt; 3; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */</span>\n    }\n}\n\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed in 4 clusters in\n * 3D space and trains an SOM that finds the topological pattern. The following\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\n * to validate the execution:\n * * `test2.csv`: random test samples points with a lamniscate pattern\n * * `w21.csv`: initial random map\n * * `w22.csv`: trained SOM map\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>, N = <span class=\"hljs-number\">300</span>;\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">3</span>;\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">30</span>;\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">X</span>(N);\n    std::vector&lt;std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">W</span>(num_out);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; std::<span class=\"hljs-built_in\">max</span>(num_out, N); i++) {\n        <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\n        <span class=\"hljs-keyword\">if</span> (i &lt; N) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\n            X[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\n        }\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\n            W[i] = std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;(num_out);\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; num_out; k++) {\n                W[i][k] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n                <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) {\n                    <span class=\"hljs-comment\">// preallocate with random initial weights</span>\n                    W[i][k][j] = _random(<span class=\"hljs-number\">-10</span>, <span class=\"hljs-number\">10</span>);\n                }\n            }\n        }\n    }\n\n    <span class=\"hljs-built_in\">test_3d_classes1</span>(&amp;X);  <span class=\"hljs-comment\">// create test data around circumference of a circle</span>\n    <span class=\"hljs-built_in\">save_2d_data</span>(<span class=\"hljs-string\">&quot;test2.csv&quot;</span>, X);  <span class=\"hljs-comment\">// save test data points</span>\n    <span class=\"hljs-built_in\">save_u_matrix</span>(<span class=\"hljs-string\">&quot;w21.csv&quot;</span>, W);   <span class=\"hljs-comment\">// save initial random weights</span>\n    <span class=\"hljs-built_in\">kohonen_som</span>(X, &amp;W, <span class=\"hljs-number\">1e-4</span>);      <span class=\"hljs-comment\">// train the SOM</span>\n    <span class=\"hljs-built_in\">save_u_matrix</span>(<span class=\"hljs-string\">&quot;w22.csv&quot;</span>, W);   <span class=\"hljs-comment\">// save the resultant weights</span>\n}\n\n<span class=\"hljs-comment\">/** Creates a random set of points distributed in four clusters in\n * 3D space with centroids at the points\n * * \\f$(0,5, 0.5, 0.5)\\f$\n * * \\f$(0,5,-0.5, -0.5)\\f$\n * * \\f$(-0,5, 0.5, 0.5)\\f$\n * * \\f$(-0,5,-0.5, -0.5)\\f$\n *\n * \\param[out] data matrix to store data in\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_3d_classes2</span><span class=\"hljs-params\">(std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; *data)</span> </span>{\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">size_t</span> N = data-&gt;<span class=\"hljs-built_in\">size</span>();\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.2</span>;  <span class=\"hljs-comment\">// radius of cluster</span>\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> num_classes = <span class=\"hljs-number\">8</span>;\n    <span class=\"hljs-type\">const</span> std::array&lt;std::array&lt;<span class=\"hljs-type\">double</span>, 3&gt;, num_classes&gt; centres = {\n        <span class=\"hljs-comment\">// centres of each class cluster</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>}),    <span class=\"hljs-comment\">// centre of class 1</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>}),   <span class=\"hljs-comment\">// centre of class 2</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>}),   <span class=\"hljs-comment\">// centre of class 3</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>}),  <span class=\"hljs-comment\">// centre of class 4</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>}),   <span class=\"hljs-comment\">// centre of class 5</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>}),  <span class=\"hljs-comment\">// centre of class 6</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>}),  <span class=\"hljs-comment\">// centre of class 7</span>\n        std::<span class=\"hljs-built_in\">array</span>&lt;<span class=\"hljs-type\">double</span>, <span class=\"hljs-number\">3</span>&gt;({<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>})  <span class=\"hljs-comment\">// centre of class 8</span>\n    };\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) {\n        <span class=\"hljs-comment\">// select a random class for the point</span>\n        <span class=\"hljs-type\">int</span> cls = std::<span class=\"hljs-built_in\">rand</span>() % num_classes;\n\n        <span class=\"hljs-comment\">// create random coordinates (x,y,z) around the centre of the class</span>\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">0</span>] = _random(centres[cls][<span class=\"hljs-number\">0</span>] - R, centres[cls][<span class=\"hljs-number\">0</span>] + R);\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">1</span>] = _random(centres[cls][<span class=\"hljs-number\">1</span>] - R, centres[cls][<span class=\"hljs-number\">1</span>] + R);\n        data[<span class=\"hljs-number\">0</span>][i][<span class=\"hljs-number\">2</span>] = _random(centres[cls][<span class=\"hljs-number\">2</span>] - R, centres[cls][<span class=\"hljs-number\">2</span>] + R);\n\n        <span class=\"hljs-comment\">/* The follosing can also be used\n        for (int j = 0; j &lt; 3; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */</span>\n    }\n}\n\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed in eight clusters in\n * 3D space and trains an SOM that finds the topological pattern. The following\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\n * to validate the execution:\n * * `test3.csv`: random test samples points with a circular pattern\n * * `w31.csv`: initial random map\n * * `w32.csv`: trained SOM map\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test3</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>, N = <span class=\"hljs-number\">500</span>;\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">3</span>;\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">30</span>;\n    std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt; <span class=\"hljs-built_in\">X</span>(N);\n    std::vector&lt;std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;&gt; <span class=\"hljs-built_in\">W</span>(num_out);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; std::<span class=\"hljs-built_in\">max</span>(num_out, N); i++) {\n        <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\n        <span class=\"hljs-keyword\">if</span> (i &lt; N) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\n            X[i] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\n        }\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out) {  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\n            W[i] = std::vector&lt;std::valarray&lt;<span class=\"hljs-type\">double</span>&gt;&gt;(num_out);\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; num_out; k++) {\n                W[i][k] = std::<span class=\"hljs-built_in\">valarray</span>&lt;<span class=\"hljs-type\">double</span>&gt;(features);\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n                <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++) {\n                    <span class=\"hljs-comment\">// preallocate with random initial weights</span>\n                    W[i][k][j] = _random(<span class=\"hljs-number\">-10</span>, <span class=\"hljs-number\">10</span>);\n                }\n            }\n        }\n    }\n\n    <span class=\"hljs-built_in\">test_3d_classes2</span>(&amp;X);  <span class=\"hljs-comment\">// create test data around circumference of a circle</span>\n    <span class=\"hljs-built_in\">save_2d_data</span>(<span class=\"hljs-string\">&quot;test3.csv&quot;</span>, X);  <span class=\"hljs-comment\">// save test data points</span>\n    <span class=\"hljs-built_in\">save_u_matrix</span>(<span class=\"hljs-string\">&quot;w31.csv&quot;</span>, W);   <span class=\"hljs-comment\">// save initial random weights</span>\n    <span class=\"hljs-built_in\">kohonen_som</span>(X, &amp;W, <span class=\"hljs-number\">1e-4</span>);      <span class=\"hljs-comment\">// train the SOM</span>\n    <span class=\"hljs-built_in\">save_u_matrix</span>(<span class=\"hljs-string\">&quot;w32.csv&quot;</span>, W);   <span class=\"hljs-comment\">// save the resultant weights</span>\n}\n\n<span class=\"hljs-comment\">/**\n * Convert clock cycle difference to time in seconds\n *\n * \\param[in] start_t start clock\n * \\param[in] end_t end clock\n * \\returns time difference in seconds\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">double</span> <span class=\"hljs-title\">get_clock_diff</span><span class=\"hljs-params\">(<span class=\"hljs-type\">clock_t</span> <span class=\"hljs-type\">start_t</span>, <span class=\"hljs-type\">clock_t</span> <span class=\"hljs-type\">end_t</span>)</span> </span>{\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">double</span>&gt;(<span class=\"hljs-type\">end_t</span> - <span class=\"hljs-type\">start_t</span>) / CLOCKS_PER_SEC;\n}\n\n<span class=\"hljs-comment\">/** Main function */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span> </span>{\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Using OpenMP based parallelization\\n&quot;</span>;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;NOT using OpenMP based parallelization\\n&quot;</span>;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n    std::<span class=\"hljs-built_in\">srand</span>(std::<span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">nullptr</span>));\n\n    std::<span class=\"hljs-type\">clock_t</span> start_clk = std::<span class=\"hljs-built_in\">clock</span>();\n    <span class=\"hljs-built_in\">test1</span>();\n    <span class=\"hljs-keyword\">auto</span> end_clk = std::<span class=\"hljs-built_in\">clock</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 1 completed in &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">get_clock_diff</span>(start_clk, end_clk)\n              &lt;&lt; <span class=\"hljs-string\">&quot; sec\\n&quot;</span>;\n\n    start_clk = std::<span class=\"hljs-built_in\">clock</span>();\n    <span class=\"hljs-built_in\">test2</span>();\n    end_clk = std::<span class=\"hljs-built_in\">clock</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 2 completed in &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">get_clock_diff</span>(start_clk, end_clk)\n              &lt;&lt; <span class=\"hljs-string\">&quot; sec\\n&quot;</span>;\n\n    start_clk = std::<span class=\"hljs-built_in\">clock</span>();\n    <span class=\"hljs-built_in\">test3</span>();\n    end_clk = std::<span class=\"hljs-built_in\">clock</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Test 3 completed in &quot;</span> &lt;&lt; <span class=\"hljs-built_in\">get_clock_diff</span>(start_clk, end_clk)\n              &lt;&lt; <span class=\"hljs-string\">&quot; sec\\n&quot;</span>;\n\n    std::cout\n        &lt;&lt; <span class=\"hljs-string\">&quot;(Note: Calculated times include: creating test sets, training &quot;</span>\n           <span class=\"hljs-string\">&quot;model and writing files to disk.)\\n\\n&quot;</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "c": {
      "dir": "machine_learning/kohonen_som_topology.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/machine_learning/kohonen_som_topology.c",
      "code": "<span class=\"hljs-comment\">/**\n * \\file\n * \\brief [Kohonen self organizing\n * map](https://en.wikipedia.org/wiki/Self-organizing_map) (topological map)\n *\n * This example implements a powerful unsupervised learning algorithm called as\n * a self organizing map. The algorithm creates a connected network of weights\n * that closely follows the given data points. This thus creates a topological\n * map of the given data i.e., it maintains the relationship between various\n * data points in a much higher dimensional space by creating an equivalent in a\n * 2-dimensional space.\n * &lt;img alt=&quot;Trained topological maps for the test cases in the program&quot;\n * src=&quot;https://raw.githubusercontent.com/TheAlgorithms/C/docs/images/machine_learning/kohonen/2D_Kohonen_SOM.svg&quot;\n * /&gt;\n * \\author [Krishna Vedala](https://github.com/kvedala)\n * \\warning MSVC 2019 compiler generates code that does not execute as expected.\n * However, MinGW, Clang for GCC and Clang for MSVC compilers on windows perform\n * as expected. Any insights and suggestions should be directed to the author.\n * \\see kohonen_som_trace.c\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> _USE_MATH_DEFINES <span class=\"hljs-comment\">/**&lt; required for MS Visual C */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;math.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;time.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP  <span class=\"hljs-comment\">// check if OpenMP based parallellization is available</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;omp.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n<span class=\"hljs-comment\">/**\n * @addtogroup machine_learning Machine learning algorithms\n * @{\n * @addtogroup kohonen_2d Kohonen SOM topology algorithm\n * @{\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> max</span>\n<span class=\"hljs-comment\">/** shorthand for maximum value */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> max(a, b) (((a) &gt; (b)) ? (a) : (b))</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifndef</span> min</span>\n<span class=\"hljs-comment\">/** shorthand for minimum value */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> min(a, b) (((a) &lt; (b)) ? (a) : (b))</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n<span class=\"hljs-comment\">/** to store info regarding 3D arrays */</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">kohonen_array_3d</span>\n{</span>\n    <span class=\"hljs-type\">int</span> dim1;     <span class=\"hljs-comment\">/**&lt; lengths of first dimension */</span>\n    <span class=\"hljs-type\">int</span> dim2;     <span class=\"hljs-comment\">/**&lt; lengths of second dimension */</span>\n    <span class=\"hljs-type\">int</span> dim3;     <span class=\"hljs-comment\">/**&lt; lengths of thirddimension */</span>\n    <span class=\"hljs-type\">double</span> *data; <span class=\"hljs-comment\">/**&lt; pointer to data */</span>\n};\n\n<span class=\"hljs-comment\">/** Function that returns the pointer to (x, y, z) ^th location in the\n * linear 3D array given by:\n * \\f[\n * X_{i,j,k} = i\\times M\\times N + j\\times N + k\n * \\f]\n * where \\f$L\\f$, \\f$M\\f$ and \\f$N\\f$ are the 3D matrix dimensions.\n * \\param[in] arr pointer to ::kohonen_array_3d structure\n * \\param[in] x     first index\n * \\param[in] y     second index\n * \\param[in] z     third index\n * \\returns pointer to (x,y,z)^th location of data\n */</span>\n<span class=\"hljs-type\">double</span> *<span class=\"hljs-title function_\">kohonen_data_3d</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">struct</span> kohonen_array_3d *arr, <span class=\"hljs-type\">int</span> x, <span class=\"hljs-type\">int</span> y, <span class=\"hljs-type\">int</span> z)</span>\n{\n    <span class=\"hljs-type\">int</span> offset = (x * arr-&gt;dim2 * arr-&gt;dim3) + (y * arr-&gt;dim3) + z;\n    <span class=\"hljs-keyword\">return</span> arr-&gt;data + offset;\n}\n\n<span class=\"hljs-comment\">/**\n * Helper function to generate a random number in a given interval.\n * \\n Steps:\n * 1. `r1 = rand() % 100` gets a random number between 0 and 99\n * 2. `r2 = r1 / 100` converts random number to be between 0 and 0.99\n * 3. scale and offset the random number to given range of \\f$[a,b)\\f$\n * \\f[\n * y = (b - a) \\times \\frac{\\text{(random number between 0 and RAND_MAX)} \\;\n * \\text{mod}\\; 100}{100} + a \\f]\n *\n * \\param[in] a lower limit\n * \\param[in] b upper limit\n * \\returns random number in the range \\f$[a,b)\\f$\n */</span>\n<span class=\"hljs-type\">double</span> _random(<span class=\"hljs-type\">double</span> a, <span class=\"hljs-type\">double</span> b)\n{\n    <span class=\"hljs-keyword\">return</span> ((b - a) * (rand() % <span class=\"hljs-number\">100</span>) / <span class=\"hljs-number\">100.f</span>) + a;\n}\n\n<span class=\"hljs-comment\">/**\n * Save a given n-dimensional data martix to file.\n *\n * \\param[in] fname filename to save in (gets overwritten without confirmation)\n * \\param[in] X matrix to save\n * \\param[in] num_points rows in the matrix = number of points\n * \\param[in] num_features columns in the matrix = dimensions of points\n * \\returns 0 if all ok\n * \\returns -1 if file creation failed\n */</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">save_2d_data</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fname, <span class=\"hljs-type\">double</span> **X, <span class=\"hljs-type\">int</span> num_points,\n                 <span class=\"hljs-type\">int</span> num_features)</span>\n{\n    FILE *fp = fopen(fname, <span class=\"hljs-string\">&quot;wt&quot;</span>);\n    <span class=\"hljs-keyword\">if</span> (!fp)  <span class=\"hljs-comment\">// error with fopen</span>\n    {\n        <span class=\"hljs-type\">char</span> msg[<span class=\"hljs-number\">120</span>];\n        <span class=\"hljs-built_in\">sprintf</span>(msg, <span class=\"hljs-string\">&quot;File error (%s): &quot;</span>, fname);\n        perror(msg);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    }\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; num_points; i++)  <span class=\"hljs-comment\">// for each point in the array</span>\n    {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; num_features; j++)  <span class=\"hljs-comment\">// for each feature in the array</span>\n        {\n            <span class=\"hljs-built_in\">fprintf</span>(fp, <span class=\"hljs-string\">&quot;%.4g&quot;</span>, X[i][j]);  <span class=\"hljs-comment\">// print the feature value</span>\n            <span class=\"hljs-keyword\">if</span> (j &lt; num_features - <span class=\"hljs-number\">1</span>)      <span class=\"hljs-comment\">// if not the last feature</span>\n                fputc(<span class=\"hljs-string\">&#x27;,&#x27;</span>, fp);            <span class=\"hljs-comment\">// suffix comma</span>\n        }\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_points - <span class=\"hljs-number\">1</span>)  <span class=\"hljs-comment\">// if not the last row</span>\n            fputc(<span class=\"hljs-string\">&#x27;\\n&#x27;</span>, fp);     <span class=\"hljs-comment\">// start a new line</span>\n    }\n    fclose(fp);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * Create the distance matrix or\n * [U-matrix](https://en.wikipedia.org/wiki/U-matrix) from the trained weights\n * and save to disk.\n *\n * \\param [in] fname filename to save in (gets overwriten without confirmation)\n * \\param [in] W model matrix to save\n * \\returns 0 if all ok\n * \\returns -1 if file creation failed\n */</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">save_u_matrix</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fname, <span class=\"hljs-keyword\">struct</span> kohonen_array_3d *W)</span>\n{\n    FILE *fp = fopen(fname, <span class=\"hljs-string\">&quot;wt&quot;</span>);\n    <span class=\"hljs-keyword\">if</span> (!fp)  <span class=\"hljs-comment\">// error with fopen</span>\n    {\n        <span class=\"hljs-type\">char</span> msg[<span class=\"hljs-number\">120</span>];\n        <span class=\"hljs-built_in\">sprintf</span>(msg, <span class=\"hljs-string\">&quot;File error (%s): &quot;</span>, fname);\n        perror(msg);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;\n    }\n\n    <span class=\"hljs-type\">int</span> R = max(W-&gt;dim1 &gt;&gt; <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>); <span class=\"hljs-comment\">/* neighborhood range */</span>\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; W-&gt;dim1; i++)  <span class=\"hljs-comment\">// for each x</span>\n    {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; W-&gt;dim2; j++)  <span class=\"hljs-comment\">// for each y</span>\n        {\n            <span class=\"hljs-type\">double</span> distance = <span class=\"hljs-number\">0.f</span>;\n            <span class=\"hljs-type\">int</span> k;\n\n            <span class=\"hljs-type\">int</span> from_x = max(<span class=\"hljs-number\">0</span>, i - R);\n            <span class=\"hljs-type\">int</span> to_x = min(W-&gt;dim1, i + R + <span class=\"hljs-number\">1</span>);\n            <span class=\"hljs-type\">int</span> from_y = max(<span class=\"hljs-number\">0</span>, j - R);\n            <span class=\"hljs-type\">int</span> to_y = min(W-&gt;dim2, j + R + <span class=\"hljs-number\">1</span>);\n            <span class=\"hljs-type\">int</span> l;\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp parallel for reduction(+ : distance)</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n            <span class=\"hljs-keyword\">for</span> (l = from_x; l &lt; to_x; l++)  <span class=\"hljs-comment\">// scan neighborhoor in x</span>\n            {\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> m = from_y; m &lt; to_y; m++)  <span class=\"hljs-comment\">// scan neighborhood in y</span>\n                {\n                    <span class=\"hljs-type\">double</span> d = <span class=\"hljs-number\">0.f</span>;\n                    <span class=\"hljs-keyword\">for</span> (k = <span class=\"hljs-number\">0</span>; k &lt; W-&gt;dim3; k++)  <span class=\"hljs-comment\">// for each feature</span>\n                    {\n                        <span class=\"hljs-type\">double</span> *w1 = kohonen_data_3d(W, i, j, k);\n                        <span class=\"hljs-type\">double</span> *w2 = kohonen_data_3d(W, l, m, k);\n                        d += (w1[<span class=\"hljs-number\">0</span>] - w2[<span class=\"hljs-number\">0</span>]) * (w1[<span class=\"hljs-number\">0</span>] - w2[<span class=\"hljs-number\">0</span>]);\n                        <span class=\"hljs-comment\">// distance += w1[0] * w1[0];</span>\n                    }\n                    distance += <span class=\"hljs-built_in\">sqrt</span>(d);\n                    <span class=\"hljs-comment\">// distance += d;</span>\n                }\n            }\n\n            distance /= R * R;              <span class=\"hljs-comment\">// mean distance from neighbors</span>\n            <span class=\"hljs-built_in\">fprintf</span>(fp, <span class=\"hljs-string\">&quot;%.4g&quot;</span>, distance);  <span class=\"hljs-comment\">// print the mean separation</span>\n            <span class=\"hljs-keyword\">if</span> (j &lt; W-&gt;dim2 - <span class=\"hljs-number\">1</span>)            <span class=\"hljs-comment\">// if not the last column</span>\n                fputc(<span class=\"hljs-string\">&#x27;,&#x27;</span>, fp);             <span class=\"hljs-comment\">// suffix comma</span>\n        }\n        <span class=\"hljs-keyword\">if</span> (i &lt; W-&gt;dim1 - <span class=\"hljs-number\">1</span>)  <span class=\"hljs-comment\">// if not the last row</span>\n            fputc(<span class=\"hljs-string\">&#x27;\\n&#x27;</span>, fp);  <span class=\"hljs-comment\">// start a new line</span>\n    }\n    fclose(fp);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-comment\">/**\n * Get minimum value and index of the value in a matrix\n * \\param[in] X matrix to search\n * \\param[in] N number of points in the vector\n * \\param[out] val minimum value found\n * \\param[out] x_idx x-index where minimum value was found\n * \\param[out] y_idx y-index where minimum value was found\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">get_min_2d</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> **X, <span class=\"hljs-type\">int</span> N, <span class=\"hljs-type\">double</span> *val, <span class=\"hljs-type\">int</span> *x_idx, <span class=\"hljs-type\">int</span> *y_idx)</span>\n{\n    val[<span class=\"hljs-number\">0</span>] = INFINITY;  <span class=\"hljs-comment\">// initial min value</span>\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)  <span class=\"hljs-comment\">// traverse each x-index</span>\n    {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j = <span class=\"hljs-number\">0</span>; j &lt; N; j++)  <span class=\"hljs-comment\">// traverse each y-index</span>\n        {\n            <span class=\"hljs-keyword\">if</span> (X[i][j] &lt; val[<span class=\"hljs-number\">0</span>])  <span class=\"hljs-comment\">// if a lower value is found</span>\n            {                      <span class=\"hljs-comment\">// save the value and its index</span>\n                x_idx[<span class=\"hljs-number\">0</span>] = i;\n                y_idx[<span class=\"hljs-number\">0</span>] = j;\n                val[<span class=\"hljs-number\">0</span>] = X[i][j];\n            }\n        }\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * Update weights of the SOM using Kohonen algorithm\n *\n * \\param[in] X data point\n * \\param[in,out] W weights matrix\n * \\param[in,out] D temporary vector to store distances\n * \\param[in] num_out number of output points\n * \\param[in] num_features number of features per input sample\n * \\param[in] alpha learning rate \\f$0&lt;\\alpha\\le1\\f$\n * \\param[in] R neighborhood range\n * \\returns minimum distance of sample and trained weights\n */</span>\n<span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">kohonen_update_weights</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> *X, <span class=\"hljs-keyword\">struct</span> kohonen_array_3d *W,\n                              <span class=\"hljs-type\">double</span> **D, <span class=\"hljs-type\">int</span> num_out, <span class=\"hljs-type\">int</span> num_features,\n                              <span class=\"hljs-type\">double</span> alpha, <span class=\"hljs-type\">int</span> R)</span>\n{\n    <span class=\"hljs-type\">int</span> x, y, k;\n    <span class=\"hljs-type\">double</span> d_min = <span class=\"hljs-number\">0.f</span>;\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-comment\">// step 1: for each 2D output point</span>\n    <span class=\"hljs-keyword\">for</span> (x = <span class=\"hljs-number\">0</span>; x &lt; num_out; x++)\n    {\n        <span class=\"hljs-keyword\">for</span> (y = <span class=\"hljs-number\">0</span>; y &lt; num_out; y++)\n        {\n            D[x][y] = <span class=\"hljs-number\">0.f</span>;\n            <span class=\"hljs-comment\">// compute Euclidian distance of each output</span>\n            <span class=\"hljs-comment\">// point from the current sample</span>\n            <span class=\"hljs-keyword\">for</span> (k = <span class=\"hljs-number\">0</span>; k &lt; num_features; k++)\n            {\n                <span class=\"hljs-type\">double</span> *w = kohonen_data_3d(W, x, y, k);\n                D[x][y] += (w[<span class=\"hljs-number\">0</span>] - X[k]) * (w[<span class=\"hljs-number\">0</span>] - X[k]);\n            }\n            D[x][y] = <span class=\"hljs-built_in\">sqrt</span>(D[x][y]);\n        }\n    }\n\n    <span class=\"hljs-comment\">// step 2:  get closest node i.e., node with smallest Euclidian distance to</span>\n    <span class=\"hljs-comment\">// the current pattern</span>\n    <span class=\"hljs-type\">int</span> d_min_x, d_min_y;\n    get_min_2d(D, num_out, &amp;d_min, &amp;d_min_x, &amp;d_min_y);\n\n    <span class=\"hljs-comment\">// step 3a: get the neighborhood range</span>\n    <span class=\"hljs-type\">int</span> from_x = max(<span class=\"hljs-number\">0</span>, d_min_x - R);\n    <span class=\"hljs-type\">int</span> to_x = min(num_out, d_min_x + R + <span class=\"hljs-number\">1</span>);\n    <span class=\"hljs-type\">int</span> from_y = max(<span class=\"hljs-number\">0</span>, d_min_y - R);\n    <span class=\"hljs-type\">int</span> to_y = min(num_out, d_min_y + R + <span class=\"hljs-number\">1</span>);\n\n    <span class=\"hljs-comment\">// step 3b: update the weights of nodes in the</span>\n    <span class=\"hljs-comment\">// neighborhood</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (x = from_x; x &lt; to_x; x++)\n    {\n        <span class=\"hljs-keyword\">for</span> (y = from_y; y &lt; to_y; y++)\n        {\n            <span class=\"hljs-comment\">/* you can enable the following normalization if needed.\n               personally, I found it detrimental to convergence */</span>\n            <span class=\"hljs-comment\">// const double s2pi = sqrt(2.f * M_PI);</span>\n            <span class=\"hljs-comment\">// double normalize = 1.f / (alpha * s2pi);</span>\n\n            <span class=\"hljs-comment\">/* apply scaling inversely proportional to distance from the\n               current node */</span>\n            <span class=\"hljs-type\">double</span> d2 =\n                (d_min_x - x) * (d_min_x - x) + (d_min_y - y) * (d_min_y - y);\n            <span class=\"hljs-type\">double</span> scale_factor = <span class=\"hljs-built_in\">exp</span>(-d2 / (<span class=\"hljs-number\">2.f</span> * alpha * alpha));\n\n            <span class=\"hljs-keyword\">for</span> (k = <span class=\"hljs-number\">0</span>; k &lt; num_features; k++)\n            {\n                <span class=\"hljs-type\">double</span> *w = kohonen_data_3d(W, x, y, k);\n                <span class=\"hljs-comment\">// update weights of nodes in the neighborhood</span>\n                w[<span class=\"hljs-number\">0</span>] += alpha * scale_factor * (X[k] - w[<span class=\"hljs-number\">0</span>]);\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> d_min;\n}\n\n<span class=\"hljs-comment\">/**\n * Apply incremental algorithm with updating neighborhood and learning rates\n * on all samples in the given datset.\n *\n * \\param[in] X data set\n * \\param[in,out] W weights matrix\n * \\param[in] num_samples number of output points\n * \\param[in] num_features number of features per input sample\n * \\param[in] num_out number of output points\n * \\param[in] alpha_min terminal value of alpha\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">kohonen_som</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> **X, <span class=\"hljs-keyword\">struct</span> kohonen_array_3d *W, <span class=\"hljs-type\">int</span> num_samples,\n                 <span class=\"hljs-type\">int</span> num_features, <span class=\"hljs-type\">int</span> num_out, <span class=\"hljs-type\">double</span> alpha_min)</span>\n{\n    <span class=\"hljs-type\">int</span> R = num_out &gt;&gt; <span class=\"hljs-number\">2</span>, iter = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-type\">double</span> **D = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(num_out * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; num_out; i++)\n        D[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(num_out * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\n\n    <span class=\"hljs-type\">double</span> dmin = <span class=\"hljs-number\">1.f</span>;  <span class=\"hljs-comment\">// average minimum distance of all samples</span>\n\n    <span class=\"hljs-comment\">// Loop alpha from 1 to slpha_min</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">double</span> alpha = <span class=\"hljs-number\">1.f</span>; alpha &gt; alpha_min &amp;&amp; dmin &gt; <span class=\"hljs-number\">1e-3</span>;\n         alpha -= <span class=\"hljs-number\">0.001</span>, iter++)\n    {\n        dmin = <span class=\"hljs-number\">0.f</span>;\n        <span class=\"hljs-comment\">// Loop for each sample pattern in the data set</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> sample = <span class=\"hljs-number\">0</span>; sample &lt; num_samples; sample++)\n        {\n            <span class=\"hljs-comment\">// update weights for the current input pattern sample</span>\n            dmin += kohonen_update_weights(X[sample], W, D, num_out,\n                                           num_features, alpha, R);\n        }\n\n        <span class=\"hljs-comment\">// every 20th iteration, reduce the neighborhood range</span>\n        <span class=\"hljs-keyword\">if</span> (iter % <span class=\"hljs-number\">100</span> == <span class=\"hljs-number\">0</span> &amp;&amp; R &gt; <span class=\"hljs-number\">1</span>)\n            R--;\n\n        dmin /= num_samples;\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;iter: %5d\\t alpha: %.4g\\t R: %d\\td_min: %.4g\\r&quot;</span>, iter, alpha, R,\n               dmin);\n    }\n    <span class=\"hljs-built_in\">putchar</span>(<span class=\"hljs-string\">&#x27;\\n&#x27;</span>);\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; num_out; i++) <span class=\"hljs-built_in\">free</span>(D[i]);\n    <span class=\"hljs-built_in\">free</span>(D);\n}\n\n<span class=\"hljs-comment\">/**\n * @}\n * @}\n */</span>\n\n<span class=\"hljs-comment\">/** Creates a random set of points distributed in four clusters in\n * 3D space with centroids at the points\n * * \\f$(0,5, 0.5, 0.5)\\f$\n * * \\f$(0,5,-0.5, -0.5)\\f$\n * * \\f$(-0,5, 0.5, 0.5)\\f$\n * * \\f$(-0,5,-0.5, -0.5)\\f$\n *\n * \\param[out] data matrix to store data in\n * \\param[in] N number of points required\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test_2d_classes</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> *<span class=\"hljs-type\">const</span> *data, <span class=\"hljs-type\">int</span> N)</span>\n{\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.3</span>;  <span class=\"hljs-comment\">// radius of cluster</span>\n    <span class=\"hljs-type\">int</span> i;\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> num_classes = <span class=\"hljs-number\">4</span>;\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> centres[][<span class=\"hljs-number\">2</span>] = {\n        <span class=\"hljs-comment\">// centres of each class cluster</span>\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>},   <span class=\"hljs-comment\">// centre of class 1</span>\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>},  <span class=\"hljs-comment\">// centre of class 2</span>\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>},  <span class=\"hljs-comment\">// centre of class 3</span>\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>}  <span class=\"hljs-comment\">// centre of class 4</span>\n    };\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\n    {\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> =</span>\n            rand() % num_classes;  <span class=\"hljs-comment\">// select a random class for the point</span>\n\n        <span class=\"hljs-comment\">// create random coordinates (x,y,z) around the centre of the class</span>\n        data[i][<span class=\"hljs-number\">0</span>] = _random(centres[class][<span class=\"hljs-number\">0</span>] - R, centres[class][<span class=\"hljs-number\">0</span>] + R);\n        data[i][<span class=\"hljs-number\">1</span>] = _random(centres[class][<span class=\"hljs-number\">1</span>] - R, centres[class][<span class=\"hljs-number\">1</span>] + R);\n\n        <span class=\"hljs-comment\">/* The follosing can also be used\n        for (int j = 0; j &lt; 2; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */</span>\n    }\n}\n\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed in four clusters in\n * 2D space and trains an SOM that finds the topological pattern.\n * The following [CSV](https://en.wikipedia.org/wiki/Comma-separated_values)\n * files are created to validate the execution:\n * * `test1.csv`: random test samples points with a circular pattern\n * * `w11.csv`: initial random U-matrix\n * * `w12.csv`: trained SOM U-matrix\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test1</span><span class=\"hljs-params\">()</span>\n{\n    <span class=\"hljs-type\">int</span> j, N = <span class=\"hljs-number\">300</span>;\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">2</span>;\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">30</span>;  <span class=\"hljs-comment\">// image size - N x N</span>\n\n    <span class=\"hljs-comment\">// 2D space, hence size = number of rows * 2</span>\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\n\n    <span class=\"hljs-comment\">// cluster nodex in &#x27;x&#x27; * cluster nodes in &#x27;y&#x27; * 2</span>\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">kohonen_array_3d</span> <span class=\"hljs-title\">W</span>;</span>\n    W.dim1 = num_out;\n    W.dim2 = num_out;\n    W.dim3 = features;\n    W.data = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(num_out * num_out * features *\n                              <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));  <span class=\"hljs-comment\">// assign rows</span>\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)  <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\n    {\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\n            X[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\n        {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; num_out; k++)\n            {\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n                <span class=\"hljs-comment\">// preallocate with random initial weights</span>\n                <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++)\n                {\n                    <span class=\"hljs-type\">double</span> *w = kohonen_data_3d(&amp;W, i, k, j);\n                    w[<span class=\"hljs-number\">0</span>] = _random(<span class=\"hljs-number\">-5</span>, <span class=\"hljs-number\">5</span>);\n                }\n            }\n        }\n    }\n\n    test_2d_classes(X, N);  <span class=\"hljs-comment\">// create test data around circumference of a circle</span>\n    save_2d_data(<span class=\"hljs-string\">&quot;test1.csv&quot;</span>, X, N, features);  <span class=\"hljs-comment\">// save test data points</span>\n    save_u_matrix(<span class=\"hljs-string\">&quot;w11.csv&quot;</span>, &amp;W);               <span class=\"hljs-comment\">// save initial random weights</span>\n    kohonen_som(X, &amp;W, N, features, num_out, <span class=\"hljs-number\">1e-4</span>);  <span class=\"hljs-comment\">// train the SOM</span>\n    save_u_matrix(<span class=\"hljs-string\">&quot;w12.csv&quot;</span>, &amp;W);  <span class=\"hljs-comment\">// save the resultant weights</span>\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) <span class=\"hljs-built_in\">free</span>(X[i]);\n    <span class=\"hljs-built_in\">free</span>(X);\n    <span class=\"hljs-built_in\">free</span>(W.data);\n}\n\n<span class=\"hljs-comment\">/** Creates a random set of points distributed in four clusters in\n * 3D space with centroids at the points\n * * \\f$(0,5, 0.5, 0.5)\\f$\n * * \\f$(0,5,-0.5, -0.5)\\f$\n * * \\f$(-0,5, 0.5, 0.5)\\f$\n * * \\f$(-0,5,-0.5, -0.5)\\f$\n *\n * \\param[out] data matrix to store data in\n * \\param[in] N number of points required\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test_3d_classes1</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> *<span class=\"hljs-type\">const</span> *data, <span class=\"hljs-type\">int</span> N)</span>\n{\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.2</span>;  <span class=\"hljs-comment\">// radius of cluster</span>\n    <span class=\"hljs-type\">int</span> i;\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> num_classes = <span class=\"hljs-number\">4</span>;\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> centres[][<span class=\"hljs-number\">3</span>] = {\n        <span class=\"hljs-comment\">// centres of each class cluster</span>\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>},    <span class=\"hljs-comment\">// centre of class 1</span>\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>},  <span class=\"hljs-comment\">// centre of class 2</span>\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>},   <span class=\"hljs-comment\">// centre of class 3</span>\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span> - <span class=\"hljs-number\">.5</span>}  <span class=\"hljs-comment\">// centre of class 4</span>\n    };\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\n    {\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> =</span>\n            rand() % num_classes;  <span class=\"hljs-comment\">// select a random class for the point</span>\n\n        <span class=\"hljs-comment\">// create random coordinates (x,y,z) around the centre of the class</span>\n        data[i][<span class=\"hljs-number\">0</span>] = _random(centres[class][<span class=\"hljs-number\">0</span>] - R, centres[class][<span class=\"hljs-number\">0</span>] + R);\n        data[i][<span class=\"hljs-number\">1</span>] = _random(centres[class][<span class=\"hljs-number\">1</span>] - R, centres[class][<span class=\"hljs-number\">1</span>] + R);\n        data[i][<span class=\"hljs-number\">2</span>] = _random(centres[class][<span class=\"hljs-number\">2</span>] - R, centres[class][<span class=\"hljs-number\">2</span>] + R);\n\n        <span class=\"hljs-comment\">/* The follosing can also be used\n        for (int j = 0; j &lt; 3; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */</span>\n    }\n}\n\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed in 4 clusters in\n * 3D space and trains an SOM that finds the topological pattern. The following\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\n * to validate the execution:\n * * `test2.csv`: random test samples points\n * * `w21.csv`: initial random U-matrix\n * * `w22.csv`: trained SOM U-matrix\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test2</span><span class=\"hljs-params\">()</span>\n{\n    <span class=\"hljs-type\">int</span> j, N = <span class=\"hljs-number\">500</span>;\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">3</span>;\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">30</span>;  <span class=\"hljs-comment\">// image size - N x N</span>\n\n    <span class=\"hljs-comment\">// 3D space, hence size = number of rows * 3</span>\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\n\n    <span class=\"hljs-comment\">// cluster nodex in &#x27;x&#x27; * cluster nodes in &#x27;y&#x27; * 2</span>\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">kohonen_array_3d</span> <span class=\"hljs-title\">W</span>;</span>\n    W.dim1 = num_out;\n    W.dim2 = num_out;\n    W.dim3 = features;\n    W.data = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(num_out * num_out * features *\n                              <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));  <span class=\"hljs-comment\">// assign rows</span>\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)  <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\n    {\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\n            X[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\n        {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; num_out; k++)\n            {\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n                <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++)\n                {  <span class=\"hljs-comment\">// preallocate with random initial weights</span>\n                    <span class=\"hljs-type\">double</span> *w = kohonen_data_3d(&amp;W, i, k, j);\n                    w[<span class=\"hljs-number\">0</span>] = _random(<span class=\"hljs-number\">-5</span>, <span class=\"hljs-number\">5</span>);\n                }\n            }\n        }\n    }\n\n    test_3d_classes1(X, N);                     <span class=\"hljs-comment\">// create test data</span>\n    save_2d_data(<span class=\"hljs-string\">&quot;test2.csv&quot;</span>, X, N, features);  <span class=\"hljs-comment\">// save test data points</span>\n    save_u_matrix(<span class=\"hljs-string\">&quot;w21.csv&quot;</span>, &amp;W);               <span class=\"hljs-comment\">// save initial random weights</span>\n    kohonen_som(X, &amp;W, N, features, num_out, <span class=\"hljs-number\">1e-4</span>);  <span class=\"hljs-comment\">// train the SOM</span>\n    save_u_matrix(<span class=\"hljs-string\">&quot;w22.csv&quot;</span>, &amp;W);  <span class=\"hljs-comment\">// save the resultant weights</span>\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) <span class=\"hljs-built_in\">free</span>(X[i]);\n    <span class=\"hljs-built_in\">free</span>(X);\n    <span class=\"hljs-built_in\">free</span>(W.data);\n}\n\n<span class=\"hljs-comment\">/** Creates a random set of points distributed in four clusters in\n * 3D space with centroids at the points\n * * \\f$(0,5, 0.5, 0.5)\\f$\n * * \\f$(0,5,-0.5, -0.5)\\f$\n * * \\f$(-0,5, 0.5, 0.5)\\f$\n * * \\f$(-0,5,-0.5, -0.5)\\f$\n *\n * \\param[out] data matrix to store data in\n * \\param[in] N number of points required\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test_3d_classes2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">double</span> *<span class=\"hljs-type\">const</span> *data, <span class=\"hljs-type\">int</span> N)</span>\n{\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> R = <span class=\"hljs-number\">0.2</span>;  <span class=\"hljs-comment\">// radius of cluster</span>\n    <span class=\"hljs-type\">int</span> i;\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">int</span> num_classes = <span class=\"hljs-number\">8</span>;\n    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">double</span> centres[][<span class=\"hljs-number\">3</span>] = {\n        <span class=\"hljs-comment\">// centres of each class cluster</span>\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>},    <span class=\"hljs-comment\">// centre of class 1</span>\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>},   <span class=\"hljs-comment\">// centre of class 2</span>\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>},   <span class=\"hljs-comment\">// centre of class 3</span>\n        {<span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>},  <span class=\"hljs-comment\">// centre of class 4</span>\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">.5</span>},   <span class=\"hljs-comment\">// centre of class 5</span>\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>, <span class=\"hljs-number\">-.5</span>},  <span class=\"hljs-comment\">// centre of class 6</span>\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">.5</span>},  <span class=\"hljs-comment\">// centre of class 7</span>\n        {<span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>, <span class=\"hljs-number\">-.5</span>}  <span class=\"hljs-comment\">// centre of class 8</span>\n    };\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; N; i++)\n    {\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> =</span>\n            rand() % num_classes;  <span class=\"hljs-comment\">// select a random class for the point</span>\n\n        <span class=\"hljs-comment\">// create random coordinates (x,y,z) around the centre of the class</span>\n        data[i][<span class=\"hljs-number\">0</span>] = _random(centres[class][<span class=\"hljs-number\">0</span>] - R, centres[class][<span class=\"hljs-number\">0</span>] + R);\n        data[i][<span class=\"hljs-number\">1</span>] = _random(centres[class][<span class=\"hljs-number\">1</span>] - R, centres[class][<span class=\"hljs-number\">1</span>] + R);\n        data[i][<span class=\"hljs-number\">2</span>] = _random(centres[class][<span class=\"hljs-number\">2</span>] - R, centres[class][<span class=\"hljs-number\">2</span>] + R);\n\n        <span class=\"hljs-comment\">/* The follosing can also be used\n        for (int j = 0; j &lt; 3; j++)\n            data[i][j] = _random(centres[class][j] - R, centres[class][j] + R);\n        */</span>\n    }\n}\n\n<span class=\"hljs-comment\">/** Test that creates a random set of points distributed in eight clusters in\n * 3D space and trains an SOM that finds the topological pattern. The following\n * [CSV](https://en.wikipedia.org/wiki/Comma-separated_values) files are created\n * to validate the execution:\n * * `test3.csv`: random test samples points\n * * `w31.csv`: initial random U-matrix\n * * `w32.csv`: trained SOM U-matrix\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test3</span><span class=\"hljs-params\">()</span>\n{\n    <span class=\"hljs-type\">int</span> j, N = <span class=\"hljs-number\">500</span>;\n    <span class=\"hljs-type\">int</span> features = <span class=\"hljs-number\">3</span>;\n    <span class=\"hljs-type\">int</span> num_out = <span class=\"hljs-number\">30</span>;\n    <span class=\"hljs-type\">double</span> **X = (<span class=\"hljs-type\">double</span> **)<span class=\"hljs-built_in\">malloc</span>(N * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span> *));\n\n    <span class=\"hljs-comment\">// cluster nodex in &#x27;x&#x27; * cluster nodes in &#x27;y&#x27; * 2</span>\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">kohonen_array_3d</span> <span class=\"hljs-title\">W</span>;</span>\n    W.dim1 = num_out;\n    W.dim2 = num_out;\n    W.dim3 = features;\n    W.data = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(num_out * num_out * features *\n                              <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));  <span class=\"hljs-comment\">// assign rows</span>\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max(num_out, N); i++)  <span class=\"hljs-comment\">// loop till max(N, num_out)</span>\n    {\n        <span class=\"hljs-keyword\">if</span> (i &lt; N)  <span class=\"hljs-comment\">// only add new arrays if i &lt; N</span>\n            X[i] = (<span class=\"hljs-type\">double</span> *)<span class=\"hljs-built_in\">malloc</span>(features * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">double</span>));\n        <span class=\"hljs-keyword\">if</span> (i &lt; num_out)  <span class=\"hljs-comment\">// only add new arrays if i &lt; num_out</span>\n        {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> k = <span class=\"hljs-number\">0</span>; k &lt; num_out; k++)\n            {\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> omp for</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n                <span class=\"hljs-comment\">// preallocate with random initial weights</span>\n                <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; features; j++)\n                {\n                    <span class=\"hljs-type\">double</span> *w = kohonen_data_3d(&amp;W, i, k, j);\n                    w[<span class=\"hljs-number\">0</span>] = _random(<span class=\"hljs-number\">-5</span>, <span class=\"hljs-number\">5</span>);\n                }\n            }\n        }\n    }\n\n    test_3d_classes2(X, N);  <span class=\"hljs-comment\">// create test data around the lamniscate</span>\n    save_2d_data(<span class=\"hljs-string\">&quot;test3.csv&quot;</span>, X, N, features);  <span class=\"hljs-comment\">// save test data points</span>\n    save_u_matrix(<span class=\"hljs-string\">&quot;w31.csv&quot;</span>, &amp;W);               <span class=\"hljs-comment\">// save initial random weights</span>\n    kohonen_som(X, &amp;W, N, features, num_out, <span class=\"hljs-number\">0.01</span>);  <span class=\"hljs-comment\">// train the SOM</span>\n    save_u_matrix(<span class=\"hljs-string\">&quot;w32.csv&quot;</span>, &amp;W);  <span class=\"hljs-comment\">// save the resultant weights</span>\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; N; i++) <span class=\"hljs-built_in\">free</span>(X[i]);\n    <span class=\"hljs-built_in\">free</span>(X);\n    <span class=\"hljs-built_in\">free</span>(W.data);\n}\n\n<span class=\"hljs-comment\">/**\n * Convert clock cycle difference to time in seconds\n *\n * \\param[in] start_t start clock\n * \\param[in] end_t end clock\n * \\returns time difference in seconds\n */</span>\n<span class=\"hljs-type\">double</span> <span class=\"hljs-title function_\">get_clock_diff</span><span class=\"hljs-params\">(<span class=\"hljs-type\">clock_t</span> <span class=\"hljs-type\">start_t</span>, <span class=\"hljs-type\">clock_t</span> <span class=\"hljs-type\">end_t</span>)</span>\n{\n    <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-type\">double</span>)(<span class=\"hljs-type\">end_t</span> - <span class=\"hljs-type\">start_t</span>) / (<span class=\"hljs-type\">double</span>)CLOCKS_PER_SEC;\n}\n\n<span class=\"hljs-comment\">/** Main function */</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> **argv)</span>\n{\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _OPENMP</span>\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Using OpenMP based parallelization\\n&quot;</span>);\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;NOT using OpenMP based parallelization\\n&quot;</span>);\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n    <span class=\"hljs-type\">clock_t</span> start_clk, end_clk;\n\n    start_clk = clock();\n    test1();\n    end_clk = clock();\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Test 1 completed in %.4g sec\\n&quot;</span>,\n           get_clock_diff(start_clk, end_clk));\n\n    start_clk = clock();\n    test2();\n    end_clk = clock();\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Test 2 completed in %.4g sec\\n&quot;</span>,\n           get_clock_diff(start_clk, end_clk));\n\n    start_clk = clock();\n    test3();\n    end_clk = clock();\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Test 3 completed in %.4g sec\\n&quot;</span>,\n           get_clock_diff(start_clk, end_clk));\n\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;(Note: Calculated times include: writing files to disk.)\\n\\n&quot;</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 10
    }
  ],
  "explanationUrl": {}
}