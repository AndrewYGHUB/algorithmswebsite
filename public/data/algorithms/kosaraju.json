{
  "slug": "kosaraju",
  "name": "Kosaraju",
  "categories": [
    "graphs"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "graph/kosaraju.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph/kosaraju.cpp",
      "code": "<span class=\"hljs-comment\">/* Implementation of Kosaraju&#x27;s Algorithm to find out the strongly connected\n   components (SCCs) in a graph. Author:Anirban166\n*/</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stack&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-comment\">/**\n * Iterative function/method to print graph:\n * @param a adjacency list representation of the graph\n * @param V number of vertices\n * @return void\n **/</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; &amp;a, <span class=\"hljs-type\">int</span> V)</span> </span>{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) {\n        <span class=\"hljs-keyword\">if</span> (!a[i].<span class=\"hljs-built_in\">empty</span>()) {\n            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;i=&quot;</span> &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot;--&gt;&quot;</span>;\n        }\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> j : a[i]) {\n            std::cout &lt;&lt; j &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;\n        }\n        <span class=\"hljs-keyword\">if</span> (!a[i].<span class=\"hljs-built_in\">empty</span>()) {\n            std::cout &lt;&lt; std::endl;\n        }\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * //Recursive function/method to push vertices into stack passed as parameter:\n * @param v vertices\n * @param st stack passed by reference\n * @param vis array to keep track of visited nodes (boolean type)\n * @param adj adjacency list representation of the graph\n * @return void\n **/</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">push_vertex</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> v, std::stack&lt;<span class=\"hljs-type\">int</span>&gt; *st, std::vector&lt;<span class=\"hljs-type\">bool</span>&gt; *vis,\n                 <span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; &amp;adj)</span> </span>{\n    (*vis)[v] = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i = adj[v].<span class=\"hljs-built_in\">begin</span>(); i != adj[v].<span class=\"hljs-built_in\">end</span>(); i++) {\n        <span class=\"hljs-keyword\">if</span> ((*vis)[*i] == <span class=\"hljs-literal\">false</span>) {\n            <span class=\"hljs-built_in\">push_vertex</span>(*i, st, vis, adj);\n        }\n    }\n    st-&gt;<span class=\"hljs-built_in\">push</span>(v);\n}\n\n<span class=\"hljs-comment\">/**\n * //Recursive function/method to implement depth first traversal(dfs):\n * @param v vertices\n * @param vis array to keep track of visited nodes (boolean type)\n * @param grev graph with reversed edges\n * @return void\n **/</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> v, std::vector&lt;<span class=\"hljs-type\">bool</span>&gt; *vis,\n         <span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; &amp;grev)</span> </span>{\n    (*vis)[v] = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-comment\">// cout&lt;&lt;v&lt;&lt;&quot; &quot;;</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i = grev[v].<span class=\"hljs-built_in\">begin</span>(); i != grev[v].<span class=\"hljs-built_in\">end</span>(); i++) {\n        <span class=\"hljs-keyword\">if</span> ((*vis)[*i] == <span class=\"hljs-literal\">false</span>) {\n            <span class=\"hljs-built_in\">dfs</span>(*i, vis, grev);\n        }\n    }\n}\n\n<span class=\"hljs-comment\">// function/method to implement Kosaraju&#x27;s Algorithm:</span>\n<span class=\"hljs-comment\">/**\n* Info about the method\n* @param V vertices in graph\n* @param adj array of vectors that represent a graph (adjacency list/array)\n* @return int ( 0, 1, 2..and so on, only unsigned values as either there can be\nno SCCs i.e. none(0) or there will be x no. of SCCs (x&gt;0)) i.e. it returns the\ncount of (number of) strongly connected components (SCCs) in the graph.\n(variable &#x27;count_scc&#x27; within function)\n**/</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">kosaraju</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> V, <span class=\"hljs-type\">const</span> std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; &amp;adj)</span> </span>{\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">bool</span>&gt; <span class=\"hljs-title\">vis</span><span class=\"hljs-params\">(V, <span class=\"hljs-literal\">false</span>)</span></span>;\n    std::stack&lt;<span class=\"hljs-type\">int</span>&gt; st;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v = <span class=\"hljs-number\">0</span>; v &lt; V; v++) {\n        <span class=\"hljs-keyword\">if</span> (vis[v] == <span class=\"hljs-literal\">false</span>) {\n            <span class=\"hljs-built_in\">push_vertex</span>(v, &amp;st, &amp;vis, adj);\n        }\n    }\n    <span class=\"hljs-comment\">// making new graph (grev) with reverse edges as in adj[]:</span>\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; <span class=\"hljs-built_in\">grev</span>(V);\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V + <span class=\"hljs-number\">1</span>; i++) {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> j = adj[i].<span class=\"hljs-built_in\">begin</span>(); j != adj[i].<span class=\"hljs-built_in\">end</span>(); j++) {\n            grev[*j].<span class=\"hljs-built_in\">push_back</span>(i);\n        }\n    }\n    <span class=\"hljs-comment\">// cout&lt;&lt;&quot;grev=&quot;&lt;&lt;endl; -&gt;debug statement</span>\n    <span class=\"hljs-comment\">// print(grev,V);       -&gt;debug statement</span>\n    <span class=\"hljs-comment\">// reinitialise visited to 0</span>\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; V; i++) vis[i] = <span class=\"hljs-literal\">false</span>;\n    <span class=\"hljs-type\">int</span> count_scc = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">while</span> (!st.<span class=\"hljs-built_in\">empty</span>()) {\n        <span class=\"hljs-type\">int</span> t = st.<span class=\"hljs-built_in\">top</span>();\n        st.<span class=\"hljs-built_in\">pop</span>();\n        <span class=\"hljs-keyword\">if</span> (vis[t] == <span class=\"hljs-literal\">false</span>) {\n            <span class=\"hljs-built_in\">dfs</span>(t, &amp;vis, grev);\n            count_scc++;\n        }\n    }\n    <span class=\"hljs-comment\">// cout&lt;&lt;&quot;count_scc=&quot;&lt;&lt;count_scc&lt;&lt;endl; //in case you want to print here</span>\n    <span class=\"hljs-comment\">// itself, uncomment &amp; change return type of function to void.</span>\n    <span class=\"hljs-keyword\">return</span> count_scc;\n}\n\n<span class=\"hljs-comment\">// All critical/corner cases have been taken care of.</span>\n<span class=\"hljs-comment\">// Input your required values: (not hardcoded)</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-type\">int</span> t = <span class=\"hljs-number\">0</span>;\n    std::cin &gt;&gt; t;\n    <span class=\"hljs-keyword\">while</span> (t--) {\n        <span class=\"hljs-type\">int</span> a = <span class=\"hljs-number\">0</span>, b = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">// a-&gt;number of nodes, b-&gt;directed edges.</span>\n        std::cin &gt;&gt; a &gt;&gt; b;\n        <span class=\"hljs-type\">int</span> m = <span class=\"hljs-number\">0</span>, n = <span class=\"hljs-number\">0</span>;\n        std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; <span class=\"hljs-built_in\">adj</span>(a + <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; b; i++)  <span class=\"hljs-comment\">// take total b inputs of 2 vertices each</span>\n                                     <span class=\"hljs-comment\">// required to form an edge.</span>\n        {\n            std::cin &gt;&gt; m &gt;&gt; n;  <span class=\"hljs-comment\">// take input m,n denoting edge from m-&gt;n.</span>\n            adj[m].<span class=\"hljs-built_in\">push_back</span>(n);\n        }\n        <span class=\"hljs-comment\">// pass number of nodes and adjacency array as parameters to function:</span>\n        std::cout &lt;&lt; <span class=\"hljs-built_in\">kosaraju</span>(a, adj) &lt;&lt; std::endl;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "c-sharp": {
      "dir": "./Algorithms/Graph/Kosaraju.cs",
      "url": "https:/github.com/TheAlgorithms/C-Sharp/tree/master/Algorithms/Graph/Kosaraju.cs",
      "code": "<span class=\"hljs-keyword\">using</span> System.Collections.Generic;\n<span class=\"hljs-keyword\">using</span> System.Linq;\n<span class=\"hljs-keyword\">using</span> DataStructures.Graph;\n\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">Algorithms.Graph</span>\n{\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> Implementation of Kosaraju-Sharir&#x27;s algorithm (also known as Kosaraju&#x27;s algorithm) to find the</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> strongly connected components (SCC) of a directed graph.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> See https://en.wikipedia.org/wiki/Kosaraju%27s_algorithm.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;typeparam name=&quot;T&quot;&gt;</span>Vertex data type.<span class=\"hljs-doctag\">&lt;/typeparam&gt;</span></span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Kosaraju</span>&lt;<span class=\"hljs-title\">T</span>&gt;\n    {\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> First DFS for Kosaraju algorithm: traverse the graph creating a reverse order explore list <span class=\"hljs-doctag\">&lt;paramref name=&quot;reversed&quot;/&gt;</span>.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;v&quot;&gt;</span>Vertex to explore.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;graph&quot;&gt;</span>Graph instance.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;visited&quot;&gt;</span>List of already visited vertex.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;reversed&quot;&gt;</span>Reversed list of vertex for the second DFS.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Visit</span>(<span class=\"hljs-params\">Vertex&lt;T&gt; v, IDirectedWeightedGraph&lt;T&gt; graph, HashSet&lt;Vertex&lt;T&gt;&gt; visited, Stack&lt;Vertex&lt;T&gt;&gt; reversed</span>)</span>\n        {\n            <span class=\"hljs-keyword\">if</span> (visited.Contains(v))\n            {\n                <span class=\"hljs-keyword\">return</span>;\n            }\n\n            <span class=\"hljs-comment\">// Set v as visited</span>\n            visited.Add(v);\n\n            <span class=\"hljs-comment\">// Push v in the stack.</span>\n            <span class=\"hljs-comment\">// This can also be done with a List, inserting v at the begining of the list</span>\n            <span class=\"hljs-comment\">// after visit the neighbors.</span>\n            reversed.Push(v);\n\n            <span class=\"hljs-comment\">// Visit neighbors</span>\n            <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> u <span class=\"hljs-keyword\">in</span> graph.GetNeighbors(v))\n            {\n                Visit(u!, graph, visited, reversed);\n            }\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> Second DFS for Kosaraju algorithm. Traverse the graph in reversed order</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> assigning a root vertex for every vertex that belong to the same SCC.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;v&quot;&gt;</span>Vertex to assign.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;root&quot;&gt;</span>Root vertext, representative of the SCC.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;graph&quot;&gt;</span>Graph with vertex and edges.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;roots&quot;&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> Dictionary that assigns to each vertex the root of the SCC to which it corresponds.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Assign</span>(<span class=\"hljs-params\">Vertex&lt;T&gt; v, Vertex&lt;T&gt; root, IDirectedWeightedGraph&lt;T&gt; graph, Dictionary&lt;Vertex&lt;T&gt;, Vertex&lt;T&gt;&gt; roots</span>)</span>\n        {\n            <span class=\"hljs-comment\">// If v already has a representative vertex (root) already assigned, do nothing.</span>\n            <span class=\"hljs-keyword\">if</span> (roots.ContainsKey(v))\n            {\n                <span class=\"hljs-keyword\">return</span>;\n            }\n\n            <span class=\"hljs-comment\">// Assign the root to the vertex.</span>\n            roots.Add(v, root);\n\n            <span class=\"hljs-comment\">// Assign the current root vertex to v neighbors.</span>\n            <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> u <span class=\"hljs-keyword\">in</span> graph.GetNeighbors(v))\n            {\n                Assign(u!, root, graph, roots);\n            }\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> Find the representative vertex of the SCC for each vertex on the graph.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;graph&quot;&gt;</span>Graph to explore.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>A dictionary that assigns to each vertex a root vertex of the SCC they belong. <span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Dictionary&lt;Vertex&lt;T&gt;, Vertex&lt;T&gt;&gt; GetRepresentatives(IDirectedWeightedGraph&lt;T&gt; graph)\n        {\n            HashSet&lt;Vertex&lt;T&gt;&gt; visited = <span class=\"hljs-keyword\">new</span> HashSet&lt;Vertex&lt;T&gt;&gt;();\n            Stack&lt;Vertex&lt;T&gt;&gt; reversedL = <span class=\"hljs-keyword\">new</span> Stack&lt;Vertex&lt;T&gt;&gt;();\n            Dictionary&lt;Vertex&lt;T&gt;, Vertex&lt;T&gt;&gt; representatives = <span class=\"hljs-keyword\">new</span> Dictionary&lt;Vertex&lt;T&gt;, Vertex&lt;T&gt;&gt;();\n\n            <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> v <span class=\"hljs-keyword\">in</span> graph.Vertices)\n            {\n                <span class=\"hljs-keyword\">if</span> (v != <span class=\"hljs-literal\">null</span>)\n                {\n                    Visit(v, graph, visited, reversedL);\n                }\n            }\n\n            visited.Clear();\n\n            <span class=\"hljs-keyword\">while</span> (reversedL.Count &gt; <span class=\"hljs-number\">0</span>)\n            {\n                Vertex&lt;T&gt; v = reversedL.Pop();\n                Assign(v, v, graph, representatives);\n            }\n\n            <span class=\"hljs-keyword\">return</span> representatives;\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> Get the Strongly Connected Components for the graph.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;graph&quot;&gt;</span>Graph to explore.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>An array of SCC.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> IEnumerable&lt;Vertex&lt;T&gt;&gt;[] GetScc(IDirectedWeightedGraph&lt;T&gt; graph)\n        {\n            <span class=\"hljs-keyword\">var</span> representatives = GetRepresentatives(graph);\n            Dictionary&lt;Vertex&lt;T&gt;, List&lt;Vertex&lt;T&gt;&gt;&gt; scc = <span class=\"hljs-keyword\">new</span> Dictionary&lt;Vertex&lt;T&gt;, List&lt;Vertex&lt;T&gt;&gt;&gt;();\n            <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> kv <span class=\"hljs-keyword\">in</span> representatives)\n            {\n                <span class=\"hljs-comment\">// Assign all vertex (key) that have the seem root (value) to a single list.</span>\n                <span class=\"hljs-keyword\">if</span> (scc.ContainsKey(kv.Value))\n                {\n                    scc[kv.Value].Add(kv.Key);\n                }\n                <span class=\"hljs-keyword\">else</span>\n                {\n                    scc.Add(kv.Value, <span class=\"hljs-keyword\">new</span> List&lt;Vertex&lt;T&gt;&gt; { kv.Key });\n                }\n            }\n\n            <span class=\"hljs-keyword\">return</span> scc.Values.ToArray();\n        }\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Diego Delgado",
      "email": "105917468+dideldev@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "ayaankhan98",
      "email": "ayaankhan98@gmail.com",
      "commits": 1
    },
    {
      "name": "Anirban166",
      "email": "bloodraven166@gmail.com",
      "commits": 3
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 3
    }
  ],
  "explanationUrl": {}
}