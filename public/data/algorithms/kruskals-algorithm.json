{
  "slug": "kruskals-algorithm",
  "name": "Kruskal's Algorithm",
  "categories": [
    "graphs",
    "minimumspanningtree"
  ],
  "body": {},
  "implementations": {
    "c-sharp": {
      "dir": "./Algorithms/Graph/MinimumSpanningTree/Kruskal.cs",
      "url": "https:/github.com/TheAlgorithms/C-Sharp/tree/master/Algorithms/Graph/MinimumSpanningTree/Kruskal.cs",
      "code": "<span class=\"hljs-keyword\">using</span> System;\n<span class=\"hljs-keyword\">using</span> System.Collections.Generic;\n<span class=\"hljs-keyword\">using</span> DataStructures.DisjointSet;\n\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">Algorithms.Graph.MinimumSpanningTree</span>\n{\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Algorithm to determine the minimum spanning forest of an undirected graph.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;remarks&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Kruskal&#x27;s algorithm is a greedy algorithm that can determine the</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     minimum spanning tree or minimum spanning forest of any undirected</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     graph. Unlike Prim&#x27;s algorithm, Kruskal&#x27;s algorithm will work on</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     graphs that are unconnected. This algorithm will always have a</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     running time of O(E log V) where E is the number of edges and V is</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     the number of vertices/nodes.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     More information: https://en.wikipedia.org/wiki/Kruskal%27s_algorithm .</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Pseudocode and analysis: https://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/primAlgor.htm .</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/remarks&gt;</span></span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Kruskal</span>\n    {\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Determine the minimum spanning tree/forest of the given graph.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;adjacencyMatrix&quot;&gt;</span>Adjacency matrix representing the graph.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Adjacency matrix of the minimum spanning tree/forest.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">float</span>[,] Solve(<span class=\"hljs-built_in\">float</span>[,] adjacencyMatrix)\n        {\n            ValidateGraph(adjacencyMatrix);\n\n            <span class=\"hljs-keyword\">var</span> numNodes = adjacencyMatrix.GetLength(<span class=\"hljs-number\">0</span>);\n            <span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">set</span> = <span class=\"hljs-keyword\">new</span> DisjointSet&lt;<span class=\"hljs-built_in\">int</span>&gt;();\n            <span class=\"hljs-keyword\">var</span> nodes = <span class=\"hljs-keyword\">new</span> Node&lt;<span class=\"hljs-built_in\">int</span>&gt;[numNodes];\n            <span class=\"hljs-keyword\">var</span> edgeWeightList = <span class=\"hljs-keyword\">new</span> List&lt;<span class=\"hljs-built_in\">float</span>&gt;();\n            <span class=\"hljs-keyword\">var</span> nodeConnectList = <span class=\"hljs-keyword\">new</span> List&lt;(<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>)&gt;();\n\n            <span class=\"hljs-comment\">// Add nodes to disjoint set</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numNodes; i++)\n            {\n                nodes[i] = <span class=\"hljs-keyword\">set</span>.MakeSet(i);\n            }\n\n            <span class=\"hljs-comment\">// Create lists with edge weights and associated connectivity</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numNodes - <span class=\"hljs-number\">1</span>; i++)\n            {\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = i + <span class=\"hljs-number\">1</span>; j &lt; numNodes; j++)\n                {\n                    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">float</span>.IsFinite(adjacencyMatrix[i, j]))\n                    {\n                        edgeWeightList.Add(adjacencyMatrix[i, j]);\n                        nodeConnectList.Add((i, j));\n                    }\n                }\n            }\n\n            <span class=\"hljs-keyword\">var</span> edges = Solve(<span class=\"hljs-keyword\">set</span>, nodes, edgeWeightList.ToArray(), nodeConnectList.ToArray());\n\n            <span class=\"hljs-comment\">// Initialize minimum spanning tree</span>\n            <span class=\"hljs-keyword\">var</span> mst = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">float</span>[numNodes, numNodes];\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numNodes; i++)\n            {\n                mst[i, i] = <span class=\"hljs-built_in\">float</span>.PositiveInfinity;\n\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = i + <span class=\"hljs-number\">1</span>; j &lt; numNodes; j++)\n                {\n                    mst[i, j] = <span class=\"hljs-built_in\">float</span>.PositiveInfinity;\n                    mst[j, i] = <span class=\"hljs-built_in\">float</span>.PositiveInfinity;\n                }\n            }\n\n            <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> (node1, node2) <span class=\"hljs-keyword\">in</span> edges)\n            {\n                mst[node1, node2] = adjacencyMatrix[node1, node2];\n                mst[node2, node1] = adjacencyMatrix[node1, node2];\n            }\n\n            <span class=\"hljs-keyword\">return</span> mst;\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Determine the minimum spanning tree/forest of the given graph.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;adjacencyList&quot;&gt;</span>Adjacency list representing the graph.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Adjacency list of the minimum spanning tree/forest.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> Dictionary&lt;<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">float</span>&gt;[] <span class=\"hljs-title\">Solve</span>(<span class=\"hljs-params\">Dictionary&lt;<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">float</span>&gt;[] adjacencyList</span>)</span>\n        {\n            ValidateGraph(adjacencyList);\n\n            <span class=\"hljs-keyword\">var</span> numNodes = adjacencyList.Length;\n            <span class=\"hljs-keyword\">var</span> <span class=\"hljs-keyword\">set</span> = <span class=\"hljs-keyword\">new</span> DisjointSet&lt;<span class=\"hljs-built_in\">int</span>&gt;();\n            <span class=\"hljs-keyword\">var</span> nodes = <span class=\"hljs-keyword\">new</span> Node&lt;<span class=\"hljs-built_in\">int</span>&gt;[numNodes];\n            <span class=\"hljs-keyword\">var</span> edgeWeightList = <span class=\"hljs-keyword\">new</span> List&lt;<span class=\"hljs-built_in\">float</span>&gt;();\n            <span class=\"hljs-keyword\">var</span> nodeConnectList = <span class=\"hljs-keyword\">new</span> List&lt;(<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>)&gt;();\n\n            <span class=\"hljs-comment\">// Add nodes to disjoint set and create list of edge weights and associated connectivity</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numNodes; i++)\n            {\n                nodes[i] = <span class=\"hljs-keyword\">set</span>.MakeSet(i);\n\n                <span class=\"hljs-keyword\">foreach</span>(<span class=\"hljs-keyword\">var</span> (node, weight) <span class=\"hljs-keyword\">in</span> adjacencyList[i])\n                {\n                    edgeWeightList.Add(weight);\n                    nodeConnectList.Add((i, node));\n                }\n            }\n\n            <span class=\"hljs-keyword\">var</span> edges = Solve(<span class=\"hljs-keyword\">set</span>, nodes, edgeWeightList.ToArray(), nodeConnectList.ToArray());\n\n            <span class=\"hljs-comment\">// Create minimum spanning tree</span>\n            <span class=\"hljs-keyword\">var</span> mst = <span class=\"hljs-keyword\">new</span> Dictionary&lt;<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">float</span>&gt;[numNodes];\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numNodes; i++)\n            {\n                mst[i] = <span class=\"hljs-keyword\">new</span> Dictionary&lt;<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">float</span>&gt;();\n            }\n\n            <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> (node1, node2) <span class=\"hljs-keyword\">in</span> edges)\n            {\n                mst[node1].Add(node2, adjacencyList[node1][node2]);\n                mst[node2].Add(node1, adjacencyList[node1][node2]);\n            }\n\n            <span class=\"hljs-keyword\">return</span> mst;\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Ensure that the given graph is undirected.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;adj&quot;&gt;</span>Adjacency matrix of graph to check.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ValidateGraph</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">float</span>[,] adj</span>)</span>\n        {\n            <span class=\"hljs-keyword\">if</span> (adj.GetLength(<span class=\"hljs-number\">0</span>) != adj.GetLength(<span class=\"hljs-number\">1</span>))\n            {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ArgumentException(<span class=\"hljs-string\">&quot;Matrix must be square!&quot;</span>);\n            }\n\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; adj.GetLength(<span class=\"hljs-number\">0</span>) - <span class=\"hljs-number\">1</span>; i++)\n            {\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = i + <span class=\"hljs-number\">1</span>; j &lt; adj.GetLength(<span class=\"hljs-number\">1</span>); j++)\n                {\n                    <span class=\"hljs-keyword\">if</span> (Math.Abs(adj[i, j] - adj[j, i]) &gt; <span class=\"hljs-number\">1e-6</span>)\n                    {\n                        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ArgumentException(<span class=\"hljs-string\">&quot;Matrix must be symmetric!&quot;</span>);\n                    }\n                }\n            }\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Ensure that the given graph is undirected.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;adj&quot;&gt;</span>Adjacency list of graph to check.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ValidateGraph</span>(<span class=\"hljs-params\">Dictionary&lt;<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">float</span>&gt;[] adj</span>)</span>\n        {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; adj.Length; i++)\n            {\n                <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> edge <span class=\"hljs-keyword\">in</span> adj[i])\n                {\n                    <span class=\"hljs-keyword\">if</span> (!adj[edge.Key].ContainsKey(i) || Math.Abs(edge.Value - adj[edge.Key][i]) &gt; <span class=\"hljs-number\">1e-6</span>)\n                    {\n                        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ArgumentException(<span class=\"hljs-string\">&quot;Graph must be undirected!&quot;</span>);\n                    }\n                }\n            }\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Determine the minimum spanning tree/forest.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;set&quot;&gt;</span>Disjoint set needed for set operations.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;nodes&quot;&gt;</span>List of nodes in disjoint set associated with each node.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;edgeWeights&quot;&gt;</span>Weights of each edge.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;connections&quot;&gt;</span>Nodes associated with each item in the <span class=\"hljs-doctag\">&lt;paramref name=&quot;edgeWeights&quot;/&gt;</span> parameter.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Array of edges in the minimum spanning tree/forest.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> (<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span></span>)[] <span class=\"hljs-title\">Solve</span>(<span class=\"hljs-params\">DisjointSet&lt;<span class=\"hljs-built_in\">int</span>&gt; <span class=\"hljs-keyword\">set</span>, Node&lt;<span class=\"hljs-built_in\">int</span>&gt;[] nodes, <span class=\"hljs-built_in\">float</span>[] edgeWeights, (<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span></span>)[] connections)</span>\n        {\n            <span class=\"hljs-keyword\">var</span> edges = <span class=\"hljs-keyword\">new</span> List&lt;(<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>)&gt;();\n\n            Array.Sort(edgeWeights, connections);\n\n            <span class=\"hljs-keyword\">foreach</span> (<span class=\"hljs-keyword\">var</span> (node1, node2) <span class=\"hljs-keyword\">in</span> connections)\n            {\n                <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-keyword\">set</span>.FindSet(nodes[node1]) != <span class=\"hljs-keyword\">set</span>.FindSet(nodes[node2]))\n                {\n                    <span class=\"hljs-keyword\">set</span>.UnionSet(nodes[node1], nodes[node2]);\n                    edges.Add((node1, node2));\n                }\n            }\n\n            <span class=\"hljs-keyword\">return</span> edges.ToArray();\n        }\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "khalil2535",
      "email": "khalil2535@localhost",
      "commits": 1
    },
    {
      "name": "Mansi Mittal",
      "email": "m16mittal@gmail.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}