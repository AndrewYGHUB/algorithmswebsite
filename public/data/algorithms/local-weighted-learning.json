{
  "slug": "local-weighted-learning",
  "name": "Local Weighted Learning",
  "categories": [
    "machinelearning"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "machine_learning/local_weighted_learning/local_weighted_learning.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/machine_learning/local_weighted_learning/local_weighted_learning.py",
      "code": "<span class=\"hljs-comment\"># Required imports to run this file</span>\n<span class=\"hljs-keyword\">import</span> matplotlib.pyplot <span class=\"hljs-keyword\">as</span> plt\n<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n\n\n<span class=\"hljs-comment\"># weighted matrix</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">weighted_matrix</span>(<span class=\"hljs-params\">point: np.mat, training_data_x: np.mat, bandwidth: <span class=\"hljs-built_in\">float</span></span>) -&gt; np.mat:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Calculate the weight for every point in the\n    data set. It takes training_point , query_point, and tau\n    Here Tau is not a fixed value it can be varied depends on output.\n    tau --&gt; bandwidth\n    xmat --&gt;Training data\n    point --&gt; the x where we want to make predictions\n    &gt;&gt;&gt; weighted_matrix(np.array([1., 1.]),np.mat([[16.99, 10.34], [21.01,23.68],\n    ...                    [24.59,25.69]]), 0.6)\n    matrix([[1.43807972e-207, 0.00000000e+000, 0.00000000e+000],\n            [0.00000000e+000, 0.00000000e+000, 0.00000000e+000],\n            [0.00000000e+000, 0.00000000e+000, 0.00000000e+000]])\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-comment\"># m is the number of training samples</span>\n    m, n = np.shape(training_data_x)\n    <span class=\"hljs-comment\"># Initializing weights as identity matrix</span>\n    weights = np.mat(np.eye(m))\n    <span class=\"hljs-comment\"># calculating weights for all training examples [x(i)&#x27;s]</span>\n    <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(m):\n        diff = point - training_data_x[j]\n        weights[j, j] = np.exp(diff * diff.T / (-<span class=\"hljs-number\">2.0</span> * bandwidth**<span class=\"hljs-number\">2</span>))\n    <span class=\"hljs-keyword\">return</span> weights\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">local_weight</span>(<span class=\"hljs-params\">\n    point: np.mat, training_data_x: np.mat, training_data_y: np.mat, bandwidth: <span class=\"hljs-built_in\">float</span>\n</span>) -&gt; np.mat:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Calculate the local weights using the weight_matrix function on training data.\n    Return the weighted matrix.\n    &gt;&gt;&gt; local_weight(np.array([1., 1.]),np.mat([[16.99, 10.34], [21.01,23.68],\n    ...                 [24.59,25.69]]),np.mat([[1.01, 1.66, 3.5]]), 0.6)\n    matrix([[0.00873174],\n            [0.08272556]])\n    &quot;&quot;&quot;</span>\n    weight = weighted_matrix(point, training_data_x, bandwidth)\n    W = (training_data_x.T * (weight * training_data_x)).I * (\n        training_data_x.T * weight * training_data_y.T\n    )\n\n    <span class=\"hljs-keyword\">return</span> W\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">local_weight_regression</span>(<span class=\"hljs-params\">\n    training_data_x: np.mat, training_data_y: np.mat, bandwidth: <span class=\"hljs-built_in\">float</span>\n</span>) -&gt; np.mat:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Calculate predictions for each data point on axis.\n    &gt;&gt;&gt; local_weight_regression(np.mat([[16.99, 10.34], [21.01,23.68],\n    ...                            [24.59,25.69]]),np.mat([[1.01, 1.66, 3.5]]), 0.6)\n    array([1.07173261, 1.65970737, 3.50160179])\n    &quot;&quot;&quot;</span>\n    m, n = np.shape(training_data_x)\n    ypred = np.zeros(m)\n\n    <span class=\"hljs-keyword\">for</span> i, item <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">enumerate</span>(training_data_x):\n        ypred[i] = item * local_weight(\n            item, training_data_x, training_data_y, bandwidth\n        )\n\n    <span class=\"hljs-keyword\">return</span> ypred\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">load_data</span>(<span class=\"hljs-params\">dataset_name: <span class=\"hljs-built_in\">str</span>, cola_name: <span class=\"hljs-built_in\">str</span>, colb_name: <span class=\"hljs-built_in\">str</span></span>) -&gt; np.mat:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Function used for loading data from the seaborn splitting into x and y points\n    &gt;&gt;&gt; pass # this function has no doctest\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">import</span> seaborn <span class=\"hljs-keyword\">as</span> sns\n\n    data = sns.load_dataset(dataset_name)\n    col_a = np.array(data[cola_name])  <span class=\"hljs-comment\"># total_bill</span>\n    col_b = np.array(data[colb_name])  <span class=\"hljs-comment\"># tip</span>\n\n    mcol_a = np.mat(col_a)\n    mcol_b = np.mat(col_b)\n\n    m = np.shape(mcol_b)[<span class=\"hljs-number\">1</span>]\n    one = np.ones((<span class=\"hljs-number\">1</span>, m), dtype=<span class=\"hljs-built_in\">int</span>)\n\n    <span class=\"hljs-comment\"># horizontal stacking</span>\n    training_data_x = np.hstack((one.T, mcol_a.T))\n\n    <span class=\"hljs-keyword\">return</span> training_data_x, mcol_b, col_a, col_b\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">get_preds</span>(<span class=\"hljs-params\">training_data_x: np.mat, mcol_b: np.mat, tau: <span class=\"hljs-built_in\">float</span></span>) -&gt; np.ndarray:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Get predictions with minimum error for each training data\n    &gt;&gt;&gt; get_preds(np.mat([[16.99, 10.34], [21.01,23.68],\n    ...                     [24.59,25.69]]),np.mat([[1.01, 1.66, 3.5]]), 0.6)\n    array([1.07173261, 1.65970737, 3.50160179])\n    &quot;&quot;&quot;</span>\n    ypred = local_weight_regression(training_data_x, mcol_b, tau)\n    <span class=\"hljs-keyword\">return</span> ypred\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">plot_preds</span>(<span class=\"hljs-params\">\n    training_data_x: np.mat,\n    predictions: np.ndarray,\n    col_x: np.ndarray,\n    col_y: np.ndarray,\n    cola_name: <span class=\"hljs-built_in\">str</span>,\n    colb_name: <span class=\"hljs-built_in\">str</span>,\n</span>) -&gt; plt.plot:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    This function used to plot predictions and display the graph\n    &gt;&gt;&gt; pass #this function has no doctest\n    &quot;&quot;&quot;</span>\n    xsort = training_data_x.copy()\n    xsort.sort(axis=<span class=\"hljs-number\">0</span>)\n    plt.scatter(col_x, col_y, color=<span class=\"hljs-string\">&quot;blue&quot;</span>)\n    plt.plot(\n        xsort[:, <span class=\"hljs-number\">1</span>],\n        predictions[training_data_x[:, <span class=\"hljs-number\">1</span>].argsort(<span class=\"hljs-number\">0</span>)],\n        color=<span class=\"hljs-string\">&quot;yellow&quot;</span>,\n        linewidth=<span class=\"hljs-number\">5</span>,\n    )\n    plt.title(<span class=\"hljs-string\">&quot;Local Weighted Regression&quot;</span>)\n    plt.xlabel(cola_name)\n    plt.ylabel(colb_name)\n    plt.show()\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    training_data_x, mcol_b, col_a, col_b = load_data(<span class=\"hljs-string\">&quot;tips&quot;</span>, <span class=\"hljs-string\">&quot;total_bill&quot;</span>, <span class=\"hljs-string\">&quot;tip&quot;</span>)\n    predictions = get_preds(training_data_x, mcol_b, <span class=\"hljs-number\">0.5</span>)\n    plot_preds(training_data_x, predictions, col_a, col_b, <span class=\"hljs-string\">&quot;total_bill&quot;</span>, <span class=\"hljs-string\">&quot;tip&quot;</span>)\n"
    }
  },
  "contributors": [
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 1
    },
    {
      "name": "Venkatesh Tantravahi",
      "email": "64308188+venkateshtantravahi@users.noreply.github.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}