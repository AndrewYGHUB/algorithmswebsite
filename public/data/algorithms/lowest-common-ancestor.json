{
  "slug": "lowest-common-ancestor",
  "name": "Lowest Common Ancestor",
  "categories": [
    "datastructures",
    "binarytree"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "data_structures/binary_tree/lowest_common_ancestor.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/data_structures/binary_tree/lowest_common_ancestor.py",
      "code": "<span class=\"hljs-comment\"># https://en.wikipedia.org/wiki/Lowest_common_ancestor</span>\n<span class=\"hljs-comment\"># https://en.wikipedia.org/wiki/Breadth-first_search</span>\n\n<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\n\n<span class=\"hljs-keyword\">from</span> queue <span class=\"hljs-keyword\">import</span> Queue\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">swap</span>(<span class=\"hljs-params\">a: <span class=\"hljs-built_in\">int</span>, b: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">int</span>]:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Return a tuple (b, a) when given two integers a and b\n    &gt;&gt;&gt; swap(2,3)\n    (3, 2)\n    &gt;&gt;&gt; swap(3,4)\n    (4, 3)\n    &gt;&gt;&gt; swap(67, 12)\n    (12, 67)\n    &quot;&quot;&quot;</span>\n    a ^= b\n    b ^= a\n    a ^= b\n    <span class=\"hljs-keyword\">return</span> a, b\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">create_sparse</span>(<span class=\"hljs-params\">max_node: <span class=\"hljs-built_in\">int</span>, parent: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]]</span>) -&gt; <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]]:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    creating sparse table which saves each nodes 2^i-th parent\n    &quot;&quot;&quot;</span>\n    j = <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span> &lt;&lt; j) &lt; max_node:\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, max_node + <span class=\"hljs-number\">1</span>):\n            parent[j][i] = parent[j - <span class=\"hljs-number\">1</span>][parent[j - <span class=\"hljs-number\">1</span>][i]]\n        j += <span class=\"hljs-number\">1</span>\n    <span class=\"hljs-keyword\">return</span> parent\n\n\n<span class=\"hljs-comment\"># returns lca of node u,v</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">lowest_common_ancestor</span>(<span class=\"hljs-params\">\n    u: <span class=\"hljs-built_in\">int</span>, v: <span class=\"hljs-built_in\">int</span>, level: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>], parent: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]]\n</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n    <span class=\"hljs-comment\"># u must be deeper in the tree than v</span>\n    <span class=\"hljs-keyword\">if</span> level[u] &lt; level[v]:\n        u, v = swap(u, v)\n    <span class=\"hljs-comment\"># making depth of u same as depth of v</span>\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">18</span>, -<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>):\n        <span class=\"hljs-keyword\">if</span> level[u] - (<span class=\"hljs-number\">1</span> &lt;&lt; i) &gt;= level[v]:\n            u = parent[i][u]\n    <span class=\"hljs-comment\"># at the same depth if u==v that mean lca is found</span>\n    <span class=\"hljs-keyword\">if</span> u == v:\n        <span class=\"hljs-keyword\">return</span> u\n    <span class=\"hljs-comment\"># moving both nodes upwards till lca in found</span>\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">18</span>, -<span class=\"hljs-number\">1</span>, -<span class=\"hljs-number\">1</span>):\n        <span class=\"hljs-keyword\">if</span> parent[i][u] <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> [<span class=\"hljs-number\">0</span>, parent[i][v]]:\n            u, v = parent[i][u], parent[i][v]\n    <span class=\"hljs-comment\"># returning longest common ancestor of u,v</span>\n    <span class=\"hljs-keyword\">return</span> parent[<span class=\"hljs-number\">0</span>][u]\n\n\n<span class=\"hljs-comment\"># runs a breadth first search from root node of the tree</span>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">breadth_first_search</span>(<span class=\"hljs-params\">\n    level: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>],\n    parent: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]],\n    max_node: <span class=\"hljs-built_in\">int</span>,\n    graph: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]],\n    root: <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">1</span>,\n</span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>], <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]]]:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    sets every nodes direct parent\n    parent of root node is set to 0\n    calculates depth of each node from root node\n    &quot;&quot;&quot;</span>\n    level[root] = <span class=\"hljs-number\">0</span>\n    q: Queue[<span class=\"hljs-built_in\">int</span>] = Queue(maxsize=max_node)\n    q.put(root)\n    <span class=\"hljs-keyword\">while</span> q.qsize() != <span class=\"hljs-number\">0</span>:\n        u = q.get()\n        <span class=\"hljs-keyword\">for</span> v <span class=\"hljs-keyword\">in</span> graph[u]:\n            <span class=\"hljs-keyword\">if</span> level[v] == -<span class=\"hljs-number\">1</span>:\n                level[v] = level[u] + <span class=\"hljs-number\">1</span>\n                q.put(v)\n                parent[<span class=\"hljs-number\">0</span>][v] = u\n    <span class=\"hljs-keyword\">return</span> level, parent\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">main</span>() -&gt; <span class=\"hljs-literal\">None</span>:\n    max_node = <span class=\"hljs-number\">13</span>\n    <span class=\"hljs-comment\"># initializing with 0</span>\n    parent = [[<span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(max_node + <span class=\"hljs-number\">10</span>)] <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">20</span>)]\n    <span class=\"hljs-comment\"># initializing with -1 which means every node is unvisited</span>\n    level = [-<span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(max_node + <span class=\"hljs-number\">10</span>)]\n    graph: <span class=\"hljs-built_in\">dict</span>[<span class=\"hljs-built_in\">int</span>, <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]] = {\n        <span class=\"hljs-number\">1</span>: [<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>],\n        <span class=\"hljs-number\">2</span>: [<span class=\"hljs-number\">5</span>],\n        <span class=\"hljs-number\">3</span>: [<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>],\n        <span class=\"hljs-number\">4</span>: [<span class=\"hljs-number\">8</span>],\n        <span class=\"hljs-number\">5</span>: [<span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>],\n        <span class=\"hljs-number\">6</span>: [<span class=\"hljs-number\">11</span>],\n        <span class=\"hljs-number\">7</span>: [],\n        <span class=\"hljs-number\">8</span>: [<span class=\"hljs-number\">12</span>, <span class=\"hljs-number\">13</span>],\n        <span class=\"hljs-number\">9</span>: [],\n        <span class=\"hljs-number\">10</span>: [],\n        <span class=\"hljs-number\">11</span>: [],\n        <span class=\"hljs-number\">12</span>: [],\n        <span class=\"hljs-number\">13</span>: [],\n    }\n    level, parent = breadth_first_search(level, parent, max_node, graph, <span class=\"hljs-number\">1</span>)\n    parent = create_sparse(max_node, parent)\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 1 and 3 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, level, parent))\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 5 and 6 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, level, parent))\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 7 and 11 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>, level, parent))\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 6 and 7 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, level, parent))\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 4 and 12 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">12</span>, level, parent))\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;LCA of node 8 and 8 is: &quot;</span>, lowest_common_ancestor(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">8</span>, level, parent))\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    main()\n"
    },
    "c-plus-plus": {
      "dir": "graph/lowest_common_ancestor.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph/lowest_common_ancestor.cpp",
      "code": "<span class=\"hljs-comment\">/**\n *\n * \\file\n *\n * \\brief Data structure for finding the lowest common ancestor\n * of two vertices in a rooted tree using binary lifting.\n *\n * \\details\n * Algorithm: https://cp-algorithms.com/graph/lca_binary_lifting.html\n *\n * Complexity:\n *   - Precomputation: \\f$O(N \\log N)\\f$ where \\f$N\\f$ is the number of vertices\n * in the tree\n *   - Query: \\f$O(\\log N)\\f$\n *   - Space: \\f$O(N \\log N)\\f$\n *\n * Example:\n * &lt;br/&gt;  Tree:\n * &lt;pre&gt;\n *             _  3  _\n *          /     |     \\\n *        1       6       4\n *      / |     /   \\       \\\n *    7   5   2       8       0\n *            |\n *            9\n * &lt;/pre&gt;\n *\n * &lt;br/&gt;  lowest_common_ancestor(7, 4) = 3\n * &lt;br/&gt;  lowest_common_ancestor(9, 6) = 6\n * &lt;br/&gt;  lowest_common_ancestor(0, 0) = 0\n * &lt;br/&gt;  lowest_common_ancestor(8, 2) = 6\n *\n *   The query is symmetrical, therefore\n *     lowest_common_ancestor(x, y) = lowest_common_ancestor(y, x)\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;utility&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-comment\">/**\n * \\namespace graph\n * \\brief Graph algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> graph {\n<span class=\"hljs-comment\">/**\n * Class for representing a graph as an adjacency list.\n * Its vertices are indexed 0, 1, ..., N - 1.\n */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span> {\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">/**\n     * \\brief Populate the adjacency list for each vertex in the graph.\n     * Assumes that evey edge is a pair of valid vertex indices.\n     *\n     * @param N number of vertices in the graph\n     * @param undirected_edges list of graph&#x27;s undirected edges\n     */</span>\n    <span class=\"hljs-built_in\">Graph</span>(<span class=\"hljs-type\">size_t</span> N, <span class=\"hljs-type\">const</span> std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; &gt; &amp;undirected_edges) {\n        neighbors.<span class=\"hljs-built_in\">resize</span>(N);\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> &amp;edge : undirected_edges) {\n            neighbors[edge.first].<span class=\"hljs-built_in\">push_back</span>(edge.second);\n            neighbors[edge.second].<span class=\"hljs-built_in\">push_back</span>(edge.first);\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Function to get the number of vertices in the graph\n     * @return the number of vertices in the graph.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">number_of_vertices</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span> </span>{ <span class=\"hljs-keyword\">return</span> neighbors.<span class=\"hljs-built_in\">size</span>(); }\n\n    <span class=\"hljs-comment\">/** \\brief for each vertex it stores a list indicies of its neighbors */</span>\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; neighbors;\n};\n\n<span class=\"hljs-comment\">/**\n * Representation of a rooted tree. For every vertex its parent is\n * precalculated.\n */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RootedTree</span> : <span class=\"hljs-keyword\">public</span> Graph {\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">/**\n     * \\brief Constructs the tree by calculating parent for every vertex.\n     * Assumes a valid description of a tree is provided.\n     *\n     * @param undirected_edges list of graph&#x27;s undirected edges\n     * @param root_ index of the root vertex\n     */</span>\n    <span class=\"hljs-built_in\">RootedTree</span>(<span class=\"hljs-type\">const</span> std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; &gt; &amp;undirected_edges,\n               <span class=\"hljs-type\">int</span> root_)\n        : <span class=\"hljs-built_in\">Graph</span>(undirected_edges.<span class=\"hljs-built_in\">size</span>() + <span class=\"hljs-number\">1</span>, undirected_edges), <span class=\"hljs-built_in\">root</span>(root_) {\n        <span class=\"hljs-built_in\">populate_parents</span>();\n    }\n\n    <span class=\"hljs-comment\">/**\n     * \\brief Stores parent of every vertex and for root its own index.\n     * The root is technically not its own parent, but it&#x27;s very practical\n     * for the lowest common ancestor algorithm.\n     */</span>\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; parent;\n    <span class=\"hljs-comment\">/** \\brief Stores the distance from the root. */</span>\n    std::vector&lt;<span class=\"hljs-type\">int</span>&gt; level;\n    <span class=\"hljs-comment\">/** \\brief Index of the root vertex. */</span>\n    <span class=\"hljs-type\">int</span> root;\n\n <span class=\"hljs-keyword\">protected</span>:\n    <span class=\"hljs-comment\">/**\n     * \\brief Calculate the parents for all the vertices in the tree.\n     * Implements the breadth first search algorithm starting from the root\n     * vertex searching the entire tree and labeling parents for all vertices.\n     * @returns none\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">populate_parents</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-comment\">// Initialize the vector with -1 which indicates the vertex</span>\n        <span class=\"hljs-comment\">// wasn&#x27;t yet visited.</span>\n        parent = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(<span class=\"hljs-built_in\">number_of_vertices</span>(), <span class=\"hljs-number\">-1</span>);\n        level = std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;(<span class=\"hljs-built_in\">number_of_vertices</span>());\n        parent[root] = root;\n        level[root] = <span class=\"hljs-number\">0</span>;\n        std::queue&lt;<span class=\"hljs-type\">int</span>&gt; queue_of_vertices;\n        queue_of_vertices.<span class=\"hljs-built_in\">push</span>(root);\n        <span class=\"hljs-keyword\">while</span> (!queue_of_vertices.<span class=\"hljs-built_in\">empty</span>()) {\n            <span class=\"hljs-type\">int</span> vertex = queue_of_vertices.<span class=\"hljs-built_in\">front</span>();\n            queue_of_vertices.<span class=\"hljs-built_in\">pop</span>();\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> neighbor : neighbors[vertex]) {\n                <span class=\"hljs-comment\">// As long as the vertex was not yet visited.</span>\n                <span class=\"hljs-keyword\">if</span> (parent[neighbor] == <span class=\"hljs-number\">-1</span>) {\n                    parent[neighbor] = vertex;\n                    level[neighbor] = level[vertex] + <span class=\"hljs-number\">1</span>;\n                    queue_of_vertices.<span class=\"hljs-built_in\">push</span>(neighbor);\n                }\n            }\n        }\n    }\n};\n\n<span class=\"hljs-comment\">/**\n * A structure that holds a rooted tree and allow for effecient\n * queries of the lowest common ancestor of two given vertices in the tree.\n */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">LowestCommonAncestor</span> {\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">/**\n     * \\brief Stores the tree and precomputs &quot;up lifts&quot;.\n     * @param tree_ rooted tree.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">LowestCommonAncestor</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> RootedTree &amp;tree_)</span> : tree(tree_) {</span>\n        <span class=\"hljs-built_in\">populate_up</span>();\n    }\n\n    <span class=\"hljs-comment\">/**\n     * \\brief Query the structure to find the lowest common ancestor.\n     * Assumes that the provided numbers are valid indices of vertices.\n     * Iterativelly modifies (&quot;lifts&quot;) u an v until it finnds their lowest\n     * common ancestor.\n     * @param u index of one of the queried vertex\n     * @param v index of the other queried vertex\n     * @return index of the vertex which is the lowet common ancestor of u and v\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">lowest_common_ancestor</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> u, <span class=\"hljs-type\">int</span> v)</span> <span class=\"hljs-type\">const</span> </span>{\n        <span class=\"hljs-comment\">// Ensure u is the deeper (higher level) of the two vertices</span>\n        <span class=\"hljs-keyword\">if</span> (tree.level[v] &gt; tree.level[u]) {\n            std::<span class=\"hljs-built_in\">swap</span>(u, v);\n        }\n\n        <span class=\"hljs-comment\">// &quot;Lift&quot; u to the same level as v.</span>\n        <span class=\"hljs-type\">int</span> level_diff = tree.level[u] - tree.level[v];\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; (<span class=\"hljs-number\">1</span> &lt;&lt; i) &lt;= level_diff; ++i) {\n            <span class=\"hljs-keyword\">if</span> (level_diff &amp; (<span class=\"hljs-number\">1</span> &lt;&lt; i)) {\n                u = up[u][i];\n            }\n        }\n        <span class=\"hljs-built_in\">assert</span>(tree.level[u] == tree.level[v]);\n\n        <span class=\"hljs-keyword\">if</span> (u == v) {\n            <span class=\"hljs-keyword\">return</span> u;\n        }\n\n        <span class=\"hljs-comment\">// &quot;Lift&quot; u and v to their 2^i th ancestor if they are different</span>\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-built_in\">static_cast</span>&lt;<span class=\"hljs-type\">int</span>&gt;(up[u].<span class=\"hljs-built_in\">size</span>()) - <span class=\"hljs-number\">1</span>; i &gt;= <span class=\"hljs-number\">0</span>; --i) {\n            <span class=\"hljs-keyword\">if</span> (up[u][i] != up[v][i]) {\n                u = up[u][i];\n                v = up[v][i];\n            }\n        }\n\n        <span class=\"hljs-comment\">// As we regressed u an v such that they cannot further be lifted so</span>\n        <span class=\"hljs-comment\">// that their ancestor would be different, the only logical</span>\n        <span class=\"hljs-comment\">// consequence is that their parent is the sought answer.</span>\n        <span class=\"hljs-built_in\">assert</span>(up[u][<span class=\"hljs-number\">0</span>] == up[v][<span class=\"hljs-number\">0</span>]);\n        <span class=\"hljs-keyword\">return</span> up[u][<span class=\"hljs-number\">0</span>];\n    }\n\n    <span class=\"hljs-comment\">/* \\brief reference to the rooted tree this structure allows to query */</span>\n    <span class=\"hljs-type\">const</span> RootedTree &amp;tree;\n    <span class=\"hljs-comment\">/**\n     * \\brief for every vertex stores a list of its ancestors by powers of two\n     * For each vertex, the first element of the corresponding list contains\n     * the index of its parent. The i-th element of the list is an index of\n     * the (2^i)-th ancestor of the vertex.\n     */</span>\n    std::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt; &gt; up;\n\n <span class=\"hljs-keyword\">protected</span>:\n    <span class=\"hljs-comment\">/**\n     * Populate the &quot;up&quot; structure. See above.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">populate_up</span><span class=\"hljs-params\">()</span> </span>{\n        up.<span class=\"hljs-built_in\">resize</span>(tree.<span class=\"hljs-built_in\">number_of_vertices</span>());\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> vertex = <span class=\"hljs-number\">0</span>; vertex &lt; tree.<span class=\"hljs-built_in\">number_of_vertices</span>(); ++vertex) {\n            up[vertex].<span class=\"hljs-built_in\">push_back</span>(tree.parent[vertex]);\n        }\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> level = <span class=\"hljs-number\">0</span>; (<span class=\"hljs-number\">1</span> &lt;&lt; level) &lt; tree.<span class=\"hljs-built_in\">number_of_vertices</span>(); ++level) {\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> vertex = <span class=\"hljs-number\">0</span>; vertex &lt; tree.<span class=\"hljs-built_in\">number_of_vertices</span>(); ++vertex) {\n                <span class=\"hljs-comment\">// up[vertex][level + 1] = 2^(level + 1) th ancestor of vertex =</span>\n                <span class=\"hljs-comment\">// = 2^level th ancestor of 2^level th ancestor of vertex =</span>\n                <span class=\"hljs-comment\">// = 2^level th ancestor of up[vertex][level]</span>\n                up[vertex].<span class=\"hljs-built_in\">push_back</span>(up[up[vertex][level]][level]);\n            }\n        }\n    }\n};\n\n}  <span class=\"hljs-comment\">// namespace graph</span>\n\n<span class=\"hljs-comment\">/**\n * Unit tests\n * @returns none\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">tests</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-comment\">/**\n     *             _  3  _\n     *          /     |     \\\n     *        1       6       4\n     *      / |     /   \\       \\\n     *    7   5   2       8       0\n     *            |\n     *            9\n     */</span>\n    std::vector&lt;std::pair&lt;<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>&gt; &gt; edges = {\n        {<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">1</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>}, {<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>}, {<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>}, {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">9</span>}, {<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>}, {<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>}, {<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">4</span>}};\n    <span class=\"hljs-function\">graph::RootedTree <span class=\"hljs-title\">t</span><span class=\"hljs-params\">(edges, <span class=\"hljs-number\">3</span>)</span></span>;\n    <span class=\"hljs-function\">graph::LowestCommonAncestor <span class=\"hljs-title\">lca</span><span class=\"hljs-params\">(t)</span></span>;\n    <span class=\"hljs-built_in\">assert</span>(lca.<span class=\"hljs-built_in\">lowest_common_ancestor</span>(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">4</span>) == <span class=\"hljs-number\">3</span>);\n    <span class=\"hljs-built_in\">assert</span>(lca.<span class=\"hljs-built_in\">lowest_common_ancestor</span>(<span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">6</span>) == <span class=\"hljs-number\">6</span>);\n    <span class=\"hljs-built_in\">assert</span>(lca.<span class=\"hljs-built_in\">lowest_common_ancestor</span>(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>) == <span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-built_in\">assert</span>(lca.<span class=\"hljs-built_in\">lowest_common_ancestor</span>(<span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">2</span>) == <span class=\"hljs-number\">6</span>);\n}\n\n<span class=\"hljs-comment\">/** Main function */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">tests</span>();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "go": {
      "dir": "graph/lowestcommonancestor.go",
      "url": "https://github.com/TheAlgorithms/go/tree/master/graph/lowestcommonancestor.go",
      "code": "<span class=\"hljs-comment\">// lowestcommonancestor.go</span>\n<span class=\"hljs-comment\">// description: Implementation of Lowest common ancestor (LCA) algorithm.</span>\n<span class=\"hljs-comment\">// detail:</span>\n<span class=\"hljs-comment\">// Let `T` be a tree. The LCA of `u` and `v` in T is the shared ancestor of `u` and `v`</span>\n<span class=\"hljs-comment\">// that is located farthest from the root.</span>\n<span class=\"hljs-comment\">// references: [cp-algorithms](https://cp-algorithms.com/graph/lca_binary_lifting.html)</span>\n<span class=\"hljs-comment\">// author(s) [Dat](https://github.com/datbeohbbh)</span>\n<span class=\"hljs-comment\">// see lowestcommonancestor_test.go for a test implementation.</span>\n\n<span class=\"hljs-keyword\">package</span> graph\n\n<span class=\"hljs-keyword\">type</span> TreeEdge <span class=\"hljs-keyword\">struct</span> {\n\tfrom <span class=\"hljs-type\">int</span>\n\tto   <span class=\"hljs-type\">int</span>\n}\n\n<span class=\"hljs-keyword\">type</span> ITree <span class=\"hljs-keyword\">interface</span> {\n\tdfs(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>)\n\taddEdge(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>)\n\tGetDepth(<span class=\"hljs-type\">int</span>) <span class=\"hljs-type\">int</span>\n\tGetDad(<span class=\"hljs-type\">int</span>) <span class=\"hljs-type\">int</span>\n\tGetLCA(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>) <span class=\"hljs-type\">int</span>\n}\n\n<span class=\"hljs-keyword\">type</span> Tree <span class=\"hljs-keyword\">struct</span> {\n\tnumbersVertex <span class=\"hljs-type\">int</span>\n\troot          <span class=\"hljs-type\">int</span>\n\tMAXLOG        <span class=\"hljs-type\">int</span>\n\tdepth         []<span class=\"hljs-type\">int</span>\n\tdad           []<span class=\"hljs-type\">int</span>\n\tjump          [][]<span class=\"hljs-type\">int</span>\n\tedges         [][]<span class=\"hljs-type\">int</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(tree *Tree)</span></span> addEdge(u, v <span class=\"hljs-type\">int</span>) {\n\ttree.edges[u] = <span class=\"hljs-built_in\">append</span>(tree.edges[u], v)\n\ttree.edges[v] = <span class=\"hljs-built_in\">append</span>(tree.edges[v], u)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(tree *Tree)</span></span> dfs(u, par <span class=\"hljs-type\">int</span>) {\n\ttree.jump[<span class=\"hljs-number\">0</span>][u] = par\n\ttree.dad[u] = par\n\t<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> tree.edges[u] {\n\t\t<span class=\"hljs-keyword\">if</span> v != par {\n\t\t\ttree.depth[v] = tree.depth[u] + <span class=\"hljs-number\">1</span>\n\t\t\ttree.dfs(v, u)\n\t\t}\n\t}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(tree *Tree)</span></span> GetDepth(u <span class=\"hljs-type\">int</span>) <span class=\"hljs-type\">int</span> {\n\t<span class=\"hljs-keyword\">return</span> tree.depth[u]\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(tree *Tree)</span></span> GetDad(u <span class=\"hljs-type\">int</span>) <span class=\"hljs-type\">int</span> {\n\t<span class=\"hljs-keyword\">return</span> tree.dad[u]\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(tree *Tree)</span></span> GetLCA(u, v <span class=\"hljs-type\">int</span>) <span class=\"hljs-type\">int</span> {\n\t<span class=\"hljs-keyword\">if</span> tree.GetDepth(u) &lt; tree.GetDepth(v) {\n\t\tu, v = v, u\n\t}\n\n\t<span class=\"hljs-keyword\">for</span> j := tree.MAXLOG - <span class=\"hljs-number\">1</span>; j &gt;= <span class=\"hljs-number\">0</span>; j-- {\n\t\t<span class=\"hljs-keyword\">if</span> tree.GetDepth(tree.jump[j][u]) &gt;= tree.GetDepth(v) {\n\t\t\tu = tree.jump[j][u]\n\t\t}\n\t}\n\n\t<span class=\"hljs-keyword\">if</span> u == v {\n\t\t<span class=\"hljs-keyword\">return</span> u\n\t}\n\n\t<span class=\"hljs-keyword\">for</span> j := tree.MAXLOG - <span class=\"hljs-number\">1</span>; j &gt;= <span class=\"hljs-number\">0</span>; j-- {\n\t\t<span class=\"hljs-keyword\">if</span> tree.jump[j][u] != tree.jump[j][v] {\n\t\t\tu = tree.jump[j][u]\n\t\t\tv = tree.jump[j][v]\n\t\t}\n\t}\n\n\t<span class=\"hljs-keyword\">return</span> tree.jump[<span class=\"hljs-number\">0</span>][u]\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewTree</span><span class=\"hljs-params\">(numbersVertex, root <span class=\"hljs-type\">int</span>, edges []TreeEdge)</span></span> (tree *Tree) {\n\ttree = <span class=\"hljs-built_in\">new</span>(Tree)\n\ttree.numbersVertex, tree.root, tree.MAXLOG = numbersVertex, root, <span class=\"hljs-number\">0</span>\n\ttree.depth = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, numbersVertex)\n\ttree.dad = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, numbersVertex)\n\n\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-number\">1</span> &lt;&lt; tree.MAXLOG) &lt;= numbersVertex {\n\t\t(tree.MAXLOG) += <span class=\"hljs-number\">1</span>\n\t}\n\t(tree.MAXLOG) += <span class=\"hljs-number\">1</span>\n\n\ttree.jump = <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, tree.MAXLOG)\n\t<span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">0</span>; j &lt; tree.MAXLOG; j++ {\n\t\ttree.jump[j] = <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, numbersVertex)\n\t}\n\n\ttree.edges = <span class=\"hljs-built_in\">make</span>([][]<span class=\"hljs-type\">int</span>, numbersVertex)\n\t<span class=\"hljs-keyword\">for</span> _, e := <span class=\"hljs-keyword\">range</span> edges {\n\t\ttree.addEdge(e.from, e.to)\n\t}\n\n\t<span class=\"hljs-keyword\">return</span> tree\n}\n\n<span class=\"hljs-comment\">// For each node, we will precompute its ancestor above him, its ancestor two nodes above, its ancestor four nodes above, etc.</span>\n<span class=\"hljs-comment\">// Let&#x27;s call `jump[j][u]` is the `2^j`-th ancestor above the node `u` with `u` in range `[0, numbersVertex)`, `j` in range `[0,MAXLOG)`.</span>\n<span class=\"hljs-comment\">// These information allow us to jump from any node to any ancestor above it in `O(MAXLOG)` time.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">LowestCommonAncestor</span><span class=\"hljs-params\">(tree *Tree)</span></span> {\n\t<span class=\"hljs-comment\">// call dfs to compute depth from the root to each node and the parent of each node.</span>\n\ttree.dfs(tree.root, tree.root)\n\n\t<span class=\"hljs-comment\">// compute jump[j][u]</span>\n\t<span class=\"hljs-keyword\">for</span> j := <span class=\"hljs-number\">1</span>; j &lt; tree.MAXLOG; j++ {\n\t\t<span class=\"hljs-keyword\">for</span> u := <span class=\"hljs-number\">0</span>; u &lt; tree.numbersVertex; u++ {\n\t\t\ttree.jump[j][u] = tree.jump[j<span class=\"hljs-number\">-1</span>][tree.jump[j<span class=\"hljs-number\">-1</span>][u]]\n\t\t}\n\t}\n}\n"
    },
    "rust": {
      "dir": "src/graph/lowest_common_ancestor.rs",
      "url": "https://github.com/TheAlgorithms/rust/tree/master/src/graph/lowest_common_ancestor.rs",
      "code": "<span class=\"hljs-comment\">/*\n Note: We will assume that here tree vertices are numbered from 1 to n.\nIf a tree is not enumerated that way or its vertices are not represented\nusing numbers, it can trivially be converted using Depth First Search\nmanually or by using `src/graph/graph_enumeration.rs`\n\n Here we implement two different algorithms:\n- The online one is implemented using Sparse Table and has O(n.lg(n))\ntime complexity and memory usage. It answers each query in O(lg(n)).\n- The offline algorithm was discovered by Robert Tarjan. At first each\nquery should be determined and saved. Then, vertices are visited in\nDepth First Search order and queries are answered using Disjoint\nSet Union algorithm. The time complexity is O(n.alpha(n) + q) and\nmemory usage is O(n + q), but time complexity can be considered to be O(n + q),\nbecause alpha(n) &lt; 5 for n &lt; 10 ^ 600\n */</span>\n\n<span class=\"hljs-keyword\">use</span> super::DisjointSetUnion;\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">LowestCommonAncestorOnline</span> {\n    <span class=\"hljs-comment\">// Make members public to allow the user to fill them themself.</span>\n    <span class=\"hljs-keyword\">pub</span> parents_sparse_table: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">usize</span>&gt;&gt;,\n    <span class=\"hljs-keyword\">pub</span> height: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">usize</span>&gt;,\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">LowestCommonAncestorOnline</span> {\n    <span class=\"hljs-comment\">// Should be called once as:</span>\n    <span class=\"hljs-comment\">// fill_sparse_table(tree_root, 0, 0, adjacency_list)</span>\n    <span class=\"hljs-meta\">#[inline]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">get_parent</span>(&amp;<span class=\"hljs-keyword\">self</span>, v: <span class=\"hljs-type\">usize</span>, i: <span class=\"hljs-type\">usize</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">usize</span> {\n        <span class=\"hljs-keyword\">self</span>.parents_sparse_table[v][i]\n    }\n    <span class=\"hljs-meta\">#[inline]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">num_parents</span>(&amp;<span class=\"hljs-keyword\">self</span>, v: <span class=\"hljs-type\">usize</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">usize</span> {\n        <span class=\"hljs-keyword\">self</span>.parents_sparse_table[v].<span class=\"hljs-title function_ invoke__\">len</span>()\n    }\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">new</span>(num_vertices: <span class=\"hljs-type\">usize</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">pars</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>]; num_vertices + <span class=\"hljs-number\">1</span>];\n        pars[<span class=\"hljs-number\">0</span>].<span class=\"hljs-title function_ invoke__\">clear</span>();\n        LowestCommonAncestorOnline {\n            parents_sparse_table: pars,\n            height: <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>; num_vertices + <span class=\"hljs-number\">1</span>],\n        }\n    }\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">fill_sparse_table</span>(\n        &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>,\n        vertex: <span class=\"hljs-type\">usize</span>,\n        parent: <span class=\"hljs-type\">usize</span>,\n        height: <span class=\"hljs-type\">usize</span>,\n        adj: &amp;[<span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">usize</span>&gt;],\n    ) {\n        <span class=\"hljs-keyword\">self</span>.parents_sparse_table[vertex][<span class=\"hljs-number\">0</span>] = parent;\n        <span class=\"hljs-keyword\">self</span>.height[vertex] = height;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">level</span> = <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">current_parent</span> = parent;\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">num_parents</span>(current_parent) &gt;= level {\n            current_parent = <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">get_parent</span>(current_parent, level - <span class=\"hljs-number\">1</span>);\n            level += <span class=\"hljs-number\">1</span>;\n            <span class=\"hljs-keyword\">self</span>.parents_sparse_table[vertex].<span class=\"hljs-title function_ invoke__\">push</span>(current_parent);\n        }\n        <span class=\"hljs-keyword\">for</span> &amp;child <span class=\"hljs-keyword\">in</span> adj[vertex].<span class=\"hljs-title function_ invoke__\">iter</span>() {\n            <span class=\"hljs-keyword\">if</span> child == parent {\n                <span class=\"hljs-comment\">// It isn&#x27;t a child!</span>\n                <span class=\"hljs-keyword\">continue</span>;\n            }\n            <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">fill_sparse_table</span>(child, vertex, height + <span class=\"hljs-number\">1</span>, adj);\n        }\n    }\n\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">get_ancestor</span>(&amp;<span class=\"hljs-keyword\">self</span>, <span class=\"hljs-keyword\">mut</span> v: <span class=\"hljs-type\">usize</span>, <span class=\"hljs-keyword\">mut</span> u: <span class=\"hljs-type\">usize</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">usize</span> {\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.height[v] &lt; <span class=\"hljs-keyword\">self</span>.height[u] {\n            std::mem::<span class=\"hljs-title function_ invoke__\">swap</span>(&amp;<span class=\"hljs-keyword\">mut</span> v, &amp;<span class=\"hljs-keyword\">mut</span> u);\n        }\n        <span class=\"hljs-comment\">// Bring v up to so that it has the same height as u</span>\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">height_diff</span> = <span class=\"hljs-keyword\">self</span>.height[v] - <span class=\"hljs-keyword\">self</span>.height[u];\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..<span class=\"hljs-number\">63</span> {\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">bit</span> = <span class=\"hljs-number\">1</span> &lt;&lt; i;\n            <span class=\"hljs-keyword\">if</span> bit &gt; height_diff {\n                <span class=\"hljs-keyword\">break</span>;\n            }\n            <span class=\"hljs-keyword\">if</span> height_diff &amp; bit != <span class=\"hljs-number\">0</span> {\n                v = <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">get_parent</span>(v, i);\n            }\n        }\n        <span class=\"hljs-keyword\">if</span> u == v {\n            <span class=\"hljs-keyword\">return</span> u;\n        }\n        <span class=\"hljs-comment\">// `self.num_parents` of u and v should be equal</span>\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-number\">0</span>..<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">num_parents</span>(v)).<span class=\"hljs-title function_ invoke__\">rev</span>() {\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">nv</span> = <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">get_parent</span>(v, i);\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">nu</span> = <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">get_parent</span>(u, i);\n            <span class=\"hljs-keyword\">if</span> nv != nu {\n                u = nu;\n                v = nv;\n            }\n        }\n        <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">get_parent</span>(v, <span class=\"hljs-number\">0</span>)\n    }\n}\n\n<span class=\"hljs-meta\">#[derive(Clone, Copy)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">LCAQuery</span> {\n    other: <span class=\"hljs-type\">usize</span>,\n    query_id: <span class=\"hljs-type\">usize</span>,\n}\n\n<span class=\"hljs-meta\">#[derive(Clone, Copy, Debug, PartialEq, Eq)]</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">QueryAnswer</span> {\n    query_id: <span class=\"hljs-type\">usize</span>,\n    answer: <span class=\"hljs-type\">usize</span>,\n}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">LowestCommonAncestorOffline</span> {\n    <span class=\"hljs-keyword\">pub</span> queries: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">Vec</span>&lt;LCAQuery&gt;&gt;,\n    dsu: DisjointSetUnion,\n    <span class=\"hljs-comment\">/*\n    The LSB of dsu_parent[v] determines whether it was visited or not.\n    The rest of the number determines the vertex that represents a\n    particular set in DSU.\n    */</span>\n    dsu_parent: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">u64</span>&gt;,\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">LowestCommonAncestorOffline</span> {\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">new</span>(num_vertices: <span class=\"hljs-type\">usize</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\n        LowestCommonAncestorOffline {\n            queries: <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-built_in\">vec!</span>[]; num_vertices + <span class=\"hljs-number\">1</span>],\n            dsu: DisjointSetUnion::<span class=\"hljs-title function_ invoke__\">new</span>(num_vertices),\n            dsu_parent: <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>; num_vertices + <span class=\"hljs-number\">1</span>],\n        }\n    }\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">add_query</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, u: <span class=\"hljs-type\">usize</span>, v: <span class=\"hljs-type\">usize</span>, query_id: <span class=\"hljs-type\">usize</span>) {\n        <span class=\"hljs-comment\">// We should add this query to both vertices, and it will be answered</span>\n        <span class=\"hljs-comment\">// the second time it is seen in DFS.</span>\n        <span class=\"hljs-keyword\">self</span>.queries[u].<span class=\"hljs-title function_ invoke__\">push</span>(LCAQuery { other: v, query_id });\n        <span class=\"hljs-keyword\">if</span> u == v {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n        <span class=\"hljs-keyword\">self</span>.queries[v].<span class=\"hljs-title function_ invoke__\">push</span>(LCAQuery { other: u, query_id });\n    }\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">calculate_answers</span>(\n        &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>,\n        vertex: <span class=\"hljs-type\">usize</span>,\n        parent: <span class=\"hljs-type\">usize</span>,\n        adj: &amp;[<span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">usize</span>&gt;],\n        answers: &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-type\">Vec</span>&lt;QueryAnswer&gt;,\n    ) {\n        <span class=\"hljs-keyword\">self</span>.dsu_parent[vertex] = (vertex <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u64</span>) &lt;&lt; <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-keyword\">for</span> &amp;child <span class=\"hljs-keyword\">in</span> adj[vertex].<span class=\"hljs-title function_ invoke__\">iter</span>() {\n            <span class=\"hljs-keyword\">if</span> child == parent {\n                <span class=\"hljs-keyword\">continue</span>;\n            }\n            <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">calculate_answers</span>(child, vertex, adj, answers);\n            <span class=\"hljs-keyword\">self</span>.dsu.<span class=\"hljs-title function_ invoke__\">merge</span>(child, vertex);\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">set</span> = <span class=\"hljs-keyword\">self</span>.dsu.<span class=\"hljs-title function_ invoke__\">find_set</span>(vertex);\n            <span class=\"hljs-keyword\">self</span>.dsu_parent[set] = ((vertex <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u64</span>) &lt;&lt; <span class=\"hljs-number\">1</span>) | (<span class=\"hljs-keyword\">self</span>.dsu_parent[set] &amp; <span class=\"hljs-number\">1</span>);\n        }\n        <span class=\"hljs-keyword\">self</span>.dsu_parent[vertex] |= <span class=\"hljs-number\">0b1</span>;\n        <span class=\"hljs-keyword\">for</span> &amp;query <span class=\"hljs-keyword\">in</span> <span class=\"hljs-keyword\">self</span>.queries[vertex].<span class=\"hljs-title function_ invoke__\">iter</span>() {\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">self</span>.dsu_parent[query.other] &amp; <span class=\"hljs-number\">1</span> != <span class=\"hljs-number\">0</span> {\n                <span class=\"hljs-comment\">// It has been visited</span>\n                answers.<span class=\"hljs-title function_ invoke__\">push</span>(QueryAnswer {\n                    query_id: query.query_id,\n                    answer: (<span class=\"hljs-keyword\">self</span>.dsu_parent[<span class=\"hljs-keyword\">self</span>.dsu.<span class=\"hljs-title function_ invoke__\">find_set</span>(query.other)] &gt;&gt; <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">usize</span>,\n                });\n            }\n        }\n    }\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">answer_queries</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, root: <span class=\"hljs-type\">usize</span>, adj: &amp;[<span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">usize</span>&gt;]) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Vec</span>&lt;QueryAnswer&gt; {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">answers</span> = Vec::<span class=\"hljs-title function_ invoke__\">new</span>();\n        <span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">calculate_answers</span>(root, <span class=\"hljs-number\">0</span>, adj, &amp;<span class=\"hljs-keyword\">mut</span> answers);\n        answers\n    }\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::*;\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">small_binary_tree</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">num_verts</span> = <span class=\"hljs-number\">127</span>;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">tree</span>: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">usize</span>&gt;&gt; = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-built_in\">vec!</span>[]; num_verts + <span class=\"hljs-number\">1</span>];\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..=num_verts &gt;&gt; <span class=\"hljs-number\">1</span> {\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">left_child</span> = i &lt;&lt; <span class=\"hljs-number\">1</span>;\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">right_child</span> = left_child + <span class=\"hljs-number\">1</span>;\n            tree[i].<span class=\"hljs-title function_ invoke__\">push</span>(left_child);\n            tree[i].<span class=\"hljs-title function_ invoke__\">push</span>(right_child);\n            tree[left_child].<span class=\"hljs-title function_ invoke__\">push</span>(i);\n            tree[right_child].<span class=\"hljs-title function_ invoke__\">push</span>(i);\n        }\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">online_answers</span>: <span class=\"hljs-type\">Vec</span>&lt;QueryAnswer&gt; = Vec::<span class=\"hljs-title function_ invoke__\">new</span>();\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">online</span> = LowestCommonAncestorOnline::<span class=\"hljs-title function_ invoke__\">new</span>(num_verts);\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">offline</span> = LowestCommonAncestorOffline::<span class=\"hljs-title function_ invoke__\">new</span>(num_verts);\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">query_id</span> = <span class=\"hljs-number\">314</span>; <span class=\"hljs-comment\">// A random number, doesn&#x27;t matter</span>\n        online.<span class=\"hljs-title function_ invoke__\">fill_sparse_table</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, &amp;tree);\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..=num_verts {\n            <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..i {\n                <span class=\"hljs-comment\">// Query every possible pair</span>\n                online_answers.<span class=\"hljs-title function_ invoke__\">push</span>(QueryAnswer {\n                    query_id,\n                    answer: online.<span class=\"hljs-title function_ invoke__\">get_ancestor</span>(i, j),\n                });\n                offline.<span class=\"hljs-title function_ invoke__\">add_query</span>(i, j, query_id);\n                query_id += <span class=\"hljs-number\">1</span>;\n            }\n        }\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">offline_answers</span> = offline.<span class=\"hljs-title function_ invoke__\">answer_queries</span>(<span class=\"hljs-number\">1</span>, &amp;tree);\n        offline_answers.<span class=\"hljs-title function_ invoke__\">sort_unstable_by</span>(|a1, a2| a1.query_id.<span class=\"hljs-title function_ invoke__\">cmp</span>(&amp;a2.query_id));\n        <span class=\"hljs-built_in\">assert_eq!</span>(offline_answers, online_answers);\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "David Leal",
      "email": "halfpacho@gmail.com",
      "commits": 1
    },
    {
      "name": "Erfan Khadem",
      "email": "45465346+er888kh@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Nguyn Tin t",
      "email": "phongtomfapp@gmail.com",
      "commits": 1
    },
    {
      "name": "Dylan Buchi",
      "email": "devybuchi@gmail.com",
      "commits": 1
    },
    {
      "name": "kanthuc",
      "email": "srikanthuchavali@gmail.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 2
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 3
    }
  ],
  "explanationUrl": {}
}