{
  "slug": "monte-carlo-tree-search",
  "name": "Monte Carlo Tree Search",
  "categories": [
    "searches"
  ],
  "body": {},
  "implementations": {
    "java": {
      "dir": "src/main/java/com/thealgorithms/searches/MonteCarloTreeSearch.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src/main/java/com/thealgorithms/searches/MonteCarloTreeSearch.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.searches;\n\n<span class=\"hljs-keyword\">import</span> java.util.Collections;\n<span class=\"hljs-keyword\">import</span> java.util.ArrayList;\n<span class=\"hljs-keyword\">import</span> java.util.Comparator;\n<span class=\"hljs-keyword\">import</span> java.util.Random;\n\n<span class=\"hljs-comment\">/**\n * Monte Carlo Tree Search (MCTS) is a heuristic search algorithm used in\n * decition taking problems especially games.\n *\n * See more: https://en.wikipedia.org/wiki/Monte_Carlo_tree_search,\n * https://www.baeldung.com/java-monte-carlo-tree-search\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MonteCarloTreeSearch</span> {\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Node</span> {\n\n        Node parent;\n        ArrayList&lt;Node&gt; childNodes;\n        <span class=\"hljs-type\">boolean</span> isPlayersTurn; <span class=\"hljs-comment\">// True if it is the player&#x27;s turn.</span>\n        <span class=\"hljs-type\">boolean</span> playerWon; <span class=\"hljs-comment\">// True if the player won; false if the opponent won.</span>\n        <span class=\"hljs-type\">int</span> score;\n        <span class=\"hljs-type\">int</span> visitCount;\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Node</span><span class=\"hljs-params\">()</span> {\n        }\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Node</span><span class=\"hljs-params\">(Node parent, <span class=\"hljs-type\">boolean</span> isPlayersTurn)</span> {\n            <span class=\"hljs-built_in\">this</span>.parent = parent;\n            childNodes = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();\n            <span class=\"hljs-built_in\">this</span>.isPlayersTurn = isPlayersTurn;\n            playerWon = <span class=\"hljs-literal\">false</span>;\n            score = <span class=\"hljs-number\">0</span>;\n            visitCount = <span class=\"hljs-number\">0</span>;\n        }\n    }\n\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">WIN_SCORE</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">10</span>;\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">TIME_LIMIT</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">500</span>; <span class=\"hljs-comment\">// Time the algorithm will be running for (in milliseconds).</span>\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n        <span class=\"hljs-type\">MonteCarloTreeSearch</span> <span class=\"hljs-variable\">mcts</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">MonteCarloTreeSearch</span>();\n\n        mcts.monteCarloTreeSearch(mcts.<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(<span class=\"hljs-literal\">null</span>, <span class=\"hljs-literal\">true</span>));\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Explores a game tree using Monte Carlo Tree Search (MCTS) and returns the\n     * most promising node.\n     *\n     * <span class=\"hljs-doctag\">@param</span> rootNode Root node of the game tree.\n     * <span class=\"hljs-doctag\">@return</span> The most promising child of the root node.\n     */</span>\n    <span class=\"hljs-keyword\">public</span> Node <span class=\"hljs-title function_\">monteCarloTreeSearch</span><span class=\"hljs-params\">(Node rootNode)</span> {\n        Node winnerNode;\n        <span class=\"hljs-type\">double</span> timeLimit;\n\n        <span class=\"hljs-comment\">// Expand the root node.</span>\n        addChildNodes(rootNode, <span class=\"hljs-number\">10</span>);\n\n        timeLimit = System.currentTimeMillis() + TIME_LIMIT;\n\n        <span class=\"hljs-comment\">// Explore the tree until the time limit is reached.</span>\n        <span class=\"hljs-keyword\">while</span> (System.currentTimeMillis() &lt; timeLimit) {\n            Node promisingNode;\n\n            <span class=\"hljs-comment\">// Get a promising node using UCT.</span>\n            promisingNode = getPromisingNode(rootNode);\n\n            <span class=\"hljs-comment\">// Expand the promising node.</span>\n            <span class=\"hljs-keyword\">if</span> (promisingNode.childNodes.size() == <span class=\"hljs-number\">0</span>) {\n                addChildNodes(promisingNode, <span class=\"hljs-number\">10</span>);\n            }\n\n            simulateRandomPlay(promisingNode);\n        }\n\n        winnerNode = getWinnerNode(rootNode);\n        printScores(rootNode);\n        System.out.format(<span class=\"hljs-string\">&quot;\\nThe optimal node is: %02d\\n&quot;</span>, rootNode.childNodes.indexOf(winnerNode) + <span class=\"hljs-number\">1</span>);\n\n        <span class=\"hljs-keyword\">return</span> winnerNode;\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">addChildNodes</span><span class=\"hljs-params\">(Node node, <span class=\"hljs-type\">int</span> childCount)</span> {\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; childCount; i++) {\n            node.childNodes.add(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Node</span>(node, !node.isPlayersTurn));\n        }\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Uses UCT to find a promising child node to be explored.\n     *\n     * UCT: Upper Confidence bounds applied to Trees.\n     *\n     * <span class=\"hljs-doctag\">@param</span> rootNode Root node of the tree.\n     * <span class=\"hljs-doctag\">@return</span> The most promising node according to UCT.\n     */</span>\n    <span class=\"hljs-keyword\">public</span> Node <span class=\"hljs-title function_\">getPromisingNode</span><span class=\"hljs-params\">(Node rootNode)</span> {\n        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">promisingNode</span> <span class=\"hljs-operator\">=</span> rootNode;\n\n        <span class=\"hljs-comment\">// Iterate until a node that hasn&#x27;t been expanded is found.</span>\n        <span class=\"hljs-keyword\">while</span> (promisingNode.childNodes.size() != <span class=\"hljs-number\">0</span>) {\n            <span class=\"hljs-type\">double</span> <span class=\"hljs-variable\">uctIndex</span> <span class=\"hljs-operator\">=</span> Double.MIN_VALUE;\n            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">nodeIndex</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n\n            <span class=\"hljs-comment\">// Iterate through child nodes and pick the most promising one</span>\n            <span class=\"hljs-comment\">// using UCT (Upper Confidence bounds applied to Trees).</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; promisingNode.childNodes.size(); i++) {\n                <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">childNode</span> <span class=\"hljs-operator\">=</span> promisingNode.childNodes.get(i);\n                <span class=\"hljs-type\">double</span> uctTemp;\n\n                <span class=\"hljs-comment\">// If child node has never been visited</span>\n                <span class=\"hljs-comment\">// it will have the highest uct value.</span>\n                <span class=\"hljs-keyword\">if</span> (childNode.visitCount == <span class=\"hljs-number\">0</span>) {\n                    nodeIndex = i;\n                    <span class=\"hljs-keyword\">break</span>;\n                }\n\n                uctTemp = ((<span class=\"hljs-type\">double</span>) childNode.score / childNode.visitCount)\n                        + <span class=\"hljs-number\">1.41</span> * Math.sqrt(Math.log(promisingNode.visitCount) / (<span class=\"hljs-type\">double</span>) childNode.visitCount);\n\n                <span class=\"hljs-keyword\">if</span> (uctTemp &gt; uctIndex) {\n                    uctIndex = uctTemp;\n                    nodeIndex = i;\n                }\n            }\n\n            promisingNode = promisingNode.childNodes.get(nodeIndex);\n        }\n\n        <span class=\"hljs-keyword\">return</span> promisingNode;\n    }\n\n    <span class=\"hljs-comment\">/**\n     * Simulates a random play from a nodes current state and back propagates\n     * the result.\n     *\n     * <span class=\"hljs-doctag\">@param</span> promisingNode Node that will be simulated.\n     */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">simulateRandomPlay</span><span class=\"hljs-params\">(Node promisingNode)</span> {\n        <span class=\"hljs-type\">Random</span> <span class=\"hljs-variable\">rand</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Random</span>();\n        <span class=\"hljs-type\">Node</span> <span class=\"hljs-variable\">tempNode</span> <span class=\"hljs-operator\">=</span> promisingNode;\n        <span class=\"hljs-type\">boolean</span> isPlayerWinner;\n\n        <span class=\"hljs-comment\">// The following line randomly determines whether the simulated play is a win or loss.</span>\n        <span class=\"hljs-comment\">// To use the MCTS algorithm correctly this should be a simulation of the nodes&#x27; current</span>\n        <span class=\"hljs-comment\">// state of the game until it finishes (if possible) and use an evaluation function to</span>\n        <span class=\"hljs-comment\">// determine how good or bad the play was.</span>\n        <span class=\"hljs-comment\">// e.g. Play tic tac toe choosing random squares until the game ends. </span>\n        promisingNode.playerWon = (rand.nextInt(<span class=\"hljs-number\">6</span>) == <span class=\"hljs-number\">0</span>);\n\n        isPlayerWinner = promisingNode.playerWon;\n\n        <span class=\"hljs-comment\">// Back propagation of the random play.</span>\n        <span class=\"hljs-keyword\">while</span> (tempNode != <span class=\"hljs-literal\">null</span>) {\n            tempNode.visitCount++;\n\n            <span class=\"hljs-comment\">// Add wining scores to bouth player and opponent depending on the turn.</span>\n            <span class=\"hljs-keyword\">if</span> ((tempNode.isPlayersTurn &amp;&amp; isPlayerWinner)\n                    || (!tempNode.isPlayersTurn &amp;&amp; !isPlayerWinner)) {\n                tempNode.score += WIN_SCORE;\n            }\n\n            tempNode = tempNode.parent;\n        }\n    }\n\n    <span class=\"hljs-keyword\">public</span> Node <span class=\"hljs-title function_\">getWinnerNode</span><span class=\"hljs-params\">(Node rootNode)</span> {\n        <span class=\"hljs-keyword\">return</span> Collections.max(rootNode.childNodes, Comparator.comparing(c -&gt; c.score));\n    }\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">printScores</span><span class=\"hljs-params\">(Node rootNode)</span> {\n        System.out.println(<span class=\"hljs-string\">&quot;N.\\tScore\\t\\tVisits&quot;</span>);\n\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>; i &lt; rootNode.childNodes.size(); i++) {\n            System.out.println(String.format(<span class=\"hljs-string\">&quot;%02d\\t%d\\t\\t%d&quot;</span>, i + <span class=\"hljs-number\">1</span>,\n                    rootNode.childNodes.get(i).score, rootNode.childNodes.get(i).visitCount));\n        }\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Aitor Fidalgo SÃ¡nchez",
      "email": "64830228+aitorfi@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}