{
  "slug": "multi-level-feedback-queue",
  "name": "Multi Level Feedback Queue",
  "categories": [
    "scheduling"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "scheduling/multi_level_feedback_queue.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/scheduling/multi_level_feedback_queue.py",
      "code": "<span class=\"hljs-keyword\">from</span> collections <span class=\"hljs-keyword\">import</span> deque\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Process</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, process_name: <span class=\"hljs-built_in\">str</span>, arrival_time: <span class=\"hljs-built_in\">int</span>, burst_time: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        self.process_name = process_name  <span class=\"hljs-comment\"># process name</span>\n        self.arrival_time = arrival_time  <span class=\"hljs-comment\"># arrival time of the process</span>\n        <span class=\"hljs-comment\"># completion time of finished process or last interrupted time</span>\n        self.stop_time = arrival_time\n        self.burst_time = burst_time  <span class=\"hljs-comment\"># remaining burst time</span>\n        self.waiting_time = <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\"># total time of the process wait in ready queue</span>\n        self.turnaround_time = <span class=\"hljs-number\">0</span>  <span class=\"hljs-comment\"># time from arrival time to completion time</span>\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">MLFQ</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    MLFQ(Multi Level Feedback Queue)\n    https://en.wikipedia.org/wiki/Multilevel_feedback_queue\n    MLFQ has a lot of queues that have different priority\n    In this MLFQ,\n    The first Queue(0) to last second Queue(N-2) of MLFQ have Round Robin Algorithm\n    The last Queue(N-1) has First Come, First Served Algorithm\n    &quot;&quot;&quot;</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">\n        self,\n        number_of_queues: <span class=\"hljs-built_in\">int</span>,\n        time_slices: <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>],\n        queue: deque[Process],\n        current_time: <span class=\"hljs-built_in\">int</span>,\n    </span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-comment\"># total number of mlfq&#x27;s queues</span>\n        self.number_of_queues = number_of_queues\n        <span class=\"hljs-comment\"># time slice of queues that round robin algorithm applied</span>\n        self.time_slices = time_slices\n        <span class=\"hljs-comment\"># unfinished process is in this ready_queue</span>\n        self.ready_queue = queue\n        <span class=\"hljs-comment\"># current time</span>\n        self.current_time = current_time\n        <span class=\"hljs-comment\"># finished process is in this sequence queue</span>\n        self.finish_queue: deque[Process] = deque()\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">calculate_sequence_of_finish_queue</span>(<span class=\"hljs-params\">self</span>) -&gt; <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">str</span>]:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        This method returns the sequence of finished processes\n        &gt;&gt;&gt; P1 = Process(&quot;P1&quot;, 0, 53)\n        &gt;&gt;&gt; P2 = Process(&quot;P2&quot;, 0, 17)\n        &gt;&gt;&gt; P3 = Process(&quot;P3&quot;, 0, 68)\n        &gt;&gt;&gt; P4 = Process(&quot;P4&quot;, 0, 24)\n        &gt;&gt;&gt; mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        &gt;&gt;&gt; _ = mlfq.multi_level_feedback_queue()\n        &gt;&gt;&gt; mlfq.calculate_sequence_of_finish_queue()\n        [&#x27;P2&#x27;, &#x27;P4&#x27;, &#x27;P1&#x27;, &#x27;P3&#x27;]\n        &quot;&quot;&quot;</span>\n        sequence = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(self.finish_queue)):\n            sequence.append(self.finish_queue[i].process_name)\n        <span class=\"hljs-keyword\">return</span> sequence\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">calculate_waiting_time</span>(<span class=\"hljs-params\">self, queue: <span class=\"hljs-built_in\">list</span>[Process]</span>) -&gt; <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        This method calculates waiting time of processes\n        &gt;&gt;&gt; P1 = Process(&quot;P1&quot;, 0, 53)\n        &gt;&gt;&gt; P2 = Process(&quot;P2&quot;, 0, 17)\n        &gt;&gt;&gt; P3 = Process(&quot;P3&quot;, 0, 68)\n        &gt;&gt;&gt; P4 = Process(&quot;P4&quot;, 0, 24)\n        &gt;&gt;&gt; mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        &gt;&gt;&gt; _ = mlfq.multi_level_feedback_queue()\n        &gt;&gt;&gt; mlfq.calculate_waiting_time([P1, P2, P3, P4])\n        [83, 17, 94, 101]\n        &quot;&quot;&quot;</span>\n        waiting_times = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(queue)):\n            waiting_times.append(queue[i].waiting_time)\n        <span class=\"hljs-keyword\">return</span> waiting_times\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">calculate_turnaround_time</span>(<span class=\"hljs-params\">self, queue: <span class=\"hljs-built_in\">list</span>[Process]</span>) -&gt; <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        This method calculates turnaround time of processes\n        &gt;&gt;&gt; P1 = Process(&quot;P1&quot;, 0, 53)\n        &gt;&gt;&gt; P2 = Process(&quot;P2&quot;, 0, 17)\n        &gt;&gt;&gt; P3 = Process(&quot;P3&quot;, 0, 68)\n        &gt;&gt;&gt; P4 = Process(&quot;P4&quot;, 0, 24)\n        &gt;&gt;&gt; mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        &gt;&gt;&gt; _ = mlfq.multi_level_feedback_queue()\n        &gt;&gt;&gt; mlfq.calculate_turnaround_time([P1, P2, P3, P4])\n        [136, 34, 162, 125]\n        &quot;&quot;&quot;</span>\n        turnaround_times = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(queue)):\n            turnaround_times.append(queue[i].turnaround_time)\n        <span class=\"hljs-keyword\">return</span> turnaround_times\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">calculate_completion_time</span>(<span class=\"hljs-params\">self, queue: <span class=\"hljs-built_in\">list</span>[Process]</span>) -&gt; <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        This method calculates completion time of processes\n        &gt;&gt;&gt; P1 = Process(&quot;P1&quot;, 0, 53)\n        &gt;&gt;&gt; P2 = Process(&quot;P2&quot;, 0, 17)\n        &gt;&gt;&gt; P3 = Process(&quot;P3&quot;, 0, 68)\n        &gt;&gt;&gt; P4 = Process(&quot;P4&quot;, 0, 24)\n        &gt;&gt;&gt; mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        &gt;&gt;&gt; _ = mlfq.multi_level_feedback_queue()\n        &gt;&gt;&gt; mlfq.calculate_turnaround_time([P1, P2, P3, P4])\n        [136, 34, 162, 125]\n        &quot;&quot;&quot;</span>\n        completion_times = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(queue)):\n            completion_times.append(queue[i].stop_time)\n        <span class=\"hljs-keyword\">return</span> completion_times\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">calculate_remaining_burst_time_of_processes</span>(<span class=\"hljs-params\">\n        self, queue: deque[Process]\n    </span>) -&gt; <span class=\"hljs-built_in\">list</span>[<span class=\"hljs-built_in\">int</span>]:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        This method calculate remaining burst time of processes\n        &gt;&gt;&gt; P1 = Process(&quot;P1&quot;, 0, 53)\n        &gt;&gt;&gt; P2 = Process(&quot;P2&quot;, 0, 17)\n        &gt;&gt;&gt; P3 = Process(&quot;P3&quot;, 0, 68)\n        &gt;&gt;&gt; P4 = Process(&quot;P4&quot;, 0, 24)\n        &gt;&gt;&gt; mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        &gt;&gt;&gt; finish_queue, ready_queue = mlfq.round_robin(deque([P1, P2, P3, P4]), 17)\n        &gt;&gt;&gt; mlfq.calculate_remaining_burst_time_of_processes(mlfq.finish_queue)\n        [0]\n        &gt;&gt;&gt; mlfq.calculate_remaining_burst_time_of_processes(ready_queue)\n        [36, 51, 7]\n        &gt;&gt;&gt; finish_queue, ready_queue = mlfq.round_robin(ready_queue, 25)\n        &gt;&gt;&gt; mlfq.calculate_remaining_burst_time_of_processes(mlfq.finish_queue)\n        [0, 0]\n        &gt;&gt;&gt; mlfq.calculate_remaining_burst_time_of_processes(ready_queue)\n        [11, 26]\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">return</span> [q.burst_time <span class=\"hljs-keyword\">for</span> q <span class=\"hljs-keyword\">in</span> queue]\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">update_waiting_time</span>(<span class=\"hljs-params\">self, process: Process</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        This method updates waiting times of unfinished processes\n        &gt;&gt;&gt; P1 = Process(&quot;P1&quot;, 0, 53)\n        &gt;&gt;&gt; P2 = Process(&quot;P2&quot;, 0, 17)\n        &gt;&gt;&gt; P3 = Process(&quot;P3&quot;, 0, 68)\n        &gt;&gt;&gt; P4 = Process(&quot;P4&quot;, 0, 24)\n        &gt;&gt;&gt; mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        &gt;&gt;&gt; mlfq.current_time = 10\n        &gt;&gt;&gt; P1.stop_time = 5\n        &gt;&gt;&gt; mlfq.update_waiting_time(P1)\n        5\n        &quot;&quot;&quot;</span>\n        process.waiting_time += self.current_time - process.stop_time\n        <span class=\"hljs-keyword\">return</span> process.waiting_time\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">first_come_first_served</span>(<span class=\"hljs-params\">self, ready_queue: deque[Process]</span>) -&gt; deque[Process]:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        FCFS(First Come, First Served)\n        FCFS will be applied to MLFQ&#x27;s last queue\n        A first came process will be finished at first\n        &gt;&gt;&gt; P1 = Process(&quot;P1&quot;, 0, 53)\n        &gt;&gt;&gt; P2 = Process(&quot;P2&quot;, 0, 17)\n        &gt;&gt;&gt; P3 = Process(&quot;P3&quot;, 0, 68)\n        &gt;&gt;&gt; P4 = Process(&quot;P4&quot;, 0, 24)\n        &gt;&gt;&gt; mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        &gt;&gt;&gt; _ = mlfq.first_come_first_served(mlfq.ready_queue)\n        &gt;&gt;&gt; mlfq.calculate_sequence_of_finish_queue()\n        [&#x27;P1&#x27;, &#x27;P2&#x27;, &#x27;P3&#x27;, &#x27;P4&#x27;]\n        &quot;&quot;&quot;</span>\n        finished: deque[Process] = deque()  <span class=\"hljs-comment\"># sequence deque of finished process</span>\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-built_in\">len</span>(ready_queue) != <span class=\"hljs-number\">0</span>:\n            cp = ready_queue.popleft()  <span class=\"hljs-comment\"># current process</span>\n\n            <span class=\"hljs-comment\"># if process&#x27;s arrival time is later than current time, update current time</span>\n            <span class=\"hljs-keyword\">if</span> self.current_time &lt; cp.arrival_time:\n                self.current_time += cp.arrival_time\n\n            <span class=\"hljs-comment\"># update waiting time of current process</span>\n            self.update_waiting_time(cp)\n            <span class=\"hljs-comment\"># update current time</span>\n            self.current_time += cp.burst_time\n            <span class=\"hljs-comment\"># finish the process and set the process&#x27;s burst-time 0</span>\n            cp.burst_time = <span class=\"hljs-number\">0</span>\n            <span class=\"hljs-comment\"># set the process&#x27;s turnaround time because it is finished</span>\n            cp.turnaround_time = self.current_time - cp.arrival_time\n            <span class=\"hljs-comment\"># set the completion time</span>\n            cp.stop_time = self.current_time\n            <span class=\"hljs-comment\"># add the process to queue that has finished queue</span>\n            finished.append(cp)\n\n        self.finish_queue.extend(finished)  <span class=\"hljs-comment\"># add finished process to finish queue</span>\n        <span class=\"hljs-comment\"># FCFS will finish all remaining processes</span>\n        <span class=\"hljs-keyword\">return</span> finished\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">round_robin</span>(<span class=\"hljs-params\">\n        self, ready_queue: deque[Process], time_slice: <span class=\"hljs-built_in\">int</span>\n    </span>) -&gt; <span class=\"hljs-built_in\">tuple</span>[deque[Process], deque[Process]]:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        RR(Round Robin)\n        RR will be applied to MLFQ&#x27;s all queues except last queue\n        All processes can&#x27;t use CPU for time more than time_slice\n        If the process consume CPU up to time_slice, it will go back to ready queue\n        &gt;&gt;&gt; P1 = Process(&quot;P1&quot;, 0, 53)\n        &gt;&gt;&gt; P2 = Process(&quot;P2&quot;, 0, 17)\n        &gt;&gt;&gt; P3 = Process(&quot;P3&quot;, 0, 68)\n        &gt;&gt;&gt; P4 = Process(&quot;P4&quot;, 0, 24)\n        &gt;&gt;&gt; mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        &gt;&gt;&gt; finish_queue, ready_queue = mlfq.round_robin(mlfq.ready_queue, 17)\n        &gt;&gt;&gt; mlfq.calculate_sequence_of_finish_queue()\n        [&#x27;P2&#x27;]\n        &quot;&quot;&quot;</span>\n        finished: deque[Process] = deque()  <span class=\"hljs-comment\"># sequence deque of terminated process</span>\n        <span class=\"hljs-comment\"># just for 1 cycle and unfinished processes will go back to queue</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(ready_queue)):\n            cp = ready_queue.popleft()  <span class=\"hljs-comment\"># current process</span>\n\n            <span class=\"hljs-comment\"># if process&#x27;s arrival time is later than current time, update current time</span>\n            <span class=\"hljs-keyword\">if</span> self.current_time &lt; cp.arrival_time:\n                self.current_time += cp.arrival_time\n\n            <span class=\"hljs-comment\"># update waiting time of unfinished processes</span>\n            self.update_waiting_time(cp)\n            <span class=\"hljs-comment\"># if the burst time of process is bigger than time-slice</span>\n            <span class=\"hljs-keyword\">if</span> cp.burst_time &gt; time_slice:\n                <span class=\"hljs-comment\"># use CPU for only time-slice</span>\n                self.current_time += time_slice\n                <span class=\"hljs-comment\"># update remaining burst time</span>\n                cp.burst_time -= time_slice\n                <span class=\"hljs-comment\"># update end point time</span>\n                cp.stop_time = self.current_time\n                <span class=\"hljs-comment\"># locate the process behind the queue because it is not finished</span>\n                ready_queue.append(cp)\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-comment\"># use CPU for remaining burst time</span>\n                self.current_time += cp.burst_time\n                <span class=\"hljs-comment\"># set burst time 0 because the process is finished</span>\n                cp.burst_time = <span class=\"hljs-number\">0</span>\n                <span class=\"hljs-comment\"># set the finish time</span>\n                cp.stop_time = self.current_time\n                <span class=\"hljs-comment\"># update the process&#x27; turnaround time because it is finished</span>\n                cp.turnaround_time = self.current_time - cp.arrival_time\n                <span class=\"hljs-comment\"># add the process to queue that has finished queue</span>\n                finished.append(cp)\n\n        self.finish_queue.extend(finished)  <span class=\"hljs-comment\"># add finished process to finish queue</span>\n        <span class=\"hljs-comment\"># return finished processes queue and remaining processes queue</span>\n        <span class=\"hljs-keyword\">return</span> finished, ready_queue\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">multi_level_feedback_queue</span>(<span class=\"hljs-params\">self</span>) -&gt; deque[Process]:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        MLFQ(Multi Level Feedback Queue)\n        &gt;&gt;&gt; P1 = Process(&quot;P1&quot;, 0, 53)\n        &gt;&gt;&gt; P2 = Process(&quot;P2&quot;, 0, 17)\n        &gt;&gt;&gt; P3 = Process(&quot;P3&quot;, 0, 68)\n        &gt;&gt;&gt; P4 = Process(&quot;P4&quot;, 0, 24)\n        &gt;&gt;&gt; mlfq = MLFQ(3, [17, 25], deque([P1, P2, P3, P4]), 0)\n        &gt;&gt;&gt; finish_queue = mlfq.multi_level_feedback_queue()\n        &gt;&gt;&gt; mlfq.calculate_sequence_of_finish_queue()\n        [&#x27;P2&#x27;, &#x27;P4&#x27;, &#x27;P1&#x27;, &#x27;P3&#x27;]\n        &quot;&quot;&quot;</span>\n\n        <span class=\"hljs-comment\">#  all queues except last one have round_robin algorithm</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(self.number_of_queues - <span class=\"hljs-number\">1</span>):\n            finished, self.ready_queue = self.round_robin(\n                self.ready_queue, self.time_slices[i]\n            )\n        <span class=\"hljs-comment\">#  the last queue has first_come_first_served algorithm</span>\n        self.first_come_first_served(self.ready_queue)\n\n        <span class=\"hljs-keyword\">return</span> self.finish_queue\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">import</span> doctest\n\n    P1 = Process(<span class=\"hljs-string\">&quot;P1&quot;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">53</span>)\n    P2 = Process(<span class=\"hljs-string\">&quot;P2&quot;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">17</span>)\n    P3 = Process(<span class=\"hljs-string\">&quot;P3&quot;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">68</span>)\n    P4 = Process(<span class=\"hljs-string\">&quot;P4&quot;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">24</span>)\n    number_of_queues = <span class=\"hljs-number\">3</span>\n    time_slices = [<span class=\"hljs-number\">17</span>, <span class=\"hljs-number\">25</span>]\n    queue = deque([P1, P2, P3, P4])\n\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(time_slices) != number_of_queues - <span class=\"hljs-number\">1</span>:\n        exit()\n\n    doctest.testmod(extraglobs={<span class=\"hljs-string\">&quot;queue&quot;</span>: deque([P1, P2, P3, P4])})\n\n    P1 = Process(<span class=\"hljs-string\">&quot;P1&quot;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">53</span>)\n    P2 = Process(<span class=\"hljs-string\">&quot;P2&quot;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">17</span>)\n    P3 = Process(<span class=\"hljs-string\">&quot;P3&quot;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">68</span>)\n    P4 = Process(<span class=\"hljs-string\">&quot;P4&quot;</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">24</span>)\n    number_of_queues = <span class=\"hljs-number\">3</span>\n    time_slices = [<span class=\"hljs-number\">17</span>, <span class=\"hljs-number\">25</span>]\n    queue = deque([P1, P2, P3, P4])\n    mlfq = MLFQ(number_of_queues, time_slices, queue, <span class=\"hljs-number\">0</span>)\n    finish_queue = mlfq.multi_level_feedback_queue()\n\n    <span class=\"hljs-comment\"># print total waiting times of processes(P1, P2, P3, P4)</span>\n    <span class=\"hljs-built_in\">print</span>(\n        <span class=\"hljs-string\">f&quot;waiting time:\\\n        \\t\\t\\t<span class=\"hljs-subst\">{MLFQ.calculate_waiting_time(mlfq, [P1, P2, P3, P4])}</span>&quot;</span>\n    )\n    <span class=\"hljs-comment\"># print completion times of processes(P1, P2, P3, P4)</span>\n    <span class=\"hljs-built_in\">print</span>(\n        <span class=\"hljs-string\">f&quot;completion time:\\\n        \\t\\t<span class=\"hljs-subst\">{MLFQ.calculate_completion_time(mlfq, [P1, P2, P3, P4])}</span>&quot;</span>\n    )\n    <span class=\"hljs-comment\"># print total turnaround times of processes(P1, P2, P3, P4)</span>\n    <span class=\"hljs-built_in\">print</span>(\n        <span class=\"hljs-string\">f&quot;turnaround time:\\\n        \\t\\t<span class=\"hljs-subst\">{MLFQ.calculate_turnaround_time(mlfq, [P1, P2, P3, P4])}</span>&quot;</span>\n    )\n    <span class=\"hljs-comment\"># print sequence of finished processes</span>\n    <span class=\"hljs-built_in\">print</span>(\n        <span class=\"hljs-string\">f&quot;sequnece of finished processes:\\\n        <span class=\"hljs-subst\">{mlfq.calculate_sequence_of_finish_queue()}</span>&quot;</span>\n    )\n"
    }
  },
  "contributors": [
    {
      "name": "DongJoon Cha",
      "email": "81581204+dongjji@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}