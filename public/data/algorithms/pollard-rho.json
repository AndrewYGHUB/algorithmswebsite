{
  "slug": "pollard-rho",
  "name": "Pollard Rho",
  "categories": [
    "math"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "maths/pollard_rho.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/maths/pollard_rho.py",
      "code": "<span class=\"hljs-keyword\">from</span> __future__ <span class=\"hljs-keyword\">import</span> annotations\n\n<span class=\"hljs-keyword\">from</span> math <span class=\"hljs-keyword\">import</span> gcd\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">pollard_rho</span>(<span class=\"hljs-params\">\n    num: <span class=\"hljs-built_in\">int</span>,\n    seed: <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">2</span>,\n    step: <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">1</span>,\n    attempts: <span class=\"hljs-built_in\">int</span> = <span class=\"hljs-number\">3</span>,\n</span>) -&gt; <span class=\"hljs-built_in\">int</span> | <span class=\"hljs-literal\">None</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Use Pollard&#x27;s Rho algorithm to return a nontrivial factor of ``num``.\n    The returned factor may be composite and require further factorization.\n    If the algorithm will return None if it fails to find a factor within\n    the specified number of attempts or within the specified number of steps.\n    If ``num`` is prime, this algorithm is guaranteed to return None.\n    https://en.wikipedia.org/wiki/Pollard%27s_rho_algorithm\n\n    &gt;&gt;&gt; pollard_rho(18446744073709551617)\n    274177\n    &gt;&gt;&gt; pollard_rho(97546105601219326301)\n    9876543191\n    &gt;&gt;&gt; pollard_rho(100)\n    2\n    &gt;&gt;&gt; pollard_rho(17)\n    &gt;&gt;&gt; pollard_rho(17**3)\n    17\n    &gt;&gt;&gt; pollard_rho(17**3, attempts=1)\n    &gt;&gt;&gt; pollard_rho(3*5*7)\n    21\n    &gt;&gt;&gt; pollard_rho(1)\n    Traceback (most recent call last):\n        ...\n    ValueError: The input value cannot be less than 2\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-comment\"># A value less than 2 can cause an infinite loop in the algorithm.</span>\n    <span class=\"hljs-keyword\">if</span> num &lt; <span class=\"hljs-number\">2</span>:\n        <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&quot;The input value cannot be less than 2&quot;</span>)\n\n    <span class=\"hljs-comment\"># Because of the relationship between ``f(f(x))`` and ``f(x)``, this</span>\n    <span class=\"hljs-comment\"># algorithm struggles to find factors that are divisible by two.</span>\n    <span class=\"hljs-comment\"># As a workaround, we specifically check for two and even inputs.</span>\n    <span class=\"hljs-comment\">#   See: https://math.stackexchange.com/a/2856214/165820</span>\n    <span class=\"hljs-keyword\">if</span> num &gt; <span class=\"hljs-number\">2</span> <span class=\"hljs-keyword\">and</span> num % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">2</span>\n\n    <span class=\"hljs-comment\"># Pollard&#x27;s Rho algorithm requires a function that returns pseudorandom</span>\n    <span class=\"hljs-comment\"># values between 0 &lt;= X &lt; ``num``.  It doesn&#x27;t need to be random in the</span>\n    <span class=\"hljs-comment\"># sense that the output value is cryptographically secure or difficult</span>\n    <span class=\"hljs-comment\"># to calculate, it only needs to be random in the sense that all output</span>\n    <span class=\"hljs-comment\"># values should be equally likely to appear.</span>\n    <span class=\"hljs-comment\"># For this reason, Pollard suggested using ``f(x) = (x**2 - 1) % num``</span>\n    <span class=\"hljs-comment\"># However, the success of Pollard&#x27;s algorithm isn&#x27;t guaranteed and is</span>\n    <span class=\"hljs-comment\"># determined in part by the initial seed and the chosen random function.</span>\n    <span class=\"hljs-comment\"># To make retries easier, we will instead use ``f(x) = (x**2 + C) % num``</span>\n    <span class=\"hljs-comment\"># where ``C`` is a value that we can modify between each attempt.</span>\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">rand_fn</span>(<span class=\"hljs-params\">value: <span class=\"hljs-built_in\">int</span>, step: <span class=\"hljs-built_in\">int</span>, modulus: <span class=\"hljs-built_in\">int</span></span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        Returns a pseudorandom value modulo ``modulus`` based on the\n        input ``value`` and attempt-specific ``step`` size.\n\n        &gt;&gt;&gt; rand_fn(0, 0, 0)\n        Traceback (most recent call last):\n            ...\n        ZeroDivisionError: integer division or modulo by zero\n        &gt;&gt;&gt; rand_fn(1, 2, 3)\n        0\n        &gt;&gt;&gt; rand_fn(0, 10, 7)\n        3\n        &gt;&gt;&gt; rand_fn(1234, 1, 17)\n        16\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">return</span> (<span class=\"hljs-built_in\">pow</span>(value, <span class=\"hljs-number\">2</span>) + step) % modulus\n\n    <span class=\"hljs-keyword\">for</span> attempt <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(attempts):\n        <span class=\"hljs-comment\"># These track the position within the cycle detection logic.</span>\n        tortoise = seed\n        hare = seed\n\n        <span class=\"hljs-keyword\">while</span> <span class=\"hljs-literal\">True</span>:\n            <span class=\"hljs-comment\"># At each iteration, the tortoise moves one step and the hare moves two.</span>\n            tortoise = rand_fn(tortoise, step, num)\n            hare = rand_fn(hare, step, num)\n            hare = rand_fn(hare, step, num)\n\n            <span class=\"hljs-comment\"># At some point both the tortoise and the hare will enter a cycle whose</span>\n            <span class=\"hljs-comment\"># length ``p`` is a divisor of ``num``.  Once in that cycle, at some point</span>\n            <span class=\"hljs-comment\"># the tortoise and hare will end up on the same value modulo ``p``.</span>\n            <span class=\"hljs-comment\"># We can detect when this happens because the position difference between</span>\n            <span class=\"hljs-comment\"># the tortoise and the hare will share a common divisor with ``num``.</span>\n            divisor = gcd(hare - tortoise, num)\n\n            <span class=\"hljs-keyword\">if</span> divisor == <span class=\"hljs-number\">1</span>:\n                <span class=\"hljs-comment\"># No common divisor yet, just keep searching.</span>\n                <span class=\"hljs-keyword\">continue</span>\n            <span class=\"hljs-keyword\">else</span>:\n                <span class=\"hljs-comment\"># We found a common divisor!</span>\n                <span class=\"hljs-keyword\">if</span> divisor == num:\n                    <span class=\"hljs-comment\"># Unfortunately, the divisor is ``num`` itself and is useless.</span>\n                    <span class=\"hljs-keyword\">break</span>\n                <span class=\"hljs-keyword\">else</span>:\n                    <span class=\"hljs-comment\"># The divisor is a nontrivial factor of ``num``!</span>\n                    <span class=\"hljs-keyword\">return</span> divisor\n\n        <span class=\"hljs-comment\"># If we made it here, then this attempt failed.</span>\n        <span class=\"hljs-comment\"># We need to pick a new starting seed for the tortoise and hare</span>\n        <span class=\"hljs-comment\"># in addition to a new step value for the random function.</span>\n        <span class=\"hljs-comment\"># To keep this example implementation deterministic, the</span>\n        <span class=\"hljs-comment\"># new values will be generated based on currently available</span>\n        <span class=\"hljs-comment\"># values instead of using something like ``random.randint``.</span>\n\n        <span class=\"hljs-comment\"># We can use the hare&#x27;s position as the new seed.</span>\n        <span class=\"hljs-comment\"># This is actually what Richard Brent&#x27;s the &quot;optimized&quot; variant does.</span>\n        seed = hare\n\n        <span class=\"hljs-comment\"># The new step value for the random function can just be incremented.</span>\n        <span class=\"hljs-comment\"># At first the results will be similar to what the old function would</span>\n        <span class=\"hljs-comment\"># have produced, but the value will quickly diverge after a bit.</span>\n        step += <span class=\"hljs-number\">1</span>\n\n    <span class=\"hljs-comment\"># We haven&#x27;t found a divisor within the requested number of attempts.</span>\n    <span class=\"hljs-comment\"># We were unlucky or ``num`` itself is actually prime.</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">None</span>\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">import</span> argparse\n\n    parser = argparse.ArgumentParser()\n    parser.add_argument(\n        <span class=\"hljs-string\">&quot;num&quot;</span>,\n        <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-built_in\">int</span>,\n        <span class=\"hljs-built_in\">help</span>=<span class=\"hljs-string\">&quot;The value to find a divisor of&quot;</span>,\n    )\n    parser.add_argument(\n        <span class=\"hljs-string\">&quot;--attempts&quot;</span>,\n        <span class=\"hljs-built_in\">type</span>=<span class=\"hljs-built_in\">int</span>,\n        default=<span class=\"hljs-number\">3</span>,\n        <span class=\"hljs-built_in\">help</span>=<span class=\"hljs-string\">&quot;The number of attempts before giving up&quot;</span>,\n    )\n    args = parser.parse_args()\n\n    divisor = pollard_rho(args.num, attempts=args.attempts)\n    <span class=\"hljs-keyword\">if</span> divisor <span class=\"hljs-keyword\">is</span> <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;<span class=\"hljs-subst\">{args.num}</span> is probably prime&quot;</span>)\n    <span class=\"hljs-keyword\">else</span>:\n        quotient = args.num // divisor\n        <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">f&quot;<span class=\"hljs-subst\">{args.num}</span> = <span class=\"hljs-subst\">{divisor}</span> * <span class=\"hljs-subst\">{quotient}</span>&quot;</span>)\n"
    },
    "rust": {
      "dir": "src/math/pollard_rho.rs",
      "url": "https://github.com/TheAlgorithms/rust/tree/master/src/math/pollard_rho.rs",
      "code": "<span class=\"hljs-keyword\">use</span> super::miller_rabin;\n\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">LinearCongruenceGenerator</span> {\n    <span class=\"hljs-comment\">// modulus as 2 ^ 32</span>\n    multiplier: <span class=\"hljs-type\">u32</span>,\n    increment: <span class=\"hljs-type\">u32</span>,\n    state: <span class=\"hljs-type\">u32</span>,\n}\n\n<span class=\"hljs-keyword\">impl</span> <span class=\"hljs-title class_\">LinearCongruenceGenerator</span> {\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">new</span>(multiplier: <span class=\"hljs-type\">u32</span>, increment: <span class=\"hljs-type\">u32</span>, state: <span class=\"hljs-type\">u32</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-keyword\">Self</span> {\n            multiplier,\n            increment,\n            state,\n        }\n    }\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">next</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">u32</span> {\n        <span class=\"hljs-keyword\">self</span>.state = (<span class=\"hljs-keyword\">self</span>.multiplier <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u64</span> * <span class=\"hljs-keyword\">self</span>.state <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u64</span> + <span class=\"hljs-keyword\">self</span>.increment <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u64</span>) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u32</span>;\n        <span class=\"hljs-keyword\">self</span>.state\n    }\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">get_64bits</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">u64</span> {\n        ((<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">next</span>() <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u64</span>) &lt;&lt; <span class=\"hljs-number\">32</span>) | (<span class=\"hljs-keyword\">self</span>.<span class=\"hljs-title function_ invoke__\">next</span>() <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u64</span>)\n    }\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">gcd</span>(<span class=\"hljs-keyword\">mut</span> a: <span class=\"hljs-type\">u64</span>, <span class=\"hljs-keyword\">mut</span> b: <span class=\"hljs-type\">u64</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">u64</span> {\n    <span class=\"hljs-keyword\">while</span> a != <span class=\"hljs-number\">0</span> {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">tmp</span> = b % a;\n        b = a;\n        a = tmp;\n    }\n    b\n}\n\n<span class=\"hljs-meta\">#[inline]</span>\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">advance</span>(x: <span class=\"hljs-type\">u128</span>, c: <span class=\"hljs-type\">u64</span>, number: <span class=\"hljs-type\">u64</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">u128</span> {\n    ((x * x) + c <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u128</span>) % number <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u128</span>\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">pollard_rho_customizable</span>(\n    number: <span class=\"hljs-type\">u64</span>,\n    x0: <span class=\"hljs-type\">u64</span>,\n    c: <span class=\"hljs-type\">u64</span>,\n    iterations_before_check: <span class=\"hljs-type\">u32</span>,\n    iterations_cutoff: <span class=\"hljs-type\">u32</span>,\n) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">u64</span> {\n    <span class=\"hljs-comment\">/*\n    Here we are using Brent&#x27;s method for finding cycle.\n    It is generally faster because we will not use `advance` function as often\n    as Floyd&#x27;s method.\n    We also wait to do a few iterations before calculating the GCD, because\n    it is an expensive function. We will correct for overshooting later.\n    This function may return either 1, `number` or a proper divisor of `number`\n     */</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">x</span> = x0 <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u128</span>; <span class=\"hljs-comment\">// tortoise</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">x_start</span> = <span class=\"hljs-number\">0_u128</span>; <span class=\"hljs-comment\">// to save the starting tortoise if we overshoot</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">y</span> = <span class=\"hljs-number\">0_u128</span>; <span class=\"hljs-comment\">// hare</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">remainder</span> = <span class=\"hljs-number\">1_u128</span>;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">current_gcd</span> = <span class=\"hljs-number\">1_u64</span>;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">max_iterations</span> = <span class=\"hljs-number\">1_u32</span>;\n    <span class=\"hljs-keyword\">while</span> current_gcd == <span class=\"hljs-number\">1</span> {\n        y = x;\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">_</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>..max_iterations {\n            x = <span class=\"hljs-title function_ invoke__\">advance</span>(x, c, number);\n        }\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">big_iteration</span> = <span class=\"hljs-number\">0_u32</span>;\n        <span class=\"hljs-keyword\">while</span> big_iteration &lt; max_iterations &amp;&amp; current_gcd == <span class=\"hljs-number\">1</span> {\n            x_start = x;\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">small_iteration</span> = <span class=\"hljs-number\">0_u32</span>;\n            <span class=\"hljs-keyword\">while</span> small_iteration &lt; iterations_before_check\n                &amp;&amp; small_iteration &lt; (max_iterations - big_iteration)\n            {\n                small_iteration += <span class=\"hljs-number\">1</span>;\n                x = <span class=\"hljs-title function_ invoke__\">advance</span>(x, c, number);\n                <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">diff</span> = x.<span class=\"hljs-title function_ invoke__\">abs_diff</span>(y);\n                remainder = (remainder * diff) % number <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u128</span>;\n            }\n            current_gcd = <span class=\"hljs-title function_ invoke__\">gcd</span>(remainder <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u64</span>, number);\n            big_iteration += iterations_before_check;\n        }\n        max_iterations *= <span class=\"hljs-number\">2</span>;\n        <span class=\"hljs-keyword\">if</span> max_iterations &gt; iterations_cutoff {\n            <span class=\"hljs-keyword\">break</span>;\n        }\n    }\n    <span class=\"hljs-keyword\">if</span> current_gcd == number {\n        <span class=\"hljs-keyword\">while</span> current_gcd == <span class=\"hljs-number\">1</span> {\n            x_start = <span class=\"hljs-title function_ invoke__\">advance</span>(x_start, c, number);\n            current_gcd = <span class=\"hljs-title function_ invoke__\">gcd</span>(x_start.<span class=\"hljs-title function_ invoke__\">abs_diff</span>(y) <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u64</span>, number);\n        }\n    }\n    current_gcd\n}\n\n<span class=\"hljs-comment\">/*\nNote: using this function with `check_is_prime` = false\nand a prime number will result in an infinite loop.\n\nRNG&#x27;s internal state is represented as `seed`. It is\nadvisable (but not mandatory) to reuse the saved seed value\nIn subsequent calls to this function.\n */</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">pollard_rho_get_one_factor</span>(number: <span class=\"hljs-type\">u64</span>, seed: &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-type\">u32</span>, check_is_prime: <span class=\"hljs-type\">bool</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">u64</span> {\n    <span class=\"hljs-comment\">// LCG parameters from wikipedia</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">rng</span> = LinearCongruenceGenerator::<span class=\"hljs-title function_ invoke__\">new</span>(<span class=\"hljs-number\">1103515245</span>, <span class=\"hljs-number\">12345</span>, *seed);\n    <span class=\"hljs-keyword\">if</span> number &lt;= <span class=\"hljs-number\">1</span> {\n        <span class=\"hljs-keyword\">return</span> number;\n    }\n    <span class=\"hljs-keyword\">if</span> check_is_prime {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">bases</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">2u64</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>];\n        <span class=\"hljs-keyword\">if</span> number &gt; <span class=\"hljs-number\">3_215_031_000</span> {\n            bases.<span class=\"hljs-title function_ invoke__\">append</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">17</span>, <span class=\"hljs-number\">19</span>, <span class=\"hljs-number\">23</span>, <span class=\"hljs-number\">29</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">37</span>]);\n        }\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-title function_ invoke__\">miller_rabin</span>(number, &amp;bases) == <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-keyword\">return</span> number;\n        }\n    }\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">factor</span> = <span class=\"hljs-number\">1u64</span>;\n    <span class=\"hljs-keyword\">while</span> factor == <span class=\"hljs-number\">1</span> || factor == number {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">x</span> = rng.<span class=\"hljs-title function_ invoke__\">get_64bits</span>();\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">c</span> = rng.<span class=\"hljs-title function_ invoke__\">get_64bits</span>();\n        factor = <span class=\"hljs-title function_ invoke__\">pollard_rho_customizable</span>(\n            number,\n            (x % (number - <span class=\"hljs-number\">3</span>)) + <span class=\"hljs-number\">2</span>,\n            (c % (number - <span class=\"hljs-number\">2</span>)) + <span class=\"hljs-number\">1</span>,\n            <span class=\"hljs-number\">32</span>,\n            <span class=\"hljs-number\">1</span> &lt;&lt; <span class=\"hljs-number\">18</span>, <span class=\"hljs-comment\">// This shouldn&#x27;t take much longer than number ^ 0.25</span>\n        );\n        <span class=\"hljs-comment\">// These numbers were selected based on local testing.</span>\n        <span class=\"hljs-comment\">// For specific applications there maybe better choices.</span>\n    }\n    *seed = rng.state;\n    factor\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">get_small_factors</span>(<span class=\"hljs-keyword\">mut</span> number: <span class=\"hljs-type\">u64</span>, primes: &amp;[<span class=\"hljs-type\">usize</span>]) <span class=\"hljs-punctuation\">-&gt;</span> (<span class=\"hljs-type\">u64</span>, <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">u64</span>&gt;) {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">result</span>: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">u64</span>&gt; = Vec::<span class=\"hljs-title function_ invoke__\">new</span>();\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">p</span> <span class=\"hljs-keyword\">in</span> primes {\n        <span class=\"hljs-title function_ invoke__\">while</span> (number % *p <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u64</span>) == <span class=\"hljs-number\">0</span> {\n            number /= *p <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u64</span>;\n            result.<span class=\"hljs-title function_ invoke__\">push</span>(*p <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u64</span>);\n        }\n    }\n    (number, result)\n}\n\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">factor_using_mpf</span>(<span class=\"hljs-keyword\">mut</span> number: <span class=\"hljs-type\">usize</span>, mpf: &amp;[<span class=\"hljs-type\">usize</span>]) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">u64</span>&gt; {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">result</span> = Vec::<span class=\"hljs-title function_ invoke__\">new</span>();\n    <span class=\"hljs-keyword\">while</span> number &gt; <span class=\"hljs-number\">1</span> {\n        result.<span class=\"hljs-title function_ invoke__\">push</span>(mpf[number] <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u64</span>);\n        number /= mpf[number];\n    }\n    result\n}\n\n<span class=\"hljs-comment\">/*\n`primes` and `minimum_prime_factors` use usize because so does\nLinearSieve implementation in this repository\n */</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">pollard_rho_factorize</span>(\n    <span class=\"hljs-keyword\">mut</span> number: <span class=\"hljs-type\">u64</span>,\n    seed: &amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-type\">u32</span>,\n    primes: &amp;[<span class=\"hljs-type\">usize</span>],\n    minimum_prime_factors: &amp;[<span class=\"hljs-type\">usize</span>],\n) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">u64</span>&gt; {\n    <span class=\"hljs-keyword\">if</span> number &lt;= <span class=\"hljs-number\">1</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">vec!</span>[];\n    }\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">result</span>: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">u64</span>&gt; = Vec::<span class=\"hljs-title function_ invoke__\">new</span>();\n    {\n        <span class=\"hljs-comment\">// Create a new scope to keep the outer scope clean</span>\n        <span class=\"hljs-keyword\">let</span> (rem, <span class=\"hljs-keyword\">mut</span> res) = <span class=\"hljs-title function_ invoke__\">get_small_factors</span>(number, primes);\n        number = rem;\n        result.<span class=\"hljs-title function_ invoke__\">append</span>(&amp;<span class=\"hljs-keyword\">mut</span> res);\n    }\n    <span class=\"hljs-keyword\">if</span> number == <span class=\"hljs-number\">1</span> {\n        <span class=\"hljs-keyword\">return</span> result;\n    }\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">to_be_factored</span> = <span class=\"hljs-built_in\">vec!</span>[number];\n    <span class=\"hljs-keyword\">while</span> !to_be_factored.<span class=\"hljs-title function_ invoke__\">is_empty</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">last</span> = to_be_factored.<span class=\"hljs-title function_ invoke__\">pop</span>().<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n        <span class=\"hljs-keyword\">if</span> last &lt; minimum_prime_factors.<span class=\"hljs-title function_ invoke__\">len</span>() <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u64</span> {\n            result.<span class=\"hljs-title function_ invoke__\">append</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-title function_ invoke__\">factor_using_mpf</span>(last <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">usize</span>, minimum_prime_factors));\n            <span class=\"hljs-keyword\">continue</span>;\n        }\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">fact</span> = <span class=\"hljs-title function_ invoke__\">pollard_rho_get_one_factor</span>(last, seed, <span class=\"hljs-literal\">true</span>);\n        <span class=\"hljs-keyword\">if</span> fact == last {\n            result.<span class=\"hljs-title function_ invoke__\">push</span>(last);\n            <span class=\"hljs-keyword\">continue</span>;\n        }\n        to_be_factored.<span class=\"hljs-title function_ invoke__\">push</span>(fact);\n        to_be_factored.<span class=\"hljs-title function_ invoke__\">push</span>(last / fact);\n    }\n    result.<span class=\"hljs-title function_ invoke__\">sort_unstable</span>();\n    result\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> test {\n    <span class=\"hljs-keyword\">use</span> super::super::LinearSieve;\n    <span class=\"hljs-keyword\">use</span> super::*;\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">check_is_proper_factor</span>(number: <span class=\"hljs-type\">u64</span>, factor: <span class=\"hljs-type\">u64</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">bool</span> {\n        factor &gt; <span class=\"hljs-number\">1</span> &amp;&amp; factor &lt; number &amp;&amp; ((number % factor) == <span class=\"hljs-number\">0</span>)\n    }\n\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">check_factorization</span>(number: <span class=\"hljs-type\">u64</span>, factors: &amp;[<span class=\"hljs-type\">u64</span>]) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">bool</span> {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">bases</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">2u64</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">17</span>, <span class=\"hljs-number\">19</span>, <span class=\"hljs-number\">23</span>, <span class=\"hljs-number\">29</span>, <span class=\"hljs-number\">31</span>, <span class=\"hljs-number\">37</span>];\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">prod</span> = <span class=\"hljs-number\">1_u64</span>;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">prime_check</span> = <span class=\"hljs-number\">0_u64</span>;\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">p</span> <span class=\"hljs-keyword\">in</span> factors {\n            prod *= *p;\n            prime_check |= <span class=\"hljs-title function_ invoke__\">miller_rabin</span>(*p, &amp;bases);\n        }\n        prime_check == <span class=\"hljs-number\">0</span> &amp;&amp; prod == number\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">one_factor</span>() {\n        <span class=\"hljs-comment\">// a few small cases</span>\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">sieve</span> = LinearSieve::<span class=\"hljs-title function_ invoke__\">new</span>();\n        sieve.<span class=\"hljs-title function_ invoke__\">prepare</span>(<span class=\"hljs-number\">1e5</span> <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">usize</span>).<span class=\"hljs-title function_ invoke__\">unwrap</span>();\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">numbers</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1235</span>, <span class=\"hljs-number\">239874233</span>, <span class=\"hljs-number\">4353234</span>, <span class=\"hljs-number\">456456</span>, <span class=\"hljs-number\">120983</span>];\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">seed</span> = <span class=\"hljs-number\">314159_u32</span>; <span class=\"hljs-comment\">// first digits of pi; nothing up my sleeve</span>\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">num</span> <span class=\"hljs-keyword\">in</span> numbers {\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">factor</span> = <span class=\"hljs-title function_ invoke__\">pollard_rho_get_one_factor</span>(num, &amp;<span class=\"hljs-keyword\">mut</span> seed, <span class=\"hljs-literal\">true</span>);\n            <span class=\"hljs-built_in\">assert!</span>(<span class=\"hljs-title function_ invoke__\">check_is_proper_factor</span>(num, factor));\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">factor</span> = <span class=\"hljs-title function_ invoke__\">pollard_rho_get_one_factor</span>(num, &amp;<span class=\"hljs-keyword\">mut</span> seed, <span class=\"hljs-literal\">false</span>);\n            <span class=\"hljs-built_in\">assert!</span>(<span class=\"hljs-title function_ invoke__\">check_is_proper_factor</span>(num, factor));\n            <span class=\"hljs-built_in\">assert!</span>(<span class=\"hljs-title function_ invoke__\">check_factorization</span>(\n                num,\n                &amp;<span class=\"hljs-title function_ invoke__\">pollard_rho_factorize</span>(num, &amp;<span class=\"hljs-keyword\">mut</span> seed, &amp;sieve.primes, &amp;sieve.minimum_prime_factor)\n            ));\n        }\n        <span class=\"hljs-comment\">// check if it goes into infinite loop if `number` is prime</span>\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">numbers</span> = <span class=\"hljs-built_in\">vec!</span>[\n            <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-number\">101</span>, <span class=\"hljs-number\">998244353</span>, <span class=\"hljs-number\">1000000007</span>, <span class=\"hljs-number\">1000000009</span>, <span class=\"hljs-number\">1671398671</span>, <span class=\"hljs-number\">1652465729</span>,\n            <span class=\"hljs-number\">1894404511</span>, <span class=\"hljs-number\">1683402997</span>, <span class=\"hljs-number\">1661963047</span>, <span class=\"hljs-number\">1946039987</span>, <span class=\"hljs-number\">2071566551</span>, <span class=\"hljs-number\">1867816303</span>, <span class=\"hljs-number\">1952199377</span>,\n            <span class=\"hljs-number\">1622379469</span>, <span class=\"hljs-number\">1739317499</span>, <span class=\"hljs-number\">1775433631</span>, <span class=\"hljs-number\">1994828917</span>, <span class=\"hljs-number\">1818930719</span>, <span class=\"hljs-number\">1672996277</span>,\n        ];\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">num</span> <span class=\"hljs-keyword\">in</span> numbers {\n            <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">pollard_rho_get_one_factor</span>(num, &amp;<span class=\"hljs-keyword\">mut</span> seed, <span class=\"hljs-literal\">true</span>), num);\n            <span class=\"hljs-built_in\">assert!</span>(<span class=\"hljs-title function_ invoke__\">check_factorization</span>(\n                num,\n                &amp;<span class=\"hljs-title function_ invoke__\">pollard_rho_factorize</span>(num, &amp;<span class=\"hljs-keyword\">mut</span> seed, &amp;sieve.primes, &amp;sieve.minimum_prime_factor)\n            ));\n        }\n    }\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">big_numbers</span>() {\n        <span class=\"hljs-comment\">// Bigger cases:</span>\n        <span class=\"hljs-comment\">// Each of these numbers is a product of two 31 bit primes</span>\n        <span class=\"hljs-comment\">// This shouldn&#x27;t take more than a 10ms per number on a modern PC</span>\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">seed</span> = <span class=\"hljs-number\">314159_u32</span>; <span class=\"hljs-comment\">// first digits of pi; nothing up my sleeve</span>\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">numbers</span>: <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">u64</span>&gt; = <span class=\"hljs-built_in\">vec!</span>[\n            <span class=\"hljs-number\">2761929023323646159</span>,\n            <span class=\"hljs-number\">3189046231347719467</span>,\n            <span class=\"hljs-number\">3234246546378360389</span>,\n            <span class=\"hljs-number\">3869305776707280953</span>,\n            <span class=\"hljs-number\">3167208188639390813</span>,\n            <span class=\"hljs-number\">3088042782711408869</span>,\n            <span class=\"hljs-number\">3628455596280801323</span>,\n            <span class=\"hljs-number\">2953787574901819241</span>,\n            <span class=\"hljs-number\">3909561575378030219</span>,\n            <span class=\"hljs-number\">4357328471891213977</span>,\n            <span class=\"hljs-number\">2824368080144930999</span>,\n            <span class=\"hljs-number\">3348680054093203003</span>,\n            <span class=\"hljs-number\">2704267100962222513</span>,\n            <span class=\"hljs-number\">2916169237307181179</span>,\n            <span class=\"hljs-number\">3669851121098875703</span>,\n        ];\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">num</span> <span class=\"hljs-keyword\">in</span> numbers {\n            <span class=\"hljs-built_in\">assert!</span>(<span class=\"hljs-title function_ invoke__\">check_factorization</span>(\n                num,\n                &amp;<span class=\"hljs-title function_ invoke__\">pollard_rho_factorize</span>(num, &amp;<span class=\"hljs-keyword\">mut</span> seed, &amp;<span class=\"hljs-built_in\">vec!</span>[], &amp;<span class=\"hljs-built_in\">vec!</span>[])\n            ));\n        }\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 1
    },
    {
      "name": "Marcus T",
      "email": "marcus.truscello@gmail.com",
      "commits": 1
    },
    {
      "name": "Erfan Khadem",
      "email": "45465346+er888kh@users.noreply.github.com",
      "commits": 2
    }
  ],
  "explanationUrl": {}
}