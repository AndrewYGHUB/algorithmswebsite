{
  "slug": "prims-algorithm-adjacency-matrix",
  "name": "Prim's Algorithm (Adjacency Matrix)",
  "categories": [
    "graphs",
    "minimumspanningtree"
  ],
  "body": {},
  "implementations": {
    "c-sharp": {
      "dir": "./Algorithms/Graph/MinimumSpanningTree/PrimMatrix.cs",
      "url": "https:/github.com/TheAlgorithms/C-Sharp/tree/master/Algorithms/Graph/MinimumSpanningTree/PrimMatrix.cs",
      "code": "<span class=\"hljs-keyword\">using</span> System;\n\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">Algorithms.Graph.MinimumSpanningTree</span>\n{\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Class that uses Prim&#x27;s (Jarnik&#x27;s algorithm) to determine the minimum</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     spanning tree (MST) of a given graph. Prim&#x27;s algorithm is a greedy</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     algorithm that can determine the MST of a weighted undirected graph</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     in O(V^2) time where V is the number of nodes/vertices when using an</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     adjacency matrix representation.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     More information: https://en.wikipedia.org/wiki/Prim%27s_algorithm</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Pseudocode and runtime analysis: https://www.personal.kent.edu/~rmuhamma/Algorithms/MyAlgorithms/GraphAlgor/primAlgor.htm .</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">PrimMatrix</span>\n    {\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Determine the minimum spanning tree for a given weighted undirected graph.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;adjacencyMatrix&quot;&gt;</span>Adjacency matrix for graph to find MST of.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;start&quot;&gt;</span>Node to start search from.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Adjacency matrix of the found MST.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-built_in\">float</span>[,] Solve(<span class=\"hljs-built_in\">float</span>[,] adjacencyMatrix, <span class=\"hljs-built_in\">int</span> start)\n        {\n            ValidateMatrix(adjacencyMatrix);\n\n            <span class=\"hljs-keyword\">var</span> numNodes = adjacencyMatrix.GetLength(<span class=\"hljs-number\">0</span>);\n\n            <span class=\"hljs-comment\">// Create array to represent minimum spanning tree</span>\n            <span class=\"hljs-keyword\">var</span> mst = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">float</span>[numNodes, numNodes];\n\n            <span class=\"hljs-comment\">// Create array to keep track of which nodes are in the MST already</span>\n            <span class=\"hljs-keyword\">var</span> added = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">bool</span>[numNodes];\n\n            <span class=\"hljs-comment\">// Create array to keep track of smallest edge weight for node</span>\n            <span class=\"hljs-keyword\">var</span> key = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">float</span>[numNodes];\n\n            <span class=\"hljs-comment\">// Create array to store parent of node</span>\n            <span class=\"hljs-keyword\">var</span> parent = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[numNodes];\n\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numNodes; i++)\n            {\n                mst[i, i] = <span class=\"hljs-built_in\">float</span>.PositiveInfinity;\n                key[i] = <span class=\"hljs-built_in\">float</span>.PositiveInfinity;\n\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = i + <span class=\"hljs-number\">1</span>; j &lt; numNodes; j++)\n                {\n                    mst[i, j] = <span class=\"hljs-built_in\">float</span>.PositiveInfinity;\n                    mst[j, i] = <span class=\"hljs-built_in\">float</span>.PositiveInfinity;\n                }\n            }\n\n            <span class=\"hljs-comment\">// Ensures that the starting node is added first</span>\n            key[start] = <span class=\"hljs-number\">0</span>;\n\n            <span class=\"hljs-comment\">// Keep looping until all nodes are in tree</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numNodes - <span class=\"hljs-number\">1</span>; i++)\n            {\n                GetNextNode(adjacencyMatrix, key, added, parent);\n            }\n\n            <span class=\"hljs-comment\">// Build adjacency matrix for tree</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numNodes; i++)\n            {\n                <span class=\"hljs-keyword\">if</span> (i == start)\n                {\n                    <span class=\"hljs-keyword\">continue</span>;\n                }\n\n                mst[i, parent[i]] = adjacencyMatrix[i, parent[i]];\n                mst[parent[i], i] = adjacencyMatrix[i, parent[i]];\n            }\n\n            <span class=\"hljs-keyword\">return</span> mst;\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Ensure that the given adjacency matrix represents a weighted undirected graph.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;adjacencyMatrix&quot;&gt;</span>Adjacency matric to check.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">ValidateMatrix</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">float</span>[,] adjacencyMatrix</span>)</span>\n        {\n            <span class=\"hljs-comment\">// Matrix should be square</span>\n            <span class=\"hljs-keyword\">if</span> (adjacencyMatrix.GetLength(<span class=\"hljs-number\">0</span>) != adjacencyMatrix.GetLength(<span class=\"hljs-number\">1</span>))\n            {\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ArgumentException(<span class=\"hljs-string\">&quot;Adjacency matrix must be square!&quot;</span>);\n            }\n\n            <span class=\"hljs-comment\">// Graph needs to be undirected and connected</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; adjacencyMatrix.GetLength(<span class=\"hljs-number\">0</span>); i++)\n            {\n                <span class=\"hljs-keyword\">var</span> connection = <span class=\"hljs-literal\">false</span>;\n                <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>; j &lt; adjacencyMatrix.GetLength(<span class=\"hljs-number\">0</span>); j++)\n                {\n                    <span class=\"hljs-keyword\">if</span> (Math.Abs(adjacencyMatrix[i, j] - adjacencyMatrix[j, i]) &gt; <span class=\"hljs-number\">1e-6</span>)\n                    {\n                        <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ArgumentException(<span class=\"hljs-string\">&quot;Adjacency matrix must be symmetric!&quot;</span>);\n                    }\n\n                    <span class=\"hljs-keyword\">if</span> (!connection &amp;&amp; <span class=\"hljs-built_in\">float</span>.IsFinite(adjacencyMatrix[i, j]))\n                    {\n                        connection = <span class=\"hljs-literal\">true</span>;\n                    }\n                }\n\n                <span class=\"hljs-keyword\">if</span> (!connection)\n                {\n                    <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> ArgumentException(<span class=\"hljs-string\">&quot;Graph must be connected!&quot;</span>);\n                }\n            }\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Determine which node should be added next to the MST.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;adjacencyMatrix&quot;&gt;</span>Adjacency matrix of graph.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;key&quot;&gt;</span>Currently known minimum edge weight connected to each node.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;added&quot;&gt;</span>Whether or not a node has been added to the MST.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;parent&quot;&gt;</span>The node that added the node to the MST. Used for building MST adjacency matrix.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">GetNextNode</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">float</span>[,] adjacencyMatrix, <span class=\"hljs-built_in\">float</span>[] key, <span class=\"hljs-built_in\">bool</span>[] added, <span class=\"hljs-built_in\">int</span>[] parent</span>)</span>\n        {\n            <span class=\"hljs-keyword\">var</span> numNodes = adjacencyMatrix.GetLength(<span class=\"hljs-number\">0</span>);\n            <span class=\"hljs-keyword\">var</span> minWeight = <span class=\"hljs-built_in\">float</span>.PositiveInfinity;\n\n            <span class=\"hljs-keyword\">var</span> node = <span class=\"hljs-number\">-1</span>;\n\n            <span class=\"hljs-comment\">// Find node with smallest node with known edge weight not in tree. Will always start with starting node</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numNodes; i++)\n            {\n                <span class=\"hljs-keyword\">if</span> (!added[i] &amp;&amp; key[i] &lt; minWeight)\n                {\n                    minWeight = key[i];\n                    node = i;\n                }\n            }\n\n            <span class=\"hljs-comment\">// Add node to mst</span>\n            added[node] = <span class=\"hljs-literal\">true</span>;\n\n            <span class=\"hljs-comment\">// Update smallest found edge weights and parent for adjacent nodes</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; numNodes; i++)\n            {\n                <span class=\"hljs-keyword\">if</span> (!added[i] &amp;&amp; adjacencyMatrix[node, i] &lt; key[i])\n                {\n                    key[i] = adjacencyMatrix[node, i];\n                    parent[i] = node;\n                }\n            }\n        }\n    }\n}\n"
    }
  },
  "contributors": [],
  "explanationUrl": {}
}