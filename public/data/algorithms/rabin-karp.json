{
  "slug": "rabin-karp",
  "name": "Rabin Karp",
  "categories": [
    "strings"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "strings/rabin_karp.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/strings/rabin_karp.py",
      "code": "<span class=\"hljs-comment\"># Numbers of alphabet which we call base</span>\nalphabet_size = <span class=\"hljs-number\">256</span>\n<span class=\"hljs-comment\"># Modulus to hash a string</span>\nmodulus = <span class=\"hljs-number\">1000003</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">rabin_karp</span>(<span class=\"hljs-params\">pattern: <span class=\"hljs-built_in\">str</span>, text: <span class=\"hljs-built_in\">str</span></span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    The Rabin-Karp Algorithm for finding a pattern within a piece of text\n    with complexity O(nm), most efficient when it is used with multiple patterns\n    as it is able to check if any of a set of patterns match a section of text in o(1)\n    given the precomputed hashes.\n\n    This will be the simple version which only assumes one pattern is being searched\n    for but it&#x27;s not hard to modify\n\n    1) Calculate pattern hash\n\n    2) Step through the text one character at a time passing a window with the same\n        length as the pattern\n        calculating the hash of the text within the window compare it with the hash\n        of the pattern. Only testing equality if the hashes match\n    &quot;&quot;&quot;</span>\n    p_len = <span class=\"hljs-built_in\">len</span>(pattern)\n    t_len = <span class=\"hljs-built_in\">len</span>(text)\n    <span class=\"hljs-keyword\">if</span> p_len &gt; t_len:\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n\n    p_hash = <span class=\"hljs-number\">0</span>\n    text_hash = <span class=\"hljs-number\">0</span>\n    modulus_power = <span class=\"hljs-number\">1</span>\n\n    <span class=\"hljs-comment\"># Calculating the hash of pattern and substring of text</span>\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(p_len):\n        p_hash = (<span class=\"hljs-built_in\">ord</span>(pattern[i]) + p_hash * alphabet_size) % modulus\n        text_hash = (<span class=\"hljs-built_in\">ord</span>(text[i]) + text_hash * alphabet_size) % modulus\n        <span class=\"hljs-keyword\">if</span> i == p_len - <span class=\"hljs-number\">1</span>:\n            <span class=\"hljs-keyword\">continue</span>\n        modulus_power = (modulus_power * alphabet_size) % modulus\n\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">0</span>, t_len - p_len + <span class=\"hljs-number\">1</span>):\n        <span class=\"hljs-keyword\">if</span> text_hash == p_hash <span class=\"hljs-keyword\">and</span> text[i : i + p_len] == pattern:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n        <span class=\"hljs-keyword\">if</span> i == t_len - p_len:\n            <span class=\"hljs-keyword\">continue</span>\n        <span class=\"hljs-comment\"># Calculate the https://en.wikipedia.org/wiki/Rolling_hash</span>\n        text_hash = (\n            (text_hash - <span class=\"hljs-built_in\">ord</span>(text[i]) * modulus_power) * alphabet_size\n            + <span class=\"hljs-built_in\">ord</span>(text[i + p_len])\n        ) % modulus\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">test_rabin_karp</span>() -&gt; <span class=\"hljs-literal\">None</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    &gt;&gt;&gt; test_rabin_karp()\n    Success.\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-comment\"># Test 1)</span>\n    pattern = <span class=\"hljs-string\">&quot;abc1abc12&quot;</span>\n    text1 = <span class=\"hljs-string\">&quot;alskfjaldsabc1abc1abc12k23adsfabcabc&quot;</span>\n    text2 = <span class=\"hljs-string\">&quot;alskfjaldsk23adsfabcabc&quot;</span>\n    <span class=\"hljs-keyword\">assert</span> rabin_karp(pattern, text1) <span class=\"hljs-keyword\">and</span> <span class=\"hljs-keyword\">not</span> rabin_karp(pattern, text2)\n\n    <span class=\"hljs-comment\"># Test 2)</span>\n    pattern = <span class=\"hljs-string\">&quot;ABABX&quot;</span>\n    text = <span class=\"hljs-string\">&quot;ABABZABABYABABX&quot;</span>\n    <span class=\"hljs-keyword\">assert</span> rabin_karp(pattern, text)\n\n    <span class=\"hljs-comment\"># Test 3)</span>\n    pattern = <span class=\"hljs-string\">&quot;AAAB&quot;</span>\n    text = <span class=\"hljs-string\">&quot;ABAAAAAB&quot;</span>\n    <span class=\"hljs-keyword\">assert</span> rabin_karp(pattern, text)\n\n    <span class=\"hljs-comment\"># Test 4)</span>\n    pattern = <span class=\"hljs-string\">&quot;abcdabcy&quot;</span>\n    text = <span class=\"hljs-string\">&quot;abcxabcdabxabcdabcdabcy&quot;</span>\n    <span class=\"hljs-keyword\">assert</span> rabin_karp(pattern, text)\n\n    <span class=\"hljs-comment\"># Test 5)</span>\n    pattern = <span class=\"hljs-string\">&quot;Lü&quot;</span>\n    text = <span class=\"hljs-string\">&quot;Lüsai&quot;</span>\n    <span class=\"hljs-keyword\">assert</span> rabin_karp(pattern, text)\n    pattern = <span class=\"hljs-string\">&quot;Lue&quot;</span>\n    <span class=\"hljs-keyword\">assert</span> <span class=\"hljs-keyword\">not</span> rabin_karp(pattern, text)\n    <span class=\"hljs-built_in\">print</span>(<span class=\"hljs-string\">&quot;Success.&quot;</span>)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    test_rabin_karp()\n"
    },
    "c-plus-plus": {
      "dir": "strings/rabin_karp.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/strings/rabin_karp.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * \\file\n * \\brief The [Rabin-Karp\n * Algorithm](https://en.wikipedia.org/wiki/Rabin–Karp_algorithm) for finding a\n * pattern within a piece of text with complexity O(n + m)\n */</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cmath&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> _MSC_VER</span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span>  <span class=\"hljs-comment\">// use this for MS Visucal C++</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cstring&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> PRIME 5  <span class=\"hljs-comment\">///&lt; Prime modulus for hash functions</span></span>\n\n<span class=\"hljs-keyword\">namespace</span> string_search {\n<span class=\"hljs-comment\">/**\n * convert a string to an intger - called as hashing function\n * \\param[in] s source of string to hash\n * \\param[in] n length of substring to hash\n * \\returns hash integer\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">create_hash</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::string&amp; s, <span class=\"hljs-type\">int</span> n)</span> </span>{\n    <span class=\"hljs-type\">int64_t</span> result = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; n; ++i) {\n        result += (<span class=\"hljs-type\">int64_t</span>)(s[i] * (<span class=\"hljs-type\">int64_t</span>)<span class=\"hljs-built_in\">pow</span>(PRIME, i));\n    }\n    <span class=\"hljs-keyword\">return</span> result;\n}\n\n<span class=\"hljs-comment\">/**\n * re-hash a string using known existing hash\n * \\param[in] s source of string to hash\n * \\param[in] old_index previous index of string\n * \\param[in] new_index new index of string\n * \\param[in] old_hash previous hash of substring\n * \\param[in] patLength length of substring to hash\n * \\returns new hash integer\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int64_t</span> <span class=\"hljs-title\">recalculate_hash</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::string&amp; s, <span class=\"hljs-type\">int</span> old_index, <span class=\"hljs-type\">int</span> new_index,\n                         <span class=\"hljs-type\">int64_t</span> old_hash, <span class=\"hljs-type\">int</span> patLength)</span> </span>{\n    <span class=\"hljs-type\">int64_t</span> new_hash = old_hash - s[old_index];\n    new_hash /= PRIME;\n    new_hash += (<span class=\"hljs-type\">int64_t</span>)(s[new_index] * (<span class=\"hljs-type\">int64_t</span>)<span class=\"hljs-built_in\">pow</span>(PRIME, patLength - <span class=\"hljs-number\">1</span>));\n    <span class=\"hljs-keyword\">return</span> new_hash;\n}\n\n<span class=\"hljs-comment\">/**\n * compare if two sub-strings are equal\n * \\param[in] str1 string pattern to search\n * \\param[in] str2 text in which to search\n * \\param[in] start1,end1 start and end indices for substring in str1\n * \\param[in] start2,end2 start and end indices for substring in str2\n * \\returns `true` if pattern was found\n * \\returns `false` if pattern was not found\n * @note can this be replaced by std::string::compare?\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">check_if_equal</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::string&amp; str1, <span class=\"hljs-type\">const</span> std::string&amp; str2,\n                    <span class=\"hljs-type\">int</span> start1, <span class=\"hljs-type\">int</span> end1, <span class=\"hljs-type\">int</span> start2, <span class=\"hljs-type\">int</span> end2)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (end1 - start1 != end2 - start2) {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n    }\n    <span class=\"hljs-keyword\">while</span> (start1 &lt;= end1 &amp;&amp; start2 &lt;= end2) {\n        <span class=\"hljs-keyword\">if</span> (str1[start1] != str2[start2]) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;\n        }\n        start1++;\n        start2++;\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;\n}\n\n<span class=\"hljs-comment\">/**\n *  Perform string pattern search using Rabin-Karp algorithm\n *  @param[in] str string to search in\n *  @param[in] pat pattern to search for\n *  @return index of first occurrence of pattern\n *  @return -1 if pattern not found\n */</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">rabin_karp</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::string&amp; str, <span class=\"hljs-type\">const</span> std::string&amp; pat)</span> </span>{\n    <span class=\"hljs-type\">int64_t</span> pat_hash = <span class=\"hljs-built_in\">create_hash</span>(pat, pat.<span class=\"hljs-built_in\">size</span>());\n    <span class=\"hljs-type\">int64_t</span> str_hash = <span class=\"hljs-built_in\">create_hash</span>(str, pat.<span class=\"hljs-built_in\">size</span>());\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt;= str.<span class=\"hljs-built_in\">size</span>() - pat.<span class=\"hljs-built_in\">size</span>(); ++i) {\n        <span class=\"hljs-keyword\">if</span> (pat_hash == str_hash &amp;&amp;\n            <span class=\"hljs-built_in\">check_if_equal</span>(str, pat, i, i + pat.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>,\n                           pat.<span class=\"hljs-built_in\">size</span>() - <span class=\"hljs-number\">1</span>)) {\n            <span class=\"hljs-keyword\">return</span> i;\n        }\n        <span class=\"hljs-keyword\">if</span> (i &lt; str.<span class=\"hljs-built_in\">size</span>() - pat.<span class=\"hljs-built_in\">size</span>()) {\n            str_hash =\n                <span class=\"hljs-built_in\">recalculate_hash</span>(str, i, i + pat.<span class=\"hljs-built_in\">size</span>(), str_hash, pat.<span class=\"hljs-built_in\">size</span>());\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;  <span class=\"hljs-comment\">// return -1 if given pattern not found</span>\n}\n\n}  <span class=\"hljs-comment\">// namespace string_search</span>\n\n<span class=\"hljs-keyword\">using</span> string_search::rabin_karp;\n\n<span class=\"hljs-comment\">/** Main function */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> </span>{\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-built_in\">rabin_karp</span>(<span class=\"hljs-string\">&quot;helloWorld&quot;</span>, <span class=\"hljs-string\">&quot;world&quot;</span>) == <span class=\"hljs-number\">-1</span>);\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-built_in\">rabin_karp</span>(<span class=\"hljs-string\">&quot;helloWorld&quot;</span>, <span class=\"hljs-string\">&quot;World&quot;</span>) == <span class=\"hljs-number\">5</span>);\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-built_in\">rabin_karp</span>(<span class=\"hljs-string\">&quot;this_is_c++&quot;</span>, <span class=\"hljs-string\">&quot;c++&quot;</span>) == <span class=\"hljs-number\">8</span>);\n    <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-built_in\">rabin_karp</span>(<span class=\"hljs-string\">&quot;happy_coding&quot;</span>, <span class=\"hljs-string\">&quot;happy&quot;</span>) == <span class=\"hljs-number\">0</span>);\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "java": {
      "dir": "src/main/java/com/thealgorithms/others/RabinKarp.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src/main/java/com/thealgorithms/others/RabinKarp.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.others;\n\n<span class=\"hljs-comment\">/**\n * <span class=\"hljs-doctag\">@author</span> Prateek Kumar Oraon (https://github.com/prateekKrOraon)\n */</span>\n<span class=\"hljs-keyword\">import</span> java.util.Scanner;\n\n<span class=\"hljs-comment\">// An implementation of Rabin-Karp string matching algorithm</span>\n<span class=\"hljs-comment\">// Program will simply end if there is no match</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">RabinKarp</span> {\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">Scanner</span> <span class=\"hljs-variable\">scanner</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">null</span>;\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">final</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">d</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">256</span>;\n\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(String[] args)</span> {\n\n        scanner = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Scanner</span>(System.in);\n        System.out.println(<span class=\"hljs-string\">&quot;Enter String&quot;</span>);\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">text</span> <span class=\"hljs-operator\">=</span> scanner.nextLine();\n        System.out.println(<span class=\"hljs-string\">&quot;Enter pattern&quot;</span>);\n        <span class=\"hljs-type\">String</span> <span class=\"hljs-variable\">pattern</span> <span class=\"hljs-operator\">=</span> scanner.nextLine();\n\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">q</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">101</span>;\n        searchPat(text, pattern, q);\n    }\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">searchPat</span><span class=\"hljs-params\">(String text, String pattern, <span class=\"hljs-type\">int</span> q)</span> {\n\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">m</span> <span class=\"hljs-operator\">=</span> pattern.length();\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">n</span> <span class=\"hljs-operator\">=</span> text.length();\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">t</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">p</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">h</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>;\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">j</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>;\n\n        h = (<span class=\"hljs-type\">int</span>) Math.pow(d, m - <span class=\"hljs-number\">1</span>) % q;\n\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; m; i++) {\n            <span class=\"hljs-comment\">// hash value is calculated for each character and then added with the hash value of the next</span>\n            <span class=\"hljs-comment\">// character for pattern</span>\n            <span class=\"hljs-comment\">// as well as the text for length equal to the length of pattern</span>\n            p = (d * p + pattern.charAt(i)) % q;\n            t = (d * t + text.charAt(i)) % q;\n        }\n\n        <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt;= n - m; i++) {\n\n            <span class=\"hljs-comment\">// if the calculated hash value of the pattern and text matches then</span>\n            <span class=\"hljs-comment\">// all the characters of the pattern is matched with the text of length equal to length of the</span>\n            <span class=\"hljs-comment\">// pattern</span>\n            <span class=\"hljs-comment\">// if all matches then pattern exist in string</span>\n            <span class=\"hljs-comment\">// if not then the hash value of the first character of the text is subtracted and hash value</span>\n            <span class=\"hljs-comment\">// of the next character after the end</span>\n            <span class=\"hljs-comment\">// of the evaluated characters is added</span>\n            <span class=\"hljs-keyword\">if</span> (p == t) {\n\n                <span class=\"hljs-comment\">// if hash value matches then the individual characters are matched</span>\n                <span class=\"hljs-keyword\">for</span> (j = <span class=\"hljs-number\">0</span>; j &lt; m; j++) {\n\n                    <span class=\"hljs-comment\">// if not matched then break out of the loop</span>\n                    <span class=\"hljs-keyword\">if</span> (text.charAt(i + j) != pattern.charAt(j)) {\n                        <span class=\"hljs-keyword\">break</span>;\n                    }\n                }\n\n                <span class=\"hljs-comment\">// if all characters are matched then pattern exist in the string</span>\n                <span class=\"hljs-keyword\">if</span> (j == m) {\n                    System.out.println(<span class=\"hljs-string\">&quot;Pattern found at index &quot;</span> + i);\n                }\n            }\n\n            <span class=\"hljs-comment\">// if i&lt;n-m then hash value of the first character of the text is subtracted and hash value of</span>\n            <span class=\"hljs-comment\">// the next character after the end</span>\n            <span class=\"hljs-comment\">// of the evaluated characters is added to get the hash value of the next window of characters</span>\n            <span class=\"hljs-comment\">// in the text</span>\n            <span class=\"hljs-keyword\">if</span> (i &lt; n - m) {\n                t = (d * (t - text.charAt(i) * h) + text.charAt(i + m)) % q;\n\n                <span class=\"hljs-comment\">// if hash value becomes less than zero than q is added to make it positive</span>\n                <span class=\"hljs-keyword\">if</span> (t &lt; <span class=\"hljs-number\">0</span>) {\n                    t = (t + q);\n                }\n            }\n        }\n    }\n}\n"
    },
    "f-sharp": {
      "dir": "Algorithms/Strings/RabinKarp.fs",
      "url": "https://github.com/TheAlgorithms/f-sharp/tree/master/Algorithms/Strings/RabinKarp.fs",
      "code": "﻿<span class=\"hljs-keyword\">namespace</span> Algorithms.Strings\n\n<span class=\"hljs-keyword\">module</span> RabinKarp <span class=\"hljs-operator\">=</span>\n    <span class=\"hljs-comment\">/// Numbers of alphabet which we call base</span>\n    <span class=\"hljs-keyword\">let</span> alphabetSize <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">256</span>L\n\n    <span class=\"hljs-comment\">/// Modulus to hash a string</span>\n    <span class=\"hljs-keyword\">let</span> modulus <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1000003</span>L\n\n    <span class=\"hljs-keyword\">let</span> nfmod (a<span class=\"hljs-operator\">:</span> <span class=\"hljs-type\">int64</span>, b<span class=\"hljs-operator\">:</span> <span class=\"hljs-type\">int64</span>) <span class=\"hljs-operator\">=</span>\n        <span class=\"hljs-keyword\">let</span> aD <span class=\"hljs-operator\">=</span> double a\n        <span class=\"hljs-keyword\">let</span> bD <span class=\"hljs-operator\">=</span> double b\n        int64 (aD <span class=\"hljs-operator\">-</span> bD <span class=\"hljs-operator\">*</span> floor (aD <span class=\"hljs-operator\">/</span> bD))\n\n    <span class=\"hljs-comment\">/// &lt;summary&gt;</span>\n    <span class=\"hljs-comment\">/// The Rabin-Karp Algorithm for finding a pattern within a piece of text</span>\n    <span class=\"hljs-comment\">/// with complexity O(nm), most efficient when it is used with multiple patterns</span>\n    <span class=\"hljs-comment\">/// as it is able to check if any of a set of patterns match a section of text in o(1)</span>\n    <span class=\"hljs-comment\">/// given the precomputed hashes.</span>\n    <span class=\"hljs-comment\">/// &lt;/summary&gt;</span>\n    <span class=\"hljs-comment\">/// &lt;remarks&gt;</span>\n    <span class=\"hljs-comment\">/// This will be the simple version which only assumes one pattern is being searched</span>\n    <span class=\"hljs-comment\">/// for but it&#x27;s not hard to modify</span>\n    <span class=\"hljs-comment\">///</span>\n    <span class=\"hljs-comment\">/// 1) Calculate pattern hash</span>\n    <span class=\"hljs-comment\">///</span>\n    <span class=\"hljs-comment\">/// 2) Step through the text one character at a time passing a window with the same</span>\n    <span class=\"hljs-comment\">/// length as the pattern</span>\n    <span class=\"hljs-comment\">/// calculating the hash of the text within the window compare it with the hash</span>\n    <span class=\"hljs-comment\">/// of the pattern. Only testing equality if the hashes match</span>\n    <span class=\"hljs-comment\">/// &lt;/remarks&gt;</span>\n    <span class=\"hljs-comment\">/// &lt;param name=&quot;pattern&quot;&gt;&lt;/param&gt;</span>\n    <span class=\"hljs-comment\">/// &lt;param name=&quot;text&quot;&gt;&lt;/param&gt;</span>\n    <span class=\"hljs-comment\">/// &lt;returns&gt;&lt;/returns&gt;</span>\n    <span class=\"hljs-keyword\">let</span> rabinKarp (pattern<span class=\"hljs-operator\">:</span> <span class=\"hljs-type\">string</span>, text<span class=\"hljs-operator\">:</span> <span class=\"hljs-type\">string</span>)<span class=\"hljs-operator\">:</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-operator\">=</span>\n\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mutable</span> result <span class=\"hljs-operator\">=</span> <span class=\"hljs-literal\">false</span>\n\n        <span class=\"hljs-keyword\">let</span> patLen <span class=\"hljs-operator\">=</span> pattern.Length\n        <span class=\"hljs-keyword\">let</span> textLen <span class=\"hljs-operator\">=</span> text.Length\n\n        <span class=\"hljs-keyword\">match</span> patLen <span class=\"hljs-keyword\">with</span>\n        <span class=\"hljs-operator\">|</span> p <span class=\"hljs-keyword\">when</span> p <span class=\"hljs-operator\">&gt;</span> textLen <span class=\"hljs-operator\">-&gt;</span> <span class=\"hljs-literal\">false</span>\n        <span class=\"hljs-operator\">|</span> _ <span class=\"hljs-operator\">-&gt;</span>\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mutable</span> patternHash <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>L\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mutable</span> textHash <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">0</span>L\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mutable</span> modulusPower <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">1</span>L\n\n\n            <span class=\"hljs-comment\">// Calculating the hash of pattern and substring of text</span>\n            <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-operator\">..</span> (patLen <span class=\"hljs-operator\">-</span> <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">do</span>\n                patternHash <span class=\"hljs-operator\">&lt;-</span> (int64 (pattern.[i]) <span class=\"hljs-operator\">+</span> patternHash <span class=\"hljs-operator\">*</span> alphabetSize) <span class=\"hljs-operator\">%</span> modulus\n                textHash <span class=\"hljs-operator\">&lt;-</span> (int64 (text.[i]) <span class=\"hljs-operator\">+</span> textHash <span class=\"hljs-operator\">*</span> alphabetSize) <span class=\"hljs-operator\">%</span> modulus\n\n                <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-operator\">&lt;&gt;</span> (patLen <span class=\"hljs-operator\">-</span> <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">then</span>\n                    modulusPower <span class=\"hljs-operator\">&lt;-</span> (modulusPower <span class=\"hljs-operator\">*</span> alphabetSize) <span class=\"hljs-operator\">%</span> modulus\n\n\n            <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span> <span class=\"hljs-operator\">..</span> (textLen <span class=\"hljs-operator\">-</span> patLen <span class=\"hljs-operator\">+</span> <span class=\"hljs-number\">1</span>) <span class=\"hljs-keyword\">do</span>\n                <span class=\"hljs-keyword\">if</span> textHash <span class=\"hljs-operator\">=</span> patternHash\n                   <span class=\"hljs-operator\">&amp;&amp;</span> text.[i<span class=\"hljs-operator\">..</span>i <span class=\"hljs-operator\">+</span> (patLen <span class=\"hljs-operator\">-</span> <span class=\"hljs-number\">1</span>)] <span class=\"hljs-operator\">=</span> pattern <span class=\"hljs-keyword\">then</span>\n                    result <span class=\"hljs-operator\">&lt;-</span> <span class=\"hljs-literal\">true</span>\n\n                <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">not</span> result <span class=\"hljs-keyword\">then</span>\n                    <span class=\"hljs-keyword\">if</span> i <span class=\"hljs-operator\">&lt;&gt;</span> (textLen <span class=\"hljs-operator\">-</span> patLen) <span class=\"hljs-keyword\">then</span>\n                        <span class=\"hljs-keyword\">let</span> first <span class=\"hljs-operator\">=</span>\n                            (textHash <span class=\"hljs-operator\">-</span> int64 (text.[i]) <span class=\"hljs-operator\">*</span> modulusPower)\n                            <span class=\"hljs-operator\">*</span> alphabetSize\n\n                        <span class=\"hljs-keyword\">let</span> second <span class=\"hljs-operator\">=</span> int64 (text.[i <span class=\"hljs-operator\">+</span> patLen])\n                        <span class=\"hljs-keyword\">let</span> third <span class=\"hljs-operator\">=</span> (first <span class=\"hljs-operator\">+</span> second) <span class=\"hljs-operator\">%</span> modulus\n\n                        textHash <span class=\"hljs-operator\">&lt;-</span>\n                            ((((textHash <span class=\"hljs-operator\">-</span> int64 (text.[i]) <span class=\"hljs-operator\">*</span> modulusPower)\n                               <span class=\"hljs-operator\">*</span> alphabetSize)\n                              <span class=\"hljs-operator\">+</span> int64 (text.[i <span class=\"hljs-operator\">+</span> patLen])) <span class=\"hljs-operator\">%</span> modulus)\n                            <span class=\"hljs-operator\">+</span> modulus\n\n            result\n"
    },
    "rust": {
      "dir": "src/string/rabin_karp.rs",
      "url": "https://github.com/TheAlgorithms/rust/tree/master/src/string/rabin_karp.rs",
      "code": "<span class=\"hljs-keyword\">const</span> MODULUS: <span class=\"hljs-type\">u16</span> = <span class=\"hljs-number\">101</span>;\n<span class=\"hljs-keyword\">const</span> BASE: <span class=\"hljs-type\">u16</span> = <span class=\"hljs-number\">256</span>;\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">rabin_karp</span>(target: <span class=\"hljs-type\">String</span>, pattern: <span class=\"hljs-type\">String</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Vec</span>&lt;<span class=\"hljs-type\">usize</span>&gt; {\n    <span class=\"hljs-comment\">// Quick exit</span>\n    <span class=\"hljs-keyword\">if</span> target.<span class=\"hljs-title function_ invoke__\">is_empty</span>() || pattern.<span class=\"hljs-title function_ invoke__\">is_empty</span>() || pattern.<span class=\"hljs-title function_ invoke__\">len</span>() &gt; target.<span class=\"hljs-title function_ invoke__\">len</span>() {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">vec!</span>[];\n    }\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">pattern_hash</span> = <span class=\"hljs-title function_ invoke__\">hash</span>(pattern.<span class=\"hljs-title function_ invoke__\">as_str</span>());\n\n    <span class=\"hljs-comment\">// Pre-calculate BASE^(n-1)</span>\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">pow_rem</span>: <span class=\"hljs-type\">u16</span> = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">_</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..pattern.<span class=\"hljs-title function_ invoke__\">len</span>() - <span class=\"hljs-number\">1</span> {\n        pow_rem *= BASE;\n        pow_rem %= MODULUS;\n    }\n\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">rolling_hash</span> = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">ret</span> = <span class=\"hljs-built_in\">vec!</span>[];\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>..=target.<span class=\"hljs-title function_ invoke__\">len</span>() - pattern.<span class=\"hljs-title function_ invoke__\">len</span>() {\n        rolling_hash = <span class=\"hljs-keyword\">if</span> i == <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-title function_ invoke__\">hash</span>(&amp;target[<span class=\"hljs-number\">0</span>..pattern.<span class=\"hljs-title function_ invoke__\">len</span>()])\n        } <span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-title function_ invoke__\">recalculate_hash</span>(\n                target.<span class=\"hljs-title function_ invoke__\">as_str</span>(),\n                i - <span class=\"hljs-number\">1</span>,\n                i + pattern.<span class=\"hljs-title function_ invoke__\">len</span>() - <span class=\"hljs-number\">1</span>,\n                rolling_hash,\n                pow_rem,\n            )\n        };\n        <span class=\"hljs-keyword\">if</span> rolling_hash == pattern_hash &amp;&amp; pattern[..] == target[i..i + pattern.<span class=\"hljs-title function_ invoke__\">len</span>()] {\n            ret.<span class=\"hljs-title function_ invoke__\">push</span>(i);\n        }\n    }\n    ret\n}\n\n<span class=\"hljs-comment\">// hash(s) is defined as BASE^(n-1) * s_0 + BASE^(n-2) * s_1 + ... + BASE^0 * s_(n-1)</span>\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">hash</span>(s: &amp;<span class=\"hljs-type\">str</span>) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">u16</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">res</span>: <span class=\"hljs-type\">u16</span> = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> &amp;c <span class=\"hljs-keyword\">in</span> s.<span class=\"hljs-title function_ invoke__\">as_bytes</span>().<span class=\"hljs-title function_ invoke__\">iter</span>() {\n        res = (res * BASE % MODULUS + c <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u16</span>) % MODULUS;\n    }\n    res\n}\n\n<span class=\"hljs-comment\">// new_hash = (old_hash - BASE^(n-1) * s_(i-n)) * BASE + s_i</span>\n<span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">recalculate_hash</span>(\n    s: &amp;<span class=\"hljs-type\">str</span>,\n    old_index: <span class=\"hljs-type\">usize</span>,\n    new_index: <span class=\"hljs-type\">usize</span>,\n    old_hash: <span class=\"hljs-type\">u16</span>,\n    pow_rem: <span class=\"hljs-type\">u16</span>,\n) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">u16</span> {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">new_hash</span> = old_hash;\n    <span class=\"hljs-keyword\">let</span> (old_ch, new_ch) = (\n        s.<span class=\"hljs-title function_ invoke__\">as_bytes</span>()[old_index] <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u16</span>,\n        s.<span class=\"hljs-title function_ invoke__\">as_bytes</span>()[new_index] <span class=\"hljs-keyword\">as</span> <span class=\"hljs-type\">u16</span>,\n    );\n    new_hash = (new_hash + MODULUS - pow_rem * old_ch % MODULUS) % MODULUS;\n    new_hash = (new_hash * BASE + new_ch) % MODULUS;\n    new_hash\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::*;\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">hi_hash</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">hash_result</span> = <span class=\"hljs-title function_ invoke__\">hash</span>(<span class=\"hljs-string\">&quot;hi&quot;</span>);\n        <span class=\"hljs-built_in\">assert_eq!</span>(hash_result, <span class=\"hljs-number\">65</span>);\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">abr_hash</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">hash_result</span> = <span class=\"hljs-title function_ invoke__\">hash</span>(<span class=\"hljs-string\">&quot;abr&quot;</span>);\n        <span class=\"hljs-built_in\">assert_eq!</span>(hash_result, <span class=\"hljs-number\">4</span>);\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">bra_hash</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">hash_result</span> = <span class=\"hljs-title function_ invoke__\">hash</span>(<span class=\"hljs-string\">&quot;bra&quot;</span>);\n        <span class=\"hljs-built_in\">assert_eq!</span>(hash_result, <span class=\"hljs-number\">30</span>);\n    }\n\n    <span class=\"hljs-comment\">// Attribution to @pgimalac for his tests from Knuth-Morris-Pratt</span>\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">each_letter_matches</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">index</span> = <span class=\"hljs-title function_ invoke__\">rabin_karp</span>(<span class=\"hljs-string\">&quot;aaa&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>(), <span class=\"hljs-string\">&quot;a&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>());\n        <span class=\"hljs-built_in\">assert_eq!</span>(index, <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>]);\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">a_few_separate_matches</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">index</span> = <span class=\"hljs-title function_ invoke__\">rabin_karp</span>(<span class=\"hljs-string\">&quot;abababa&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>(), <span class=\"hljs-string\">&quot;ab&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>());\n        <span class=\"hljs-built_in\">assert_eq!</span>(index, <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>]);\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">one_match</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">index</span> = <span class=\"hljs-title function_ invoke__\">rabin_karp</span>(<span class=\"hljs-string\">&quot;ABC ABCDAB ABCDABCDABDE&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>(), <span class=\"hljs-string\">&quot;ABCDABD&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>());\n        <span class=\"hljs-built_in\">assert_eq!</span>(index, <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">15</span>]);\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">lots_of_matches</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">index</span> = <span class=\"hljs-title function_ invoke__\">rabin_karp</span>(<span class=\"hljs-string\">&quot;aaabaabaaaaa&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>(), <span class=\"hljs-string\">&quot;aa&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>());\n        <span class=\"hljs-built_in\">assert_eq!</span>(index, <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">10</span>]);\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">lots_of_intricate_matches</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">index</span> = <span class=\"hljs-title function_ invoke__\">rabin_karp</span>(<span class=\"hljs-string\">&quot;ababababa&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>(), <span class=\"hljs-string\">&quot;aba&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>());\n        <span class=\"hljs-built_in\">assert_eq!</span>(index, <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>]);\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">not_found0</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">index</span> = <span class=\"hljs-title function_ invoke__\">rabin_karp</span>(<span class=\"hljs-string\">&quot;abcde&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>(), <span class=\"hljs-string\">&quot;f&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>());\n        <span class=\"hljs-built_in\">assert_eq!</span>(index, <span class=\"hljs-built_in\">vec!</span>[]);\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">not_found1</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">index</span> = <span class=\"hljs-title function_ invoke__\">rabin_karp</span>(<span class=\"hljs-string\">&quot;abcde&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>(), <span class=\"hljs-string\">&quot;ac&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>());\n        <span class=\"hljs-built_in\">assert_eq!</span>(index, <span class=\"hljs-built_in\">vec!</span>[]);\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">not_found2</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">index</span> = <span class=\"hljs-title function_ invoke__\">rabin_karp</span>(<span class=\"hljs-string\">&quot;ababab&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>(), <span class=\"hljs-string\">&quot;bababa&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>());\n        <span class=\"hljs-built_in\">assert_eq!</span>(index, <span class=\"hljs-built_in\">vec!</span>[]);\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">empty_string</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">index</span> = <span class=\"hljs-title function_ invoke__\">rabin_karp</span>(<span class=\"hljs-string\">&quot;&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>(), <span class=\"hljs-string\">&quot;abcdef&quot;</span>.<span class=\"hljs-title function_ invoke__\">to_string</span>());\n        <span class=\"hljs-built_in\">assert_eq!</span>(index, <span class=\"hljs-built_in\">vec!</span>[]);\n    }\n}\n"
    },
    "julia": {
      "dir": "src/strings/rabin_karp.jl",
      "url": "https://github.com/TheAlgorithms/julia/tree/master/src/strings/rabin_karp.jl",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;\n    rabin_karp(text, pattern)\n\n# Brief:\n    A function that finds all occurrences of a pattern in the given text.\n    Instead of checking each character ot the pattern with each character block of the text,\n    for each character block calculate the hash value, and only if that value matches hash value of the pattern,\n    compare them character by character. These blocks are the same length as the pattern.\n\n# Returns:\n    A list with starting indices where the pattern was found\n\n# References:\n    https://www.geeksforgeeks.org/rabin-karp-algorithm-for-pattern-searching/\n\n# Contributed by: [Nikola Mircic](https://github.com/Nikola-Mircic)\n&quot;&quot;&quot;</span>\n<span class=\"hljs-keyword\">function</span> rabin_karp(text::<span class=\"hljs-built_in\">String</span>, pattern::<span class=\"hljs-built_in\">String</span>)\n    indices = <span class=\"hljs-built_in\">Array</span>{<span class=\"hljs-built_in\">Int64</span>}(<span class=\"hljs-literal\">undef</span>, <span class=\"hljs-number\">0</span>)<span class=\"hljs-comment\"># An array to store matching indices</span>\n\n    txt_len = length(text) <span class=\"hljs-comment\"># Length of the text</span>\n    ptn_len = length(pattern) <span class=\"hljs-comment\"># Length of the pattern</span>\n\n    <span class=\"hljs-comment\"># Convert string to an array of chars, and then to an array of integers</span>\n    text = text |&gt; collect .|&gt; <span class=\"hljs-built_in\">Int</span>\n    pattern = pattern |&gt; collect .|&gt; <span class=\"hljs-built_in\">Int</span>\n\n    <span class=\"hljs-comment\"># If the text is shorter than the pattern, return empty vector</span>\n    <span class=\"hljs-keyword\">if</span> txt_len &lt; ptn_len\n        <span class=\"hljs-keyword\">return</span> indices\n    <span class=\"hljs-keyword\">end</span>\n\n    t_hash = <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\"># A hash value of the current block</span>\n    p_hash = <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\"># A hash value of the pattern</span>\n\n    d = <span class=\"hljs-number\">256</span> <span class=\"hljs-comment\"># Maximum number of different characters in the text</span>\n    m_hash = <span class=\"hljs-number\">2048</span> <span class=\"hljs-comment\"># Maximum hash value</span>\n    pow = <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\"># d^(pattern length - 1) to easily remove the first character from the hash value</span>\n\n    <span class=\"hljs-comment\"># Calculate the pow</span>\n    <span class=\"hljs-keyword\">for</span> _ <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>:(ptn_len-<span class=\"hljs-number\">1</span>)\n        pow = (pow * d) % m_hash\n    <span class=\"hljs-keyword\">end</span>\n\n    <span class=\"hljs-comment\"># Calculate the first hash value</span>\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>:ptn_len\n        t_hash = (t_hash * d + text[i]) % m_hash\n        p_hash = (p_hash * d + pattern[i]) % m_hash\n    <span class=\"hljs-keyword\">end</span>\n\n    <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">1</span>:(txt_len-ptn_len+<span class=\"hljs-number\">1</span>)\n        <span class=\"hljs-comment\"># If hash values match</span>\n        <span class=\"hljs-keyword\">if</span> p_hash == t_hash\n            test = <span class=\"hljs-literal\">true</span>\n            <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-number\">0</span>:(ptn_len-<span class=\"hljs-number\">1</span>)\n                <span class=\"hljs-keyword\">if</span> text[i+j] != pattern[j+<span class=\"hljs-number\">1</span>] <span class=\"hljs-comment\"># The hash values are the same, but the strings are different</span>\n                    test = <span class=\"hljs-literal\">false</span>\n                    <span class=\"hljs-keyword\">break</span>\n                <span class=\"hljs-keyword\">end</span>\n            <span class=\"hljs-keyword\">end</span>\n            <span class=\"hljs-keyword\">if</span> test <span class=\"hljs-comment\"># The hash values are the same, and the strings are equals</span>\n                push!(indices, i)\n            <span class=\"hljs-keyword\">end</span>\n        <span class=\"hljs-keyword\">end</span>\n\n        <span class=\"hljs-comment\"># If the current block is not the last one, calculate the hash value for the next block</span>\n        <span class=\"hljs-keyword\">if</span> i &lt;= txt_len - ptn_len\n            t_hash = (d * (t_hash - text[i] * pow) + text[i+ptn_len]) % m_hash\n\n            <span class=\"hljs-keyword\">if</span> t_hash &lt; <span class=\"hljs-number\">0</span>\n                t_hash += m_hash\n            <span class=\"hljs-keyword\">end</span>\n        <span class=\"hljs-keyword\">end</span>\n    <span class=\"hljs-keyword\">end</span>\n\n    <span class=\"hljs-keyword\">return</span> indices\n<span class=\"hljs-keyword\">end</span>\n"
    },
    "c-sharp": {
      "dir": "./Algorithms/Strings/RabinKarp.cs",
      "url": "https:/github.com/TheAlgorithms/C-Sharp/tree/master/Algorithms/Strings/RabinKarp.cs",
      "code": "<span class=\"hljs-keyword\">using</span> System;\n<span class=\"hljs-keyword\">using</span> System.Collections.Generic;\n\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">Algorithms.Strings</span>\n{\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     The idea: You calculate the hash for the pattern <span class=\"hljs-doctag\">&lt;c&gt;</span>p<span class=\"hljs-doctag\">&lt;/c&gt;</span> and the hash values for all the prefixes of the text</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     <span class=\"hljs-doctag\">&lt;c&gt;</span>t<span class=\"hljs-doctag\">&lt;/c&gt;</span>.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Now, you can compare a substring in constant time using the calculated hashes.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     time complexity: O(p + t),</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     space complexity: O(t),</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     where   t - text length</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     p - pattern length.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">RabinKarp</span>\n    {\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Finds the index of all occurrences of the pattern <span class=\"hljs-doctag\">&lt;c&gt;</span>p<span class=\"hljs-doctag\">&lt;/c&gt;</span> int <span class=\"hljs-doctag\">&lt;c&gt;</span>t<span class=\"hljs-doctag\">&lt;/c&gt;</span>.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>List of starting indices of the pattern in the text.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> List&lt;<span class=\"hljs-built_in\">int</span>&gt; <span class=\"hljs-title\">FindAllOccurrences</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">string</span> text, <span class=\"hljs-built_in\">string</span> pattern</span>)</span>\n        {\n            <span class=\"hljs-comment\">// Prime number</span>\n            <span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">ulong</span> p = <span class=\"hljs-number\">65537</span>;\n\n            <span class=\"hljs-comment\">// Modulo coefficient</span>\n            <span class=\"hljs-keyword\">const</span> <span class=\"hljs-built_in\">ulong</span> m = (<span class=\"hljs-built_in\">ulong</span>)<span class=\"hljs-number\">1e9</span> + <span class=\"hljs-number\">7</span>;\n\n            <span class=\"hljs-comment\">// p_pow[i] = P^i mod M</span>\n            <span class=\"hljs-built_in\">ulong</span>[] pPow = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ulong</span>[Math.Max(pattern.Length, text.Length)];\n            pPow[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">1</span>;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">1</span>; i &lt; pPow.Length; i++)\n            {\n                pPow[i] = pPow[i - <span class=\"hljs-number\">1</span>] * p % m;\n            }\n\n            <span class=\"hljs-comment\">// hash_t[i] is the sum of the previous hash values of the letters (t[0], t[1], ..., t[i-1]) and the hash value of t[i] itself (mod M).</span>\n            <span class=\"hljs-comment\">// The hash value of a letter t[i] is equal to the product of t[i] and p_pow[i] (mod M).</span>\n            <span class=\"hljs-built_in\">ulong</span>[] hashT = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">ulong</span>[text.Length + <span class=\"hljs-number\">1</span>];\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; text.Length; i++)\n            {\n                hashT[i + <span class=\"hljs-number\">1</span>] = (hashT[i] + text[i] * pPow[i]) % m;\n            }\n\n            <span class=\"hljs-comment\">// hash_s is equal to sum of the hash values of the pattern (mod M).</span>\n            <span class=\"hljs-built_in\">ulong</span> hashS = <span class=\"hljs-number\">0</span>;\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i &lt; pattern.Length; i++)\n            {\n                hashS = (hashS + pattern[i] * pPow[i]) % m;\n            }\n\n            <span class=\"hljs-comment\">// In the next step you iterate over the text with the pattern.</span>\n            List&lt;<span class=\"hljs-built_in\">int</span>&gt; occurrences = <span class=\"hljs-keyword\">new</span>();\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = <span class=\"hljs-number\">0</span>; i + pattern.Length - <span class=\"hljs-number\">1</span> &lt; text.Length; i++)\n            {\n                <span class=\"hljs-comment\">// In each step you calculate the hash value of the substring to be tested.</span>\n                <span class=\"hljs-comment\">// By storing the hash values of the letters as a prefixes you can do this in constant time.</span>\n                <span class=\"hljs-keyword\">var</span> currentHash = (hashT[i + pattern.Length] + m - hashT[i]) % m;\n\n                <span class=\"hljs-comment\">// Now you can compare the hash value of the substring with the product of the hash value of the pattern and p_pow[i].</span>\n                <span class=\"hljs-keyword\">if</span> (currentHash == hashS * pPow[i] % m)\n                {\n                    <span class=\"hljs-comment\">// If the hash values are identical, do a double-check in case a hash collision occurs.</span>\n                    <span class=\"hljs-keyword\">var</span> j = <span class=\"hljs-number\">0</span>;\n                    <span class=\"hljs-keyword\">while</span> (j &lt; pattern.Length &amp;&amp; text[i + j] == pattern[j])\n                    {\n                        ++j;\n                    }\n\n                    <span class=\"hljs-keyword\">if</span> (j == pattern.Length)\n                    {\n                        <span class=\"hljs-comment\">// If the hash values are identical and the double-check passes, a substring was found that matches the pattern.</span>\n                        <span class=\"hljs-comment\">// In this case you add the index i to the list of occurences.</span>\n                        occurrences.Add(i);\n                    }\n                }\n            }\n\n            <span class=\"hljs-keyword\">return</span> occurrences;\n        }\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 1
    },
    {
      "name": "YANG Wenqiang",
      "email": "70672970+wq-yang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "kevinburchfield",
      "email": "kevinburchfi@gmail.com",
      "commits": 1
    },
    {
      "name": "Nikola Mircic",
      "email": "nikola123mircic@gmail.com",
      "commits": 1
    },
    {
      "name": "Ihjass Thasbekha",
      "email": "44056715+Ihjass@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Antony",
      "email": "45163503+DuckNrOne@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Amit Kumar",
      "email": "offamitkumar@gmail.com",
      "commits": 1
    },
    {
      "name": "Prateek Kumar Oraon",
      "email": "b170078@nitsikkim.ac.in",
      "commits": 1
    },
    {
      "name": "Hector S",
      "email": "hfsam88@gmail.com",
      "commits": 1
    },
    {
      "name": "Nolan Emirot",
      "email": "emirot.nolan@gmail.com",
      "commits": 1
    },
    {
      "name": "Dmytro Litvinov",
      "email": "litvinov.dmytro.it@gmail.com",
      "commits": 1
    },
    {
      "name": "Md. Mahbubur Rahman",
      "email": "mahbuburrahman2111@gmail.com",
      "commits": 1
    },
    {
      "name": "damelLP",
      "email": "dlambertpowell@gmail.com",
      "commits": 1
    },
    {
      "name": "Andrii Siriak",
      "email": "siryaka@gmail.com",
      "commits": 2
    },
    {
      "name": "Aitor Fidalgo Sánchez",
      "email": "64830228+aitorfi@users.noreply.github.com",
      "commits": 2
    },
    {
      "name": "Allister Isaiah Harvey",
      "email": "41553768+powpow58@users.noreply.github.com",
      "commits": 5
    }
  ],
  "explanationUrl": {}
}