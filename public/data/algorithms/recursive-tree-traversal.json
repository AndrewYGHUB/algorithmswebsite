{
  "slug": "recursive-tree-traversal",
  "name": "Recursive Tree Traversal",
  "categories": [
    "others"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "others/recursive_tree_traversal.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/others/recursive_tree_traversal.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @brief Recursive version of Inorder, Preorder, and Postorder [Traversal of\n * the Tree] (https://en.wikipedia.org/wiki/Tree_traversal)\n *\n * @details\n *\n * ### Iterative Inorder Traversal of a tree\n * For traversing a (non-empty) binary tree in an inorder fashion, we must do\n * these three things for every node n starting from the tree’s root:\n *\n * (L) Recursively traverse its left subtree. When this step is finished,\n * we are back at n again.\n * (N) Process n itself.\n * (R) Recursively traverse its right subtree. When this step is finished,\n * we are back at n again.\n *\n * In normal inorder traversal, we visit the left subtree before the right\n * subtree. If we visit the right subtree before visiting the left subtree, it\n * is referred to as reverse inorder traversal.\n *\n * ### Iterative Preorder Traversal of a tree\n * For traversing a (non-empty) binary tree in a preorder fashion, we must do\n * these three things for every node n starting from the tree’s root:\n *\n * (N) Process n itself.\n * (L) Recursively traverse its left subtree. When this step is finished,\n * we are back at n again.\n * (R) Recursively traverse its right subtree. When this step is finished,\n * we are back at n again.\n *\n * In normal preorder traversal, visit the left subtree before the right\n * subtree. If we visit the right subtree before visiting the left subtree, it\n * is referred to as reverse preorder traversal.\n *\n * ### Iterative Postorder Traversal of a tree\n * For traversing a (non-empty) binary tree in a postorder fashion, we must do\n * these three things for every node n starting from the tree’s root:\n *\n * (L) Recursively traverse its left subtree. When this step is finished,\n * we are back at n again.\n * (R) Recursively traverse its right subtree. When this step is finished,\n * we are back at n again.\n * (N) Process n itself.\n *\n * In normal postorder traversal, visit the left subtree before the right\n * subtree. If we visit the right subtree before visiting the left subtree, it\n * is referred to as reverse postorder traversal.\n *\n * @author [Lajat Manekar](https://github.com/Lazeeez)\n *\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>   <span class=\"hljs-comment\">/// for assert</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">/// for I/O operations</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>    <span class=\"hljs-comment\">/// for vector</span></span>\n\n<span class=\"hljs-comment\">/**\n * @namespace others\n * @brief Other algorithms\n */</span>\n<span class=\"hljs-keyword\">namespace</span> others {\n\n<span class=\"hljs-comment\">/**\n * @namespace interpolation_search\n * @brief Functions for the Recursive version of Inorder, Preorder, and\n * Postorder [Traversal of the\n * Tree](https://en.wikipedia.org/wiki/Tree_traversal) algorithm implementation\n */</span>\n<span class=\"hljs-keyword\">namespace</span> recursive_tree_traversals {\n\n<span class=\"hljs-comment\">/**\n * @brief The structure to hold Nodes of the tree.\n * @param data Value that will be stored in the node.\n * @param left follow up left subtree.\n * @param right follow up right subtree.\n */</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> {\n    <span class=\"hljs-type\">uint64_t</span> data = <span class=\"hljs-number\">0</span>;     <span class=\"hljs-comment\">///&lt; The value/key of the node.</span>\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> *left{};   <span class=\"hljs-comment\">///&lt; struct pointer to left subtree.</span>\n    <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> *right{};  <span class=\"hljs-comment\">///&lt; struct pointer to right subtree.</span>\n};\n<span class=\"hljs-comment\">/**\n * @brief BT used to make the entire structure of the binary tree and the\n * functions associated with the binary tree\n */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BT</span> {\n <span class=\"hljs-keyword\">public</span>:\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt;\n        inorder_result;  <span class=\"hljs-comment\">// vector to store the inorder traversal of the tree.</span>\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt;\n        preorder_result;  <span class=\"hljs-comment\">// vector to store the preorder traversal of the tree.</span>\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; postorder_result;  <span class=\"hljs-comment\">// vector to store the preorder</span>\n                                             <span class=\"hljs-comment\">// traversal of the tree.</span>\n\n    <span class=\"hljs-function\">Node *<span class=\"hljs-title\">createNewNode</span><span class=\"hljs-params\">(\n        <span class=\"hljs-type\">uint64_t</span>)</span></span>;  <span class=\"hljs-comment\">// function that will create new node for insertion.</span>\n\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; <span class=\"hljs-title\">inorder</span><span class=\"hljs-params\">(\n        Node *)</span></span>;  <span class=\"hljs-comment\">// function that takes root of the tree as an argument and</span>\n                  <span class=\"hljs-comment\">// returns its inorder traversal.</span>\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; <span class=\"hljs-title\">preorder</span><span class=\"hljs-params\">(\n        Node *)</span></span>;  <span class=\"hljs-comment\">// function that takes root of the tree as an argument and</span>\n                  <span class=\"hljs-comment\">// returns its preorder traversal.</span>\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; <span class=\"hljs-title\">postorder</span><span class=\"hljs-params\">(\n        Node *)</span></span>;  <span class=\"hljs-comment\">// function that takes root of the tree as an argument and</span>\n                  <span class=\"hljs-comment\">// returns its postorder traversal.</span>\n};\n\n<span class=\"hljs-comment\">/**\n * @brief will allocate the memory for a node and, along the data and return the\n * node.\n * @param data value that a particular node will contain.\n * @return pointer to the newly created node with assigned data.\n */</span>\n<span class=\"hljs-function\">Node *<span class=\"hljs-title\">BT::createNewNode</span><span class=\"hljs-params\">(<span class=\"hljs-type\">uint64_t</span> data)</span> </span>{\n    Node *node = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>();\n    node-&gt;data = data;\n    node-&gt;left = node-&gt;right = <span class=\"hljs-literal\">nullptr</span>;\n    <span class=\"hljs-keyword\">return</span> node;\n}\n\n<span class=\"hljs-comment\">/*\n * @brief inorder() function that will perform the inorder traversal\n * recursively, and return the resultant vector that contain the inorder\n * traversal of a tree.\n * @param root head/root node of a tree\n * @return result that is containing the inorder traversal of a tree\n **/</span>\n<span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; <span class=\"hljs-title\">BT::inorder</span><span class=\"hljs-params\">(Node *root)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>) {  <span class=\"hljs-comment\">// return if the current node is empty</span>\n        <span class=\"hljs-keyword\">return</span> {};\n    }\n\n    <span class=\"hljs-built_in\">inorder</span>(root-&gt;left);  <span class=\"hljs-comment\">// Traverse the left subtree</span>\n    BT::inorder_result.<span class=\"hljs-built_in\">push_back</span>(\n        root-&gt;data);  <span class=\"hljs-comment\">// Display the data part of the root (or current node)</span>\n    <span class=\"hljs-built_in\">inorder</span>(root-&gt;right);  <span class=\"hljs-comment\">// Traverse the right subtree</span>\n\n    <span class=\"hljs-keyword\">return</span> inorder_result;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief preorder function that will perform the preorder traversal\n * recursively, and return the resultant vector that contain the preorder\n * traversal of a tree.\n * @param root head/root node of a tree\n * @return result that is containing the preorder traversal of a tree\n */</span>\n<span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; <span class=\"hljs-title\">BT::preorder</span><span class=\"hljs-params\">(Node *root)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>) {  <span class=\"hljs-comment\">// if the current node is empty</span>\n        <span class=\"hljs-keyword\">return</span> {};\n    }\n\n    BT::preorder_result.<span class=\"hljs-built_in\">push_back</span>(\n        root-&gt;data);  <span class=\"hljs-comment\">// Display the data part of the root (or current node)</span>\n    <span class=\"hljs-built_in\">preorder</span>(root-&gt;left);   <span class=\"hljs-comment\">// Traverse the left subtree</span>\n    <span class=\"hljs-built_in\">preorder</span>(root-&gt;right);  <span class=\"hljs-comment\">// Traverse the right subtree</span>\n\n    <span class=\"hljs-keyword\">return</span> preorder_result;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief postorder function that will perform the postorder traversal\n * recursively, and return the result vector that contain the postorder\n * traversal of a tree.\n * @param root head/root node of a tree\n * @return result that is containing the postorder traversal of a tree\n */</span>\n<span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; <span class=\"hljs-title\">BT::postorder</span><span class=\"hljs-params\">(Node *root)</span> </span>{\n    <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>) {  <span class=\"hljs-comment\">// if the current node is empty</span>\n        <span class=\"hljs-keyword\">return</span> {};\n    }\n\n    <span class=\"hljs-built_in\">postorder</span>(root-&gt;left);   <span class=\"hljs-comment\">// Traverse the left subtree</span>\n    <span class=\"hljs-built_in\">postorder</span>(root-&gt;right);  <span class=\"hljs-comment\">// Traverse the right subtree</span>\n    BT::postorder_result.<span class=\"hljs-built_in\">push_back</span>(\n        root-&gt;data);  <span class=\"hljs-comment\">// Display the data part of the root (or current node)</span>\n\n    <span class=\"hljs-keyword\">return</span> postorder_result;\n}\n\n}  <span class=\"hljs-comment\">// namespace recursive_tree_traversals</span>\n\n}  <span class=\"hljs-comment\">// namespace others</span>\n\n<span class=\"hljs-comment\">/**\n * @brief 1st test-case\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">()</span> </span>{\n    others::recursive_tree_traversals::BT obj1;\n    others::recursive_tree_traversals::Node *root = obj1.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">2</span>);\n    root-&gt;left = obj1.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">7</span>);\n    root-&gt;right = obj1.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">5</span>);\n    root-&gt;left-&gt;left = obj1.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">2</span>);\n    root-&gt;left-&gt;right = obj1.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">6</span>);\n    root-&gt;right-&gt;right = obj1.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">9</span>);\n    root-&gt;left-&gt;right-&gt;left = obj1.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">5</span>);\n    root-&gt;left-&gt;right-&gt;right = obj1.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">11</span>);\n    root-&gt;right-&gt;right-&gt;left = obj1.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">4</span>);\n\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; actual_result_inorder{<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">9</span>};\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; actual_result_preorder{<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">4</span>};\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; actual_result_postorder{<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>};\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; result_inorder;    <span class=\"hljs-comment\">///&lt; result stores the inorder</span>\n                                             <span class=\"hljs-comment\">///&lt; traversal of the binary tree</span>\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; result_preorder;   <span class=\"hljs-comment\">///&lt; result stores the preorder</span>\n                                             <span class=\"hljs-comment\">///&lt; traversal of the binary tree</span>\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; result_postorder;  <span class=\"hljs-comment\">///&lt; result stores the postorder</span>\n                                             <span class=\"hljs-comment\">///&lt; traversal of the binary tree</span>\n\n    <span class=\"hljs-type\">uint64_t</span> size = actual_result_inorder.<span class=\"hljs-built_in\">size</span>();\n\n    <span class=\"hljs-comment\">// Calling inorder() function by passing a root node,</span>\n    <span class=\"hljs-comment\">// and storing the inorder traversal in result_inorder.</span>\n    result_inorder = obj1.<span class=\"hljs-built_in\">inorder</span>(root);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testcase #1: Inorder Traversal...&quot;</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; ++i) {\n        <span class=\"hljs-built_in\">assert</span>(actual_result_inorder[i] == result_inorder[i]);\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Passed!&quot;</span> &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">// Calling preorder() function by passing a root node,</span>\n    <span class=\"hljs-comment\">// and storing the preorder traversal in result_preorder.</span>\n    result_preorder = obj1.<span class=\"hljs-built_in\">preorder</span>(root);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testcase #1: Preorder Traversal...&quot;</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; ++i) {\n        <span class=\"hljs-built_in\">assert</span>(actual_result_preorder[i] == result_preorder[i]);\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Passed!&quot;</span> &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">// Calling postorder() function by passing a root node,</span>\n    <span class=\"hljs-comment\">// and storing the postorder traversal in result_postorder.</span>\n    result_postorder = obj1.<span class=\"hljs-built_in\">postorder</span>(root);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testcase #1: Postorder Traversal...&quot;</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; ++i) {\n        <span class=\"hljs-built_in\">assert</span>(actual_result_postorder[i] == result_postorder[i]);\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Passed!&quot;</span> &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief 2nd test-case\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">()</span> </span>{\n    others::recursive_tree_traversals::BT obj2;\n    others::recursive_tree_traversals::Node *root = obj2.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">1</span>);\n    root-&gt;left = obj2.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">2</span>);\n    root-&gt;right = obj2.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">3</span>);\n    root-&gt;left-&gt;left = obj2.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">4</span>);\n    root-&gt;right-&gt;left = obj2.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">5</span>);\n    root-&gt;right-&gt;right = obj2.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">6</span>);\n    root-&gt;right-&gt;left-&gt;left = obj2.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">7</span>);\n    root-&gt;right-&gt;left-&gt;right = obj2.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">8</span>);\n\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; actual_result_inorder{<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>};\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; actual_result_preorder{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>};\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; actual_result_postorder{<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>};\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; result_inorder;    <span class=\"hljs-comment\">///&lt; result stores the inorder</span>\n                                             <span class=\"hljs-comment\">///&lt; traversal of the binary tree</span>\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; result_preorder;   <span class=\"hljs-comment\">///&lt; result stores the preorder</span>\n                                             <span class=\"hljs-comment\">///&lt; traversal of the binary tree</span>\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; result_postorder;  <span class=\"hljs-comment\">///&lt; result stores the postorder</span>\n                                             <span class=\"hljs-comment\">///&lt; traversal of the binary tree</span>\n\n    <span class=\"hljs-type\">uint64_t</span> size = actual_result_inorder.<span class=\"hljs-built_in\">size</span>();\n\n    <span class=\"hljs-comment\">// Calling inorder() function by passing a root node,</span>\n    <span class=\"hljs-comment\">// and storing the inorder traversal in result_inorder.</span>\n    result_inorder = obj2.<span class=\"hljs-built_in\">inorder</span>(root);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testcase #2: Inorder Traversal...&quot;</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; ++i) {\n        <span class=\"hljs-built_in\">assert</span>(actual_result_inorder[i] == result_inorder[i]);\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Passed!&quot;</span> &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">// Calling preorder() function by passing a root node,</span>\n    <span class=\"hljs-comment\">// and storing the preorder traversal in result_preorder.</span>\n    result_preorder = obj2.<span class=\"hljs-built_in\">preorder</span>(root);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testcase #2: Preorder Traversal...&quot;</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; ++i) {\n        <span class=\"hljs-built_in\">assert</span>(actual_result_preorder[i] == result_preorder[i]);\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Passed!&quot;</span> &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">// Calling postorder() function by passing a root node,</span>\n    <span class=\"hljs-comment\">// and storing the postorder traversal in result_postorder.</span>\n    result_postorder = obj2.<span class=\"hljs-built_in\">postorder</span>(root);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testcase #2: Postorder Traversal...&quot;</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; ++i) {\n        <span class=\"hljs-built_in\">assert</span>(actual_result_postorder[i] == result_postorder[i]);\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Passed!&quot;</span> &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief 3rd test-case\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test3</span><span class=\"hljs-params\">()</span> </span>{\n    others::recursive_tree_traversals::BT obj3;\n    others::recursive_tree_traversals::Node *root = obj3.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">1</span>);\n    root-&gt;left = obj3.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">2</span>);\n    root-&gt;right = obj3.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">3</span>);\n    root-&gt;left-&gt;left = obj3.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">4</span>);\n    root-&gt;left-&gt;right = obj3.<span class=\"hljs-built_in\">createNewNode</span>(<span class=\"hljs-number\">5</span>);\n\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; actual_result_inorder{<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>};\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; actual_result_preorder{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">3</span>};\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; actual_result_postorder{<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>};\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; result_inorder;    <span class=\"hljs-comment\">///&lt; result stores the inorder</span>\n                                             <span class=\"hljs-comment\">///&lt; traversal of the binary tree</span>\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; result_preorder;   <span class=\"hljs-comment\">///&lt; result stores the preorder</span>\n                                             <span class=\"hljs-comment\">///&lt; traversal of the binary tree</span>\n    std::vector&lt;<span class=\"hljs-type\">uint64_t</span>&gt; result_postorder;  <span class=\"hljs-comment\">///&lt; result stores the postorder</span>\n                                             <span class=\"hljs-comment\">///&lt; traversal of the binary tree</span>\n\n    <span class=\"hljs-type\">uint64_t</span> size = actual_result_inorder.<span class=\"hljs-built_in\">size</span>();\n\n    <span class=\"hljs-comment\">// Calling inorder() function by passing a root node,</span>\n    <span class=\"hljs-comment\">// and storing the inorder traversal in result_inorder.</span>\n\n    result_inorder = obj3.<span class=\"hljs-built_in\">inorder</span>(root);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testcase #3: Inorder Traversal...&quot;</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; ++i) {\n        <span class=\"hljs-built_in\">assert</span>(actual_result_inorder[i] == result_inorder[i]);\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Passed!&quot;</span> &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">// Calling preorder() function by passing a root node,</span>\n    <span class=\"hljs-comment\">// and storing the preorder traversal in result_preorder.</span>\n    result_preorder = obj3.<span class=\"hljs-built_in\">preorder</span>(root);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testcase #3: Preorder Traversal...&quot;</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; ++i) {\n        <span class=\"hljs-built_in\">assert</span>(actual_result_preorder[i] == result_preorder[i]);\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Passed!&quot;</span> &lt;&lt; std::endl;\n\n    <span class=\"hljs-comment\">// Calling postorder() function by passing a root node,</span>\n    <span class=\"hljs-comment\">// and storing the postorder traversal in result_postorder.</span>\n    result_postorder = obj3.<span class=\"hljs-built_in\">postorder</span>(root);\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Testcase #3: Postorder Traversal...&quot;</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> i = <span class=\"hljs-number\">0</span>; i &lt; size; ++i) {\n        <span class=\"hljs-built_in\">assert</span>(actual_result_postorder[i] == result_postorder[i]);\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Passed!&quot;</span> &lt;&lt; std::endl;\n\n    std::cout &lt;&lt; std::endl;\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Self-test implementations\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">tests</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;1st test-case&quot;</span> &lt;&lt; std::endl;\n    <span class=\"hljs-built_in\">test1</span>();  <span class=\"hljs-comment\">// run 1st test-case</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;2nd test-case&quot;</span> &lt;&lt; std::endl;\n    <span class=\"hljs-built_in\">test2</span>();  <span class=\"hljs-comment\">// run 2nd test-case</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;3rd test-case&quot;</span> &lt;&lt; std::endl;\n    <span class=\"hljs-built_in\">test3</span>();  <span class=\"hljs-comment\">// run 3rd test-case</span>\n}\n<span class=\"hljs-comment\">/**\n * @brief Main function\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">tests</span>();  <span class=\"hljs-comment\">// run self-test implementations</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Lajat5",
      "email": "64376519+Lazeeez@users.noreply.github.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}