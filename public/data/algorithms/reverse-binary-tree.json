{
  "slug": "reverse-binary-tree",
  "name": "Reverse Binary Tree",
  "categories": [
    "operationsondatastructures"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "operations_on_datastructures/reverse_binary_tree.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/operations_on_datastructures/reverse_binary_tree.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @brief Implementation for the [Reversing a Binary\n * Tree](https://www.geeksforgeeks.org/reverse-tree-path/) recursively\n * algorithm.\n * @details A binary tree can be reversed by swapping the left and\n * right child of a node at each node, starting from the root, and\n * cascading below. This solution aims to provide an implementation of\n * a recursive reversal of a binary tree.\n * @author [Alvin](https://github.com/polarvoid)\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>   <span class=\"hljs-comment\">/// For assert</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>  <span class=\"hljs-comment\">/// For IO operations</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;queue&gt;</span>     <span class=\"hljs-comment\">/// For std::queue</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>    <span class=\"hljs-comment\">/// For std::vector</span></span>\n\n<span class=\"hljs-comment\">/**\n * @namespace operations_on_datastructures\n * @brief Operations on Data Structures\n */</span>\n<span class=\"hljs-keyword\">namespace</span> operations_on_datastructures {\n\n<span class=\"hljs-comment\">/**\n * @namespace reverse_binary_tree\n * @brief Functions for the [Reverse a Binary\n * Tree](https://www.geeksforgeeks.org/reverse-tree-path/) implementation\n */</span>\n<span class=\"hljs-keyword\">namespace</span> reverse_binary_tree {\n\n<span class=\"hljs-comment\">/**\n * @brief A Node struct that represents a single node in a Binary Tree\n */</span>\n<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">Node</span> {\n    <span class=\"hljs-type\">int64_t</span> data;  <span class=\"hljs-comment\">///&lt; The value of the Node</span>\n    Node* left;    <span class=\"hljs-comment\">///&lt; The Node&#x27;s left child</span>\n    Node* right;   <span class=\"hljs-comment\">///&lt; The Node&#x27;s right child</span>\n    <span class=\"hljs-comment\">/**\n     * @brief Creates a new Node with some initial data\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">Node</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> _data)</span> </span>{\n        data = _data;     <span class=\"hljs-comment\">///&lt; Set value of Node data</span>\n        left = <span class=\"hljs-literal\">nullptr</span>;   <span class=\"hljs-comment\">///&lt; Initialize left child to NULL</span>\n        right = <span class=\"hljs-literal\">nullptr</span>;  <span class=\"hljs-comment\">///&lt; Initialize right child to NULL</span>\n    }\n};\n\n<span class=\"hljs-comment\">/**\n * @brief A Binary Tree class that implements a Binary Search Tree\n *(BST) by default.\n */</span>\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BinaryTree</span> {\n <span class=\"hljs-keyword\">private</span>:\n    Node* root;  <span class=\"hljs-comment\">///&lt; Pointer to root node of Binary Tree</span>\n    <span class=\"hljs-comment\">/**\n     * @brief inserts a node in the Binary Tree, with the behaviouur of\n     * a Binary Search Tree.\n     * @details Nodes with smaller values are inserted in the left\n     * subtree, and Nodes with larger values are inserted into the\n     * right subtree recursively. Time Complexity: O(log(n))\n     * @param data The data/value of the Node to be inserted\n     * @param pivot A pointer to the root node of the (sub)tree\n     * @returns Node pointer to the root\n     */</span>\n    <span class=\"hljs-function\">Node* <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> data, Node* pivot)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (pivot == <span class=\"hljs-literal\">nullptr</span>) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(data);  <span class=\"hljs-comment\">///&lt; Create new node</span>\n        }\n        <span class=\"hljs-keyword\">if</span> (data &lt;= pivot-&gt;data) {\n            pivot-&gt;left =\n                <span class=\"hljs-built_in\">insert</span>(data, pivot-&gt;left);  <span class=\"hljs-comment\">///&lt; Insert Node to the left</span>\n        } <span class=\"hljs-keyword\">else</span> {\n            pivot-&gt;right =\n                <span class=\"hljs-built_in\">insert</span>(data, pivot-&gt;right);  <span class=\"hljs-comment\">///&lt; Insert node to the right</span>\n        }\n        <span class=\"hljs-keyword\">return</span> pivot;\n    }\n    <span class=\"hljs-comment\">/**\n     * @brief Reverses a Binary Tree recursively by swapping the left and\n     * right subtrees and their children.\n     * @param pivot A reference to the root of the (sub)tree\n     * @returns Node pointer to root node\n     */</span>\n    <span class=\"hljs-function\">Node* <span class=\"hljs-title\">reverseBinaryTree</span><span class=\"hljs-params\">(Node* pivot)</span> </span>{\n        <span class=\"hljs-keyword\">if</span> (pivot == <span class=\"hljs-literal\">nullptr</span>) {\n            <span class=\"hljs-keyword\">return</span> pivot;  <span class=\"hljs-comment\">///&lt; Base case</span>\n        }\n        Node* temp = pivot-&gt;left;  <span class=\"hljs-comment\">///&lt; pointer to the left subtree</span>\n        pivot-&gt;left = <span class=\"hljs-built_in\">reverseBinaryTree</span>(pivot-&gt;right);  <span class=\"hljs-comment\">///&lt; Swap</span>\n        pivot-&gt;right = <span class=\"hljs-built_in\">reverseBinaryTree</span>(temp);         <span class=\"hljs-comment\">///&lt; Swap</span>\n        <span class=\"hljs-keyword\">return</span> pivot;\n    }\n\n <span class=\"hljs-keyword\">public</span>:\n    <span class=\"hljs-comment\">/**\n     * @brief Creates a BinaryTree with a root pointing to NULL.\n     */</span>\n    <span class=\"hljs-built_in\">BinaryTree</span>() { root = <span class=\"hljs-literal\">nullptr</span>; }\n    <span class=\"hljs-comment\">/**\n     * @brief Creates a BinaryTree with a root with an initial value.\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">explicit</span> <span class=\"hljs-title\">BinaryTree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> data)</span> </span>{ root = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Node</span>(data); }\n    <span class=\"hljs-comment\">/**\n     * @brief Adds a new Node to the Binary Tree\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int64_t</span> data)</span> </span>{ root = <span class=\"hljs-built_in\">insert</span>(data, root); }\n    <span class=\"hljs-comment\">/**\n     * Reverses the Binary Tree\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">reverse</span><span class=\"hljs-params\">()</span> </span>{ root = <span class=\"hljs-built_in\">reverseBinaryTree</span>(root); }\n    <span class=\"hljs-comment\">/**\n     * @brief Level order traversal of a tree consists of visiting its\n     * elements, top to bottom, left to right. This function performs\n     * level order traversal and returns the node datas as a vector.\n     * @details The function uses a queue to append and remove elements\n     * as they are visited, and then adds their children, if any. This\n     * ensures that the elements are visited layer-by-layer, starting\n     * from the root of the Tree.\n     * @returns vector&lt;int64_t&gt; of nodes of the tree.\n     */</span>\n    <span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; <span class=\"hljs-title\">get_level_order</span><span class=\"hljs-params\">()</span> </span>{\n        std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; data;  <span class=\"hljs-comment\">///&lt; Result vector of int</span>\n        <span class=\"hljs-keyword\">if</span> (root == <span class=\"hljs-literal\">nullptr</span>) {\n            <span class=\"hljs-keyword\">return</span> data;  <span class=\"hljs-comment\">///&lt; Return empty vector if root is Invalid</span>\n        }\n        std::queue&lt;Node*&gt; nodes;  <span class=\"hljs-comment\">///&lt; Queue of the nodes in the tree</span>\n        nodes.<span class=\"hljs-built_in\">push</span>(root);         <span class=\"hljs-comment\">///&lt; Insert root into the queue</span>\n        <span class=\"hljs-keyword\">while</span> (!nodes.<span class=\"hljs-built_in\">empty</span>()) {\n            Node* temp = nodes.<span class=\"hljs-built_in\">front</span>();  <span class=\"hljs-comment\">///&lt; Copy the first element</span>\n            data.<span class=\"hljs-built_in\">push_back</span>(temp-&gt;data);  <span class=\"hljs-comment\">///&lt; Add the element to the data</span>\n            nodes.<span class=\"hljs-built_in\">pop</span>();                 <span class=\"hljs-comment\">///&lt; Remove element</span>\n            <span class=\"hljs-keyword\">if</span> (temp-&gt;left != <span class=\"hljs-literal\">nullptr</span>) {\n                nodes.<span class=\"hljs-built_in\">push</span>(temp-&gt;left);  <span class=\"hljs-comment\">///&lt; Insert left node</span>\n            }\n            <span class=\"hljs-keyword\">if</span> (temp-&gt;right != <span class=\"hljs-literal\">nullptr</span>) {\n                nodes.<span class=\"hljs-built_in\">push</span>(temp-&gt;right);  <span class=\"hljs-comment\">///&lt; Insert right node</span>\n            }\n        }  <span class=\"hljs-comment\">/// Add nodes while Tree is not empty</span>\n        <span class=\"hljs-keyword\">return</span> data;\n    }\n    <span class=\"hljs-comment\">/**\n     * @brief Prints all of the elements in the tree to stdout\n     * level-by-level, using the get_level_order() function.\n     * @returns void\n     */</span>\n    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i : <span class=\"hljs-built_in\">get_level_order</span>()) {\n            std::cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;  <span class=\"hljs-comment\">/// Print each element in the tree</span>\n        }\n        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;  <span class=\"hljs-comment\">/// Print newline</span>\n    }\n};\n\n}  <span class=\"hljs-comment\">// namespace reverse_binary_tree</span>\n}  <span class=\"hljs-comment\">// namespace operations_on_datastructures</span>\n\n<span class=\"hljs-comment\">/**\n * @namespace tests\n * @brief Testcases to check Reversal of Binary Tree.\n */</span>\n<span class=\"hljs-keyword\">namespace</span> tests {\n<span class=\"hljs-keyword\">using</span> operations_on_datastructures::reverse_binary_tree::\n    BinaryTree;  <span class=\"hljs-comment\">///&lt; Use the BinaryTree</span>\n<span class=\"hljs-comment\">/**\n * @brief A Test to check an edge case (single element reversal)\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">()</span> </span>{\n    BinaryTree bst;\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; pre_reversal, post_reversal;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST CASE 1\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Initializing tree with a single element (5)\\n&quot;</span>;\n    bst.<span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">5</span>);\n    pre_reversal = bst.<span class=\"hljs-built_in\">get_level_order</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Before reversal: &quot;</span>;\n    bst.<span class=\"hljs-built_in\">print</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;After reversal: &quot;</span>;\n    bst.<span class=\"hljs-built_in\">reverse</span>();\n    post_reversal = bst.<span class=\"hljs-built_in\">get_level_order</span>();\n    <span class=\"hljs-built_in\">assert</span>(pre_reversal.<span class=\"hljs-built_in\">size</span>() ==\n           post_reversal.<span class=\"hljs-built_in\">size</span>());  <span class=\"hljs-comment\">///&lt; Check for equal sizes</span>\n    <span class=\"hljs-built_in\">assert</span>(pre_reversal.<span class=\"hljs-built_in\">size</span>() ==\n           <span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">///&lt; Ensure that there is only one element</span>\n    <span class=\"hljs-built_in\">assert</span>(pre_reversal[<span class=\"hljs-number\">0</span>] ==\n           post_reversal[<span class=\"hljs-number\">0</span>]);  <span class=\"hljs-comment\">///&lt; Check if both elements are same</span>\n    bst.<span class=\"hljs-built_in\">print</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST PASSED!\\n\\n&quot;</span>;\n}\n<span class=\"hljs-comment\">/**\n * @brief A Test to check an edge case (NULL root element)\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">()</span> </span>{\n    BinaryTree bst;\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; pre_reversal, post_reversal;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST CASE 2\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Creating empty tree (root points to NULL)\\n&quot;</span>;\n    pre_reversal = bst.<span class=\"hljs-built_in\">get_level_order</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Before reversal: &quot;</span>;\n    bst.<span class=\"hljs-built_in\">print</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;After reversal: &quot;</span>;\n    bst.<span class=\"hljs-built_in\">reverse</span>();\n    post_reversal = bst.<span class=\"hljs-built_in\">get_level_order</span>();\n    <span class=\"hljs-built_in\">assert</span>(pre_reversal.<span class=\"hljs-built_in\">size</span>() ==\n           post_reversal.<span class=\"hljs-built_in\">size</span>());  <span class=\"hljs-comment\">///&lt; Check for equal sizes</span>\n    <span class=\"hljs-built_in\">assert</span>(pre_reversal.<span class=\"hljs-built_in\">size</span>() ==\n           <span class=\"hljs-number\">0</span>);  <span class=\"hljs-comment\">///&lt; Ensure that there is only one element</span>\n    bst.<span class=\"hljs-built_in\">print</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST PASSED!\\n\\n&quot;</span>;\n}\n<span class=\"hljs-comment\">/**\n * @brief A Test to check correct reversal of a Binary Tree\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test3</span><span class=\"hljs-params\">()</span> </span>{\n    BinaryTree bst;\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; pre_reversal, post_reversal;\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; pre_res = {<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">1</span>};\n    std::vector&lt;<span class=\"hljs-type\">int64_t</span>&gt; post_res = {<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>};\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST CASE 3\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Creating tree with elements (4, 6, 3, 2, 5, 7, 1)\\n&quot;</span>;\n    bst.<span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">4</span>);\n    bst.<span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">6</span>);\n    bst.<span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">3</span>);\n    bst.<span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">2</span>);\n    bst.<span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">5</span>);\n    bst.<span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">7</span>);\n    bst.<span class=\"hljs-built_in\">add</span>(<span class=\"hljs-number\">1</span>);\n    pre_reversal = bst.<span class=\"hljs-built_in\">get_level_order</span>();\n    <span class=\"hljs-built_in\">assert</span>(pre_reversal == pre_res);  <span class=\"hljs-comment\">///&lt; Check for equality</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Before reversal: &quot;</span>;\n    bst.<span class=\"hljs-built_in\">print</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;After reversal: &quot;</span>;\n    bst.<span class=\"hljs-built_in\">reverse</span>();\n    post_reversal = bst.<span class=\"hljs-built_in\">get_level_order</span>();\n    <span class=\"hljs-built_in\">assert</span>(post_reversal == post_res);  <span class=\"hljs-comment\">///&lt; Check for equality</span>\n    bst.<span class=\"hljs-built_in\">print</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST PASSED!\\n\\n&quot;</span>;\n}\n}  <span class=\"hljs-comment\">// namespace tests</span>\n\n<span class=\"hljs-comment\">/**\n * @brief Function to test the correctness of the Tree Reversal\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n    tests::<span class=\"hljs-built_in\">test1</span>();  <span class=\"hljs-comment\">///&lt; Single element test</span>\n    tests::<span class=\"hljs-built_in\">test2</span>();  <span class=\"hljs-comment\">///&lt; No element test</span>\n    tests::<span class=\"hljs-built_in\">test3</span>();  <span class=\"hljs-comment\">///&lt; Correct reversal test</span>\n}\n\n<span class=\"hljs-comment\">/**\n * @brief main function\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// run self-test implementations</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Alvin Philips",
      "email": "alvinphilips257@gmail.com",
      "commits": 1
    }
  ],
  "explanationUrl": {}
}