{
  "slug": "segment-tree",
  "name": "Segment Tree",
  "categories": [
    "datastructures",
    "binarytree"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "data_structures/binary_tree/segment_tree.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/data_structures/binary_tree/segment_tree.py",
      "code": "<span class=\"hljs-keyword\">import</span> math\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SegmentTree</span>:\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">self, A</span>):\n        self.N = <span class=\"hljs-built_in\">len</span>(A)\n        self.st = [<span class=\"hljs-number\">0</span>] * (\n            <span class=\"hljs-number\">4</span> * self.N\n        )  <span class=\"hljs-comment\"># approximate the overall size of segment tree with array N</span>\n        self.build(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, self.N - <span class=\"hljs-number\">1</span>)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">left</span>(<span class=\"hljs-params\">self, idx</span>):\n        <span class=\"hljs-keyword\">return</span> idx * <span class=\"hljs-number\">2</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">right</span>(<span class=\"hljs-params\">self, idx</span>):\n        <span class=\"hljs-keyword\">return</span> idx * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">build</span>(<span class=\"hljs-params\">self, idx, l, r</span>):  <span class=\"hljs-comment\"># noqa: E741</span>\n        <span class=\"hljs-keyword\">if</span> l == r:  <span class=\"hljs-comment\"># noqa: E741</span>\n            self.st[idx] = A[l]\n        <span class=\"hljs-keyword\">else</span>:\n            mid = (l + r) // <span class=\"hljs-number\">2</span>\n            self.build(self.left(idx), l, mid)\n            self.build(self.right(idx), mid + <span class=\"hljs-number\">1</span>, r)\n            self.st[idx] = <span class=\"hljs-built_in\">max</span>(self.st[self.left(idx)], self.st[self.right(idx)])\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">update</span>(<span class=\"hljs-params\">self, a, b, val</span>):\n        <span class=\"hljs-keyword\">return</span> self.update_recursive(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, self.N - <span class=\"hljs-number\">1</span>, a - <span class=\"hljs-number\">1</span>, b - <span class=\"hljs-number\">1</span>, val)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">update_recursive</span>(<span class=\"hljs-params\">self, idx, l, r, a, b, val</span>):  <span class=\"hljs-comment\"># noqa: E741</span>\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        update(1, 1, N, a, b, v) for update val v to [a,b]\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">if</span> r &lt; a <span class=\"hljs-keyword\">or</span> l &gt; b:\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n        <span class=\"hljs-keyword\">if</span> l == r:  <span class=\"hljs-comment\"># noqa: E741</span>\n            self.st[idx] = val\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n        mid = (l + r) // <span class=\"hljs-number\">2</span>\n        self.update_recursive(self.left(idx), l, mid, a, b, val)\n        self.update_recursive(self.right(idx), mid + <span class=\"hljs-number\">1</span>, r, a, b, val)\n        self.st[idx] = <span class=\"hljs-built_in\">max</span>(self.st[self.left(idx)], self.st[self.right(idx)])\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">True</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">query</span>(<span class=\"hljs-params\">self, a, b</span>):\n        <span class=\"hljs-keyword\">return</span> self.query_recursive(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, self.N - <span class=\"hljs-number\">1</span>, a - <span class=\"hljs-number\">1</span>, b - <span class=\"hljs-number\">1</span>)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">query_recursive</span>(<span class=\"hljs-params\">self, idx, l, r, a, b</span>):  <span class=\"hljs-comment\"># noqa: E741</span>\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        query(1, 1, N, a, b) for query max of [a,b]\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">if</span> r &lt; a <span class=\"hljs-keyword\">or</span> l &gt; b:\n            <span class=\"hljs-keyword\">return</span> -math.inf\n        <span class=\"hljs-keyword\">if</span> l &gt;= a <span class=\"hljs-keyword\">and</span> r &lt;= b:  <span class=\"hljs-comment\"># noqa: E741</span>\n            <span class=\"hljs-keyword\">return</span> self.st[idx]\n        mid = (l + r) // <span class=\"hljs-number\">2</span>\n        q1 = self.query_recursive(self.left(idx), l, mid, a, b)\n        q2 = self.query_recursive(self.right(idx), mid + <span class=\"hljs-number\">1</span>, r, a, b)\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">max</span>(q1, q2)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">showData</span>(<span class=\"hljs-params\">self</span>):\n        showList = []\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">1</span>, N + <span class=\"hljs-number\">1</span>):\n            showList += [self.query(i, i)]\n        <span class=\"hljs-built_in\">print</span>(showList)\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    A = [<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">3</span>, -<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">11</span>, -<span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">8</span>]\n    N = <span class=\"hljs-number\">15</span>\n    segt = SegmentTree(A)\n    <span class=\"hljs-built_in\">print</span>(segt.query(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>))\n    <span class=\"hljs-built_in\">print</span>(segt.query(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">11</span>))\n    <span class=\"hljs-built_in\">print</span>(segt.query(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">12</span>))\n    segt.update(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">111</span>)\n    <span class=\"hljs-built_in\">print</span>(segt.query(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">15</span>))\n    segt.update(<span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">235</span>)\n    segt.showData()\n"
    },
    "java": {
      "dir": "src/main/java/com/thealgorithms/datastructures/trees/SegmentTree.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src/main/java/com/thealgorithms/datastructures/trees/SegmentTree.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.datastructures.trees;\n\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SegmentTree</span> {\n\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> seg_t[];\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> n;\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> arr[];\n\n    <span class=\"hljs-comment\">/* Constructor which takes the size of the array and the array as a parameter*/</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">SegmentTree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> n, <span class=\"hljs-type\">int</span> arr[])</span> {\n        <span class=\"hljs-built_in\">this</span>.n = n;\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">x</span> <span class=\"hljs-operator\">=</span> (<span class=\"hljs-type\">int</span>) (Math.ceil(Math.log(n) / Math.log(<span class=\"hljs-number\">2</span>)));\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">seg_size</span> <span class=\"hljs-operator\">=</span> <span class=\"hljs-number\">2</span> * (<span class=\"hljs-type\">int</span>) Math.pow(<span class=\"hljs-number\">2</span>, x) - <span class=\"hljs-number\">1</span>;\n\n        <span class=\"hljs-built_in\">this</span>.seg_t = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">int</span>[seg_size];\n        <span class=\"hljs-built_in\">this</span>.arr = arr;\n        <span class=\"hljs-built_in\">this</span>.n = n;\n        constructTree(arr, <span class=\"hljs-number\">0</span>, n - <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>);\n    }\n\n    <span class=\"hljs-comment\">/* A function which will create the segment tree*/</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">constructTree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>[] arr, <span class=\"hljs-type\">int</span> start, <span class=\"hljs-type\">int</span> end, <span class=\"hljs-type\">int</span> index)</span> {\n        <span class=\"hljs-keyword\">if</span> (start == end) {\n            <span class=\"hljs-built_in\">this</span>.seg_t[index] = arr[start];\n            <span class=\"hljs-keyword\">return</span> arr[start];\n        }\n\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">mid</span> <span class=\"hljs-operator\">=</span> start + (end - start) / <span class=\"hljs-number\">2</span>;\n        <span class=\"hljs-built_in\">this</span>.seg_t[index] = constructTree(arr, start, mid, index * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>)\n                + constructTree(arr, mid + <span class=\"hljs-number\">1</span>, end, index * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>);\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.seg_t[index];\n    }\n\n    <span class=\"hljs-comment\">/* A function which will update the value at a index i. This will be called by the\n    update function internally*/</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">updateTree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> start, <span class=\"hljs-type\">int</span> end, <span class=\"hljs-type\">int</span> index, <span class=\"hljs-type\">int</span> diff, <span class=\"hljs-type\">int</span> seg_index)</span> {\n        <span class=\"hljs-keyword\">if</span> (index &lt; start || index &gt; end) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n\n        <span class=\"hljs-built_in\">this</span>.seg_t[seg_index] += diff;\n        <span class=\"hljs-keyword\">if</span> (start != end) {\n            <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">mid</span> <span class=\"hljs-operator\">=</span> start + (end - start) / <span class=\"hljs-number\">2</span>;\n            updateTree(start, mid, index, diff, seg_index * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>);\n            updateTree(mid + <span class=\"hljs-number\">1</span>, end, index, diff, seg_index * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>);\n        }\n    }\n\n    <span class=\"hljs-comment\">/* A function to update the value at a particular index*/</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">update</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> index, <span class=\"hljs-type\">int</span> value)</span> {\n        <span class=\"hljs-keyword\">if</span> (index &lt; <span class=\"hljs-number\">0</span> || index &gt; n) {\n            <span class=\"hljs-keyword\">return</span>;\n        }\n\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">diff</span> <span class=\"hljs-operator\">=</span> value - arr[index];\n        arr[index] = value;\n        updateTree(<span class=\"hljs-number\">0</span>, n - <span class=\"hljs-number\">1</span>, index, diff, <span class=\"hljs-number\">0</span>);\n    }\n\n    <span class=\"hljs-comment\">/* A function to get the sum of the elements from index l to index r. This will be called internally*/</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getSumTree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> start, <span class=\"hljs-type\">int</span> end, <span class=\"hljs-type\">int</span> q_start, <span class=\"hljs-type\">int</span> q_end, <span class=\"hljs-type\">int</span> seg_index)</span> {\n        <span class=\"hljs-keyword\">if</span> (q_start &lt;= start &amp;&amp; q_end &gt;= end) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">this</span>.seg_t[seg_index];\n        }\n\n        <span class=\"hljs-keyword\">if</span> (q_start &gt; end || q_end &lt; start) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n        }\n\n        <span class=\"hljs-type\">int</span> <span class=\"hljs-variable\">mid</span> <span class=\"hljs-operator\">=</span> start + (end - start) / <span class=\"hljs-number\">2</span>;\n        <span class=\"hljs-keyword\">return</span> getSumTree(start, mid, q_start, q_end, seg_index * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>) + getSumTree(mid + <span class=\"hljs-number\">1</span>, end, q_start, q_end, seg_index * <span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">2</span>);\n    }\n\n    <span class=\"hljs-comment\">/* A function to query the sum of the subarray [start...end]*/</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">getSum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> start, <span class=\"hljs-type\">int</span> end)</span> {\n        <span class=\"hljs-keyword\">if</span> (start &lt; <span class=\"hljs-number\">0</span> || end &gt; n || start &gt; end) {\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n        }\n        <span class=\"hljs-keyword\">return</span> getSumTree(<span class=\"hljs-number\">0</span>, n - <span class=\"hljs-number\">1</span>, start, end, <span class=\"hljs-number\">0</span>);\n    }\n}\n"
    },
    "c": {
      "dir": "data_structures/binary_trees/segment_tree.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/data_structures/binary_trees/segment_tree.c",
      "code": "<span class=\"hljs-comment\">/**\n * @file segment_tree.c\n * @brief segment trees with only point updates\n * @details\n * This code implements segment trees. Segment trees are general structures\n * which allow range based queries in a given array in logN time.\n * Segment tree with point updates allow update of single element in the array\n * in logN time.\n * [Learn more about segment trees\n * here](https://codeforces.com/blog/entry/18051)\n * @author [Lakhan Nad](https://github.com/Lakhan-Nad)\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span>   <span class=\"hljs-comment\">/* for assert */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;inttypes.h&gt;</span> <span class=\"hljs-comment\">/* for int32 */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span>    <span class=\"hljs-comment\">/* for scanf printf */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span>   <span class=\"hljs-comment\">/* for malloc, free */</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string.h&gt;</span>   <span class=\"hljs-comment\">/* for memcpy, memset */</span></span>\n\n<span class=\"hljs-comment\">/**\n * Function that combines two data to generate a new one\n * The name of function might be misleading actually combine here signifies the\n * fact that in segment trees we take partial result from two ranges and using\n * partial results we derive the result for joint range of those two ranges\n * For Example: array(1,2,3,4,5,6) sum of range [0,2] = 6\n * and sum of range [3,5] = 15 the combined sum of two range is 6+15=21\n * @note The function is same to binary function in Discrete Mathematics\n * @param a pointer to first data\n * @param b pointer to second data\n * @param result pointer to memory location where result of combining a and b is\n * to be stored\n */</span>\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-title function_\">void</span> <span class=\"hljs-params\">(*combine_function)</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span> *a, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span> *b, <span class=\"hljs-type\">void</span> *result)</span>;\n\n<span class=\"hljs-comment\">/**\n * This structures holds all the data that is required by a segment tree\n */</span>\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">segment_tree</span>\n{</span>\n    <span class=\"hljs-type\">void</span> *root;       <span class=\"hljs-comment\">/**&lt; the root of formed segment tree */</span>\n    <span class=\"hljs-type\">void</span> *identity;   <span class=\"hljs-comment\">/**&lt; identity element for combine function */</span>\n    <span class=\"hljs-type\">size_t</span> elem_size; <span class=\"hljs-comment\">/**&lt; size in bytes of each data element */</span>\n    <span class=\"hljs-type\">size_t</span> length;    <span class=\"hljs-comment\">/**&lt; total size of array which segment tree represents*/</span>\n    <span class=\"hljs-comment\">/** the function to be used to combine two node&#x27;s\n     * data to form parent&#x27;s data\n     */</span>\n    combine_function combine;\n} segment_tree;\n\n<span class=\"hljs-comment\">/**\n * Builds a Segment tree\n * It is assumed that leaves of tree already contains data.\n * @param tree pointer to segment tree to be build\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">segment_tree_build</span><span class=\"hljs-params\">(segment_tree *tree)</span>\n{\n    <span class=\"hljs-type\">size_t</span> elem_size = tree-&gt;elem_size;\n    <span class=\"hljs-type\">int</span> index = (tree-&gt;length - <span class=\"hljs-number\">2</span>);\n    <span class=\"hljs-type\">size_t</span> b, l, r;\n    <span class=\"hljs-type\">char</span> *ptr = (<span class=\"hljs-type\">char</span> *)tree-&gt;root;\n    <span class=\"hljs-keyword\">for</span> (; index &gt;= <span class=\"hljs-number\">0</span>; index--)\n    {\n        b = index * elem_size;\n        l = (<span class=\"hljs-number\">2</span> * index + <span class=\"hljs-number\">1</span>) * elem_size;\n        r = (<span class=\"hljs-number\">2</span> * index + <span class=\"hljs-number\">2</span>) * elem_size;\n        tree-&gt;combine(ptr + l, ptr + r, ptr + b);\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * For point updates\n * This function updates the element at given index and also updates segment\n * tree accordingly\n *\n * @param tree pointer to segment tree\n * @param index the index whose element is to be updated (0 based indexing used)\n * @param val pointer to value that is to be replaced at given index\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">segment_tree_update</span><span class=\"hljs-params\">(segment_tree *tree, <span class=\"hljs-type\">size_t</span> index, <span class=\"hljs-type\">void</span> *val)</span>\n{\n    <span class=\"hljs-type\">size_t</span> elem_size = tree-&gt;elem_size;\n    index = index + tree-&gt;length - <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-type\">char</span> *base = (<span class=\"hljs-type\">char</span> *)tree-&gt;root;\n    <span class=\"hljs-type\">char</span> *t = base + index * elem_size;\n    <span class=\"hljs-built_in\">memcpy</span>(t, val, elem_size);\n    <span class=\"hljs-keyword\">while</span> (index &gt; <span class=\"hljs-number\">0</span>)\n    {\n        index = ((index - <span class=\"hljs-number\">1</span>) &gt;&gt; <span class=\"hljs-number\">1</span>);\n        tree-&gt;combine(base + (<span class=\"hljs-number\">2</span> * index + <span class=\"hljs-number\">1</span>) * elem_size,\n                      base + (<span class=\"hljs-number\">2</span> * index + <span class=\"hljs-number\">2</span>) * elem_size,\n                      base + index * elem_size);\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * Query the segment tree\n * This function helps in range query of segment tree\n * This function assumes that the given range is valid\n * Performs the query in range [l,r]\n * @param tree pointer to segment tree\n * @param l the start of range\n * @param r the end of range\n * @param res the pointer to memory where result of query is stored\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">segment_tree_query</span><span class=\"hljs-params\">(segment_tree *tree, <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> l, <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> r, <span class=\"hljs-type\">void</span> *res)</span>\n{\n    <span class=\"hljs-type\">size_t</span> elem_size = tree-&gt;elem_size;\n    <span class=\"hljs-built_in\">memcpy</span>(res, tree-&gt;identity, elem_size);\n    elem_size = tree-&gt;elem_size;\n    <span class=\"hljs-type\">char</span> *root = (<span class=\"hljs-type\">char</span> *)tree-&gt;root;\n    l += tree-&gt;length - <span class=\"hljs-number\">1</span>;\n    r += tree-&gt;length - <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-keyword\">while</span> (l &lt;= r)\n    {\n        <span class=\"hljs-keyword\">if</span> (!(l &amp; <span class=\"hljs-number\">1</span>))\n        {\n            tree-&gt;combine(res, root + l * elem_size, res);\n        }\n        <span class=\"hljs-keyword\">if</span> (r &amp; <span class=\"hljs-number\">1</span>)\n        {\n            tree-&gt;combine(res, root + r * elem_size, res);\n        }\n        r = (r &gt;&gt; <span class=\"hljs-number\">1</span>) - <span class=\"hljs-number\">1</span>;\n        l = (l &gt;&gt; <span class=\"hljs-number\">1</span>);\n    }\n}\n\n<span class=\"hljs-comment\">/**\n * Initializes Segment Tree\n * Accquires memory for segment tree\n * and fill the leaves of segment tree with data from array\n * @param arr the array data upon which segment tree is build\n * @param elem_size size of each element in segment tree\n * @param len total no of elements in array\n * @param identity the identity element for combine_function\n * @param func the combine_function used to build segment tree\n *\n * @returns pointer to sgement tree build\n */</span>\nsegment_tree *<span class=\"hljs-title function_\">segment_tree_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arr, <span class=\"hljs-type\">size_t</span> elem_size, <span class=\"hljs-type\">size_t</span> len,\n                                <span class=\"hljs-type\">void</span> *identity, combine_function func)</span>\n{\n    segment_tree *tree = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(segment_tree));\n    tree-&gt;elem_size = elem_size;\n    tree-&gt;length = len;\n    tree-&gt;combine = func;\n    tree-&gt;root = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">char</span>) * elem_size * (<span class=\"hljs-number\">2</span> * len - <span class=\"hljs-number\">1</span>));\n    tree-&gt;identity = <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">char</span>) * elem_size);\n    <span class=\"hljs-type\">char</span> *ptr = (<span class=\"hljs-type\">char</span> *)tree-&gt;root;\n    <span class=\"hljs-built_in\">memset</span>(ptr, <span class=\"hljs-number\">0</span>, (len - <span class=\"hljs-number\">1</span>) * elem_size);  <span class=\"hljs-comment\">// Initializing memory</span>\n    ptr = ptr + (len - <span class=\"hljs-number\">1</span>) * elem_size;\n    <span class=\"hljs-built_in\">memcpy</span>(ptr, arr, elem_size * len);  <span class=\"hljs-comment\">// copy the leaf nodes i.e. array data</span>\n    <span class=\"hljs-built_in\">memcpy</span>(tree-&gt;identity, identity, elem_size);  <span class=\"hljs-comment\">// copy identity element</span>\n    <span class=\"hljs-keyword\">return</span> tree;\n}\n\n<span class=\"hljs-comment\">/**\n * Dispose Segment Tree\n * Frees all heap memory accquired by segment tree\n * @param tree pointer to segment tree\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">segment_tree_dispose</span><span class=\"hljs-params\">(segment_tree *tree)</span>\n{\n    <span class=\"hljs-built_in\">free</span>(tree-&gt;root);\n    <span class=\"hljs-built_in\">free</span>(tree-&gt;identity);\n}\n\n<span class=\"hljs-comment\">/**\n * Prints the data in segment tree\n * The data should be of int type\n * A utility to print segment tree\n * with data type of int\n * @param tree pointer to segment tree\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">segment_tree_print_int</span><span class=\"hljs-params\">(segment_tree *tree)</span>\n{\n    <span class=\"hljs-type\">char</span> *base = (<span class=\"hljs-type\">char</span> *)tree-&gt;root;\n    <span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> (; i &lt; <span class=\"hljs-number\">2</span> * tree-&gt;length - <span class=\"hljs-number\">1</span>; i++)\n    {\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>, *(<span class=\"hljs-type\">int</span> *)(base + i * tree-&gt;elem_size));\n    }\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);\n}\n\n<span class=\"hljs-comment\">/**\n * Utility for test\n * A function compare for minimum between two integers\n * This function is used as combine_function for RMQ\n * @param a pointer to integer a\n * @param b pointer to integer b\n * @param c pointer where minimum of a and b is tored as result\n */</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">minimum</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span> *a, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span> *b, <span class=\"hljs-type\">void</span> *c)</span>\n{\n    *(<span class=\"hljs-type\">int</span> *)c = *(<span class=\"hljs-type\">int</span> *)a &lt; *(<span class=\"hljs-type\">int</span> *)b ? *(<span class=\"hljs-type\">int</span> *)a : *(<span class=\"hljs-type\">int</span> *)b;\n}\n\n<span class=\"hljs-comment\">/**\n * Test RMQ\n * Testing Segment tree using\n * Range Minimum Queries\n * @returns void\n */</span>\n<span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">()</span>\n{\n    <span class=\"hljs-type\">int32_t</span> arr[<span class=\"hljs-number\">10</span>] = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">-2</span>, <span class=\"hljs-number\">8</span>};\n    <span class=\"hljs-type\">int32_t</span> identity = __INT32_MAX__;\n    segment_tree *tree =\n        segment_tree_init(arr, <span class=\"hljs-keyword\">sizeof</span>(*arr), <span class=\"hljs-number\">10</span>, &amp;identity, minimum);\n    segment_tree_build(tree);\n    <span class=\"hljs-type\">int32_t</span> result;\n    segment_tree_query(tree, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">6</span>, &amp;result);\n    assert(result == <span class=\"hljs-number\">2</span>);\n    segment_tree_query(tree, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, &amp;result);\n    assert(result == <span class=\"hljs-number\">-2</span>);\n    result = <span class=\"hljs-number\">12</span>;\n    segment_tree_update(tree, <span class=\"hljs-number\">5</span>, &amp;result);\n    segment_tree_update(tree, <span class=\"hljs-number\">8</span>, &amp;result);\n    segment_tree_query(tree, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">3</span>, &amp;result);\n    assert(result == <span class=\"hljs-number\">0</span>);\n    segment_tree_query(tree, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, &amp;result);\n    assert(result == <span class=\"hljs-number\">8</span>);\n    segment_tree_dispose(tree);\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Main Function\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>\n{\n    test();\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "go": {
      "dir": "structure/segmenttree/segmenttree.go",
      "url": "https://github.com/TheAlgorithms/go/tree/master/structure/segmenttree/segmenttree.go",
      "code": "<span class=\"hljs-comment\">//Segment Tree Data Structure for Range Queries</span>\n<span class=\"hljs-comment\">//Build: O(n*log(n))</span>\n<span class=\"hljs-comment\">//Query: O(log(n))</span>\n<span class=\"hljs-comment\">//Update: O(log(n))</span>\n<span class=\"hljs-comment\">//reference: https://cp-algorithms.com/data_structures/segment_tree.html</span>\n\n<span class=\"hljs-keyword\">package</span> segmenttree\n\n<span class=\"hljs-keyword\">import</span> (\n\t<span class=\"hljs-string\">&quot;github.com/TheAlgorithms/Go/math/max&quot;</span>\n\t<span class=\"hljs-string\">&quot;github.com/TheAlgorithms/Go/math/min&quot;</span>\n)\n\n<span class=\"hljs-keyword\">const</span> emptyLazyNode = <span class=\"hljs-number\">0</span>\n\n<span class=\"hljs-comment\">//SegmentTree with original Array and the Segment Tree Array</span>\n<span class=\"hljs-keyword\">type</span> SegmentTree <span class=\"hljs-keyword\">struct</span> {\n\tArray       []<span class=\"hljs-type\">int</span>\n\tSegmentTree []<span class=\"hljs-type\">int</span>\n\tLazyTree    []<span class=\"hljs-type\">int</span>\n}\n\n<span class=\"hljs-comment\">//Propagate lazy tree node values</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s *SegmentTree)</span></span> Propagate(node <span class=\"hljs-type\">int</span>, leftNode <span class=\"hljs-type\">int</span>, rightNode <span class=\"hljs-type\">int</span>) {\n\t<span class=\"hljs-keyword\">if</span> s.LazyTree[node] != emptyLazyNode {\n\t\t<span class=\"hljs-comment\">//add lazy node value multiplied by (right-left+1), which represents all interval</span>\n\t\t<span class=\"hljs-comment\">//this is the same of adding a value on each node</span>\n\t\ts.SegmentTree[node] += (rightNode - leftNode + <span class=\"hljs-number\">1</span>) * s.LazyTree[node]\n\n\t\t<span class=\"hljs-keyword\">if</span> leftNode == rightNode {\n\t\t\t<span class=\"hljs-comment\">//leaf node</span>\n\t\t\ts.Array[leftNode] += s.LazyTree[node]\n\t\t} <span class=\"hljs-keyword\">else</span> {\n\t\t\t<span class=\"hljs-comment\">//propagate lazy node value for children nodes</span>\n\t\t\t<span class=\"hljs-comment\">//may propagate multiple times, children nodes should accumulate lazy node value</span>\n\t\t\ts.LazyTree[<span class=\"hljs-number\">2</span>*node] += s.LazyTree[node]\n\t\t\ts.LazyTree[<span class=\"hljs-number\">2</span>*node+<span class=\"hljs-number\">1</span>] += s.LazyTree[node]\n\t\t}\n\n\t\t<span class=\"hljs-comment\">//clear lazy node</span>\n\t\ts.LazyTree[node] = emptyLazyNode\n\t}\n}\n\n<span class=\"hljs-comment\">//Query on interval [firstIndex, leftIndex]</span>\n<span class=\"hljs-comment\">//node, leftNode and rightNode always should start with 1, 0 and len(Array)-1</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s *SegmentTree)</span></span> Query(node <span class=\"hljs-type\">int</span>, leftNode <span class=\"hljs-type\">int</span>, rightNode <span class=\"hljs-type\">int</span>, firstIndex <span class=\"hljs-type\">int</span>, lastIndex <span class=\"hljs-type\">int</span>) <span class=\"hljs-type\">int</span> {\n\t<span class=\"hljs-keyword\">if</span> (firstIndex &gt; lastIndex) || (leftNode &gt; rightNode) {\n\t\t<span class=\"hljs-comment\">//outside the interval</span>\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>\n\t}\n\n\t<span class=\"hljs-comment\">//propagate lazy tree</span>\n\ts.Propagate(node, leftNode, rightNode)\n\n\t<span class=\"hljs-keyword\">if</span> (leftNode &gt;= firstIndex) &amp;&amp; (rightNode &lt;= lastIndex) {\n\t\t<span class=\"hljs-comment\">//inside the interval</span>\n\t\t<span class=\"hljs-keyword\">return</span> s.SegmentTree[node]\n\t}\n\n\t<span class=\"hljs-comment\">//get sum of left and right nodes</span>\n\tmid := (leftNode + rightNode) / <span class=\"hljs-number\">2</span>\n\n\tleftNodeSum := s.Query(<span class=\"hljs-number\">2</span>*node, leftNode, mid, firstIndex, min.Int(mid, lastIndex))\n\trightNodeSum := s.Query(<span class=\"hljs-number\">2</span>*node+<span class=\"hljs-number\">1</span>, mid+<span class=\"hljs-number\">1</span>, rightNode, max.Int(firstIndex, mid+<span class=\"hljs-number\">1</span>), lastIndex)\n\n\t<span class=\"hljs-keyword\">return</span> leftNodeSum + rightNodeSum\n}\n\n<span class=\"hljs-comment\">//Update Segment Tree</span>\n<span class=\"hljs-comment\">//node, leftNode and rightNode always should start with 1, 0 and len(Array)-1</span>\n<span class=\"hljs-comment\">//index is the Array index that you want to update</span>\n<span class=\"hljs-comment\">//value is the value that you want to override</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s *SegmentTree)</span></span> Update(node <span class=\"hljs-type\">int</span>, leftNode <span class=\"hljs-type\">int</span>, rightNode <span class=\"hljs-type\">int</span>, firstIndex <span class=\"hljs-type\">int</span>, lastIndex <span class=\"hljs-type\">int</span>, value <span class=\"hljs-type\">int</span>) {\n\t<span class=\"hljs-comment\">//propagate lazy tree</span>\n\ts.Propagate(node, leftNode, rightNode)\n\n\t<span class=\"hljs-keyword\">if</span> (firstIndex &gt; lastIndex) || (leftNode &gt; rightNode) {\n\t\t<span class=\"hljs-comment\">//outside the interval</span>\n\t\t<span class=\"hljs-keyword\">return</span>\n\t}\n\n\t<span class=\"hljs-keyword\">if</span> (leftNode &gt;= firstIndex) &amp;&amp; (rightNode &lt;= lastIndex) {\n\t\t<span class=\"hljs-comment\">//inside the interval</span>\n\t\t<span class=\"hljs-comment\">//accumulate the lazy node value</span>\n\t\ts.LazyTree[node] += value\n\t\ts.Propagate(node, leftNode, rightNode)\n\t} <span class=\"hljs-keyword\">else</span> {\n\t\t<span class=\"hljs-comment\">//update left and right nodes</span>\n\t\tmid := (leftNode + rightNode) / <span class=\"hljs-number\">2</span>\n\n\t\ts.Update(<span class=\"hljs-number\">2</span>*node, leftNode, mid, firstIndex, min.Int(mid, lastIndex), value)\n\t\ts.Update(<span class=\"hljs-number\">2</span>*node+<span class=\"hljs-number\">1</span>, mid+<span class=\"hljs-number\">1</span>, rightNode, max.Int(firstIndex, mid+<span class=\"hljs-number\">1</span>), lastIndex, value)\n\n\t\ts.SegmentTree[node] = s.SegmentTree[<span class=\"hljs-number\">2</span>*node] + s.SegmentTree[<span class=\"hljs-number\">2</span>*node+<span class=\"hljs-number\">1</span>]\n\t}\n}\n\n<span class=\"hljs-comment\">//Build Segment Tree</span>\n<span class=\"hljs-comment\">//node, leftNode and rightNode always should start with 1, 0 and len(Array)-1</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s *SegmentTree)</span></span> Build(node <span class=\"hljs-type\">int</span>, left <span class=\"hljs-type\">int</span>, right <span class=\"hljs-type\">int</span>) {\n\t<span class=\"hljs-keyword\">if</span> left == right {\n\t\t<span class=\"hljs-comment\">//leaf node</span>\n\t\ts.SegmentTree[node] = s.Array[left]\n\t} <span class=\"hljs-keyword\">else</span> {\n\t\t<span class=\"hljs-comment\">//get sum of left and right nodes</span>\n\t\tmid := (left + right) / <span class=\"hljs-number\">2</span>\n\n\t\ts.Build(<span class=\"hljs-number\">2</span>*node, left, mid)\n\t\ts.Build(<span class=\"hljs-number\">2</span>*node+<span class=\"hljs-number\">1</span>, mid+<span class=\"hljs-number\">1</span>, right)\n\n\t\ts.SegmentTree[node] = s.SegmentTree[<span class=\"hljs-number\">2</span>*node] + s.SegmentTree[<span class=\"hljs-number\">2</span>*node+<span class=\"hljs-number\">1</span>]\n\t}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewSegmentTree</span><span class=\"hljs-params\">(Array []<span class=\"hljs-type\">int</span>)</span></span> *SegmentTree {\n\t<span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(Array) == <span class=\"hljs-number\">0</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n\t}\n\n\tsegTree := SegmentTree{\n\t\tArray:       Array,\n\t\tSegmentTree: <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">4</span>*<span class=\"hljs-built_in\">len</span>(Array)),\n\t\tLazyTree:    <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-type\">int</span>, <span class=\"hljs-number\">4</span>*<span class=\"hljs-built_in\">len</span>(Array)),\n\t}\n\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-keyword\">range</span> segTree.LazyTree {\n\t\t<span class=\"hljs-comment\">//fill LazyTree with empty lazy nodes</span>\n\t\tsegTree.LazyTree[i] = emptyLazyNode\n\t}\n\n\t<span class=\"hljs-comment\">//starts with node 1 and interval [0, len(arr)-1] inclusive</span>\n\tsegTree.Build(<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">len</span>(Array)<span class=\"hljs-number\">-1</span>)\n\n\t<span class=\"hljs-keyword\">return</span> &amp;segTree\n}\n"
    },
    "rust": {
      "dir": "src/data_structures/segment_tree.rs",
      "url": "https://github.com/TheAlgorithms/rust/tree/master/src/data_structures/segment_tree.rs",
      "code": "<span class=\"hljs-comment\">/// This stucture implements a segmented tree that</span>\n<span class=\"hljs-comment\">/// can efficiently answer range queries on arrays.</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">SegmentTree</span>&lt;T: <span class=\"hljs-built_in\">Default</span> + <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span>&gt; {\n    len: <span class=\"hljs-type\">usize</span>,\n    buf: <span class=\"hljs-type\">Vec</span>&lt;T&gt;,\n    op: Ops,\n}\n\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Ops</span> {\n    Max,\n    Min,\n}\n\n<span class=\"hljs-keyword\">impl</span>&lt;T: <span class=\"hljs-built_in\">Default</span> + <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span>&gt; SegmentTree&lt;T&gt; {\n    <span class=\"hljs-comment\">/// function to build the tree</span>\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">from_vec</span>(arr: &amp;[T], op: Ops) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-keyword\">Self</span> {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">len</span> = arr.<span class=\"hljs-title function_ invoke__\">len</span>();\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">buf</span>: <span class=\"hljs-type\">Vec</span>&lt;T&gt; = <span class=\"hljs-built_in\">vec!</span>[T::<span class=\"hljs-title function_ invoke__\">default</span>(); <span class=\"hljs-number\">2</span> * len];\n        buf[len..(len + len)].<span class=\"hljs-title function_ invoke__\">clone_from_slice</span>(&amp;arr[<span class=\"hljs-number\">0</span>..len]);\n        <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">i</span> <span class=\"hljs-keyword\">in</span> (<span class=\"hljs-number\">1</span>..len).<span class=\"hljs-title function_ invoke__\">rev</span>() {\n            buf[i] = <span class=\"hljs-keyword\">match</span> op {\n                Ops::Max =&gt; buf[<span class=\"hljs-number\">2</span> * i].<span class=\"hljs-title function_ invoke__\">max</span>(buf[<span class=\"hljs-number\">2</span> * i + <span class=\"hljs-number\">1</span>]),\n                Ops::Min =&gt; buf[<span class=\"hljs-number\">2</span> * i].<span class=\"hljs-title function_ invoke__\">min</span>(buf[<span class=\"hljs-number\">2</span> * i + <span class=\"hljs-number\">1</span>]),\n            };\n        }\n        SegmentTree { len, buf, op }\n    }\n\n    <span class=\"hljs-comment\">/// function to get sum on interval [l, r]</span>\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">query</span>(&amp;<span class=\"hljs-keyword\">self</span>, <span class=\"hljs-keyword\">mut</span> l: <span class=\"hljs-type\">usize</span>, <span class=\"hljs-keyword\">mut</span> r: <span class=\"hljs-type\">usize</span>) <span class=\"hljs-punctuation\">-&gt;</span> T {\n        l += <span class=\"hljs-keyword\">self</span>.len;\n        r += <span class=\"hljs-keyword\">self</span>.len;\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">res</span> = <span class=\"hljs-keyword\">self</span>.buf[l];\n        <span class=\"hljs-keyword\">while</span> l &lt;= r {\n            <span class=\"hljs-keyword\">if</span> l % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">1</span> {\n                res = <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span>.op {\n                    Ops::Max =&gt; res.<span class=\"hljs-title function_ invoke__\">max</span>(<span class=\"hljs-keyword\">self</span>.buf[l]),\n                    Ops::Min =&gt; res.<span class=\"hljs-title function_ invoke__\">min</span>(<span class=\"hljs-keyword\">self</span>.buf[l]),\n                };\n                l += <span class=\"hljs-number\">1</span>;\n            }\n            <span class=\"hljs-keyword\">if</span> r % <span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span> {\n                res = <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span>.op {\n                    Ops::Max =&gt; res.<span class=\"hljs-title function_ invoke__\">max</span>(<span class=\"hljs-keyword\">self</span>.buf[r]),\n                    Ops::Min =&gt; res.<span class=\"hljs-title function_ invoke__\">min</span>(<span class=\"hljs-keyword\">self</span>.buf[r]),\n                };\n                r -= <span class=\"hljs-number\">1</span>;\n            }\n            l /= <span class=\"hljs-number\">2</span>;\n            r /= <span class=\"hljs-number\">2</span>;\n        }\n        res\n    }\n\n    <span class=\"hljs-comment\">/// function to update a tree node</span>\n    <span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">update</span>(&amp;<span class=\"hljs-keyword\">mut</span> <span class=\"hljs-keyword\">self</span>, <span class=\"hljs-keyword\">mut</span> idx: <span class=\"hljs-type\">usize</span>, val: T) {\n        idx += <span class=\"hljs-keyword\">self</span>.len;\n        <span class=\"hljs-keyword\">self</span>.buf[idx] = val;\n        idx /= <span class=\"hljs-number\">2</span>;\n\n        <span class=\"hljs-keyword\">while</span> idx != <span class=\"hljs-number\">0</span> {\n            <span class=\"hljs-keyword\">self</span>.buf[idx] = <span class=\"hljs-keyword\">match</span> <span class=\"hljs-keyword\">self</span>.op {\n                Ops::Max =&gt; <span class=\"hljs-keyword\">self</span>.buf[<span class=\"hljs-number\">2</span> * idx].<span class=\"hljs-title function_ invoke__\">max</span>(<span class=\"hljs-keyword\">self</span>.buf[<span class=\"hljs-number\">2</span> * idx + <span class=\"hljs-number\">1</span>]),\n                Ops::Min =&gt; <span class=\"hljs-keyword\">self</span>.buf[<span class=\"hljs-number\">2</span> * idx].<span class=\"hljs-title function_ invoke__\">min</span>(<span class=\"hljs-keyword\">self</span>.buf[<span class=\"hljs-number\">2</span> * idx + <span class=\"hljs-number\">1</span>]),\n            };\n            idx /= <span class=\"hljs-number\">2</span>;\n        }\n    }\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> super::*;\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">it_works</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">vec</span> = <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">3</span>, -<span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">11</span>, -<span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">14</span>, <span class=\"hljs-number\">15</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">2</span>, -<span class=\"hljs-number\">8</span>];\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">min_seg_tree</span> = SegmentTree::<span class=\"hljs-title function_ invoke__\">from_vec</span>(&amp;vec, Ops::Min);\n        <span class=\"hljs-built_in\">assert_eq!</span>(-<span class=\"hljs-number\">5</span>, min_seg_tree.<span class=\"hljs-title function_ invoke__\">query</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>));\n        <span class=\"hljs-built_in\">assert_eq!</span>(-<span class=\"hljs-number\">20</span>, min_seg_tree.<span class=\"hljs-title function_ invoke__\">query</span>(<span class=\"hljs-number\">0</span>, vec.<span class=\"hljs-title function_ invoke__\">len</span>() - <span class=\"hljs-number\">1</span>));\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">max_seg_tree</span> = SegmentTree::<span class=\"hljs-title function_ invoke__\">from_vec</span>(&amp;vec, Ops::Max);\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">6</span>, max_seg_tree.<span class=\"hljs-title function_ invoke__\">query</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>));\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">15</span>, max_seg_tree.<span class=\"hljs-title function_ invoke__\">query</span>(<span class=\"hljs-number\">0</span>, vec.<span class=\"hljs-title function_ invoke__\">len</span>() - <span class=\"hljs-number\">1</span>));\n        max_seg_tree.<span class=\"hljs-title function_ invoke__\">update</span>(<span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>);\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-number\">8</span>, max_seg_tree.<span class=\"hljs-title function_ invoke__\">query</span>(<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>));\n    }\n}\n"
    },
    "c-sharp": {
      "dir": "./DataStructures/SegmentTrees/SegmentTree.cs",
      "url": "https:/github.com/TheAlgorithms/C-Sharp/tree/master/DataStructures/SegmentTrees/SegmentTree.cs",
      "code": "<span class=\"hljs-keyword\">using</span> System;\n\n<span class=\"hljs-keyword\">namespace</span> <span class=\"hljs-title\">DataStructures.SegmentTrees</span>\n{\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Goal:   Data structure with which you can quickly perform queries on an array (i.e. sum of subarray)</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     and at the same time efficiently update an entry</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     or apply a distributive operation to a subarray.</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Idea:   Preprocessing special queries</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Hint:   The query operation HAS to be associative (in this example addition).</span>\n    <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">SegmentTree</span>\n    {\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Initializes a new instance of the <span class=\"hljs-doctag\">&lt;see cref=&quot;SegmentTree&quot; /&gt;</span> class.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Runtime complexity: O(n) where n equals the array-length.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;arr&quot;&gt;</span>Array on which the queries should be made.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">SegmentTree</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span>[] arr</span>)</span>\n        {\n            <span class=\"hljs-comment\">// Calculates next power of two</span>\n            <span class=\"hljs-keyword\">var</span> pow = (<span class=\"hljs-built_in\">int</span>)Math.Pow(<span class=\"hljs-number\">2</span>, Math.Ceiling(Math.Log(arr.Length, <span class=\"hljs-number\">2</span>)));\n            Tree = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">int</span>[<span class=\"hljs-number\">2</span> * pow];\n\n            <span class=\"hljs-comment\">// Transfers the input array into the last half of the segment tree array</span>\n            Array.Copy(arr, <span class=\"hljs-number\">0</span>, Tree, pow, arr.Length);\n\n            <span class=\"hljs-comment\">// Calculates the first half</span>\n            <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">var</span> i = pow - <span class=\"hljs-number\">1</span>; i &gt; <span class=\"hljs-number\">0</span>; --i)\n            {\n                Tree[i] = Tree[Left(i)] + Tree[Right(i)];\n            }\n        }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span>Gets the segment tree array.<span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span>[] Tree { <span class=\"hljs-keyword\">get</span>; }\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Starts a query.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Runtime complexity: O(logN) where n equals the array-length.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;l&quot;&gt;</span>Left border of the query.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;r&quot;&gt;</span>Right border of the query.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Sum of the subarray between <span class=\"hljs-doctag\">&lt;c&gt;</span>l<span class=\"hljs-doctag\">&lt;/c&gt;</span> and <span class=\"hljs-doctag\">&lt;c&gt;</span>r<span class=\"hljs-doctag\">&lt;/c&gt;</span> (including <span class=\"hljs-doctag\">&lt;c&gt;</span>l<span class=\"hljs-doctag\">&lt;/c&gt;</span> and <span class=\"hljs-doctag\">&lt;c&gt;</span>r<span class=\"hljs-doctag\">&lt;/c&gt;</span>).<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-comment\">// Editing of query start at node with 1.</span>\n        <span class=\"hljs-comment\">// Node with index 1 includes the whole input subarray.</span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">Query</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span> l, <span class=\"hljs-built_in\">int</span> r</span>)</span> =&gt;\n            Query(++l, ++r, <span class=\"hljs-number\">1</span>, Tree.Length / <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>);\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Calculates the right child of a node.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;node&quot;&gt;</span>Current node.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Index of the right child.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">Right</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span> node</span>)</span> =&gt; <span class=\"hljs-number\">2</span> * node + <span class=\"hljs-number\">1</span>;\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Calculates the left child of a node.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;node&quot;&gt;</span>Current node.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Index of the left child.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">Left</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span> node</span>)</span> =&gt; <span class=\"hljs-number\">2</span> * node;\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Calculates the parent of a node.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;node&quot;&gt;</span>Current node.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Index of the parent node.<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">Parent</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span> node</span>)</span> =&gt; node / <span class=\"hljs-number\">2</span>;\n\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span>     Edits a query.</span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;/summary&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;l&quot;&gt;</span>Left border of the query.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;r&quot;&gt;</span>Right border of the query.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;a&quot;&gt;</span>Left end of the subarray enclosed by <span class=\"hljs-doctag\">&lt;c&gt;</span>i<span class=\"hljs-doctag\">&lt;/c&gt;</span>.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;b&quot;&gt;</span>Right end of the subarray enclosed by <span class=\"hljs-doctag\">&lt;c&gt;</span>i<span class=\"hljs-doctag\">&lt;/c&gt;</span>.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;param name=&quot;i&quot;&gt;</span>Current node.<span class=\"hljs-doctag\">&lt;/param&gt;</span></span>\n        <span class=\"hljs-comment\"><span class=\"hljs-doctag\">///</span> <span class=\"hljs-doctag\">&lt;returns&gt;</span>Sum of a subarray between <span class=\"hljs-doctag\">&lt;c&gt;</span>l<span class=\"hljs-doctag\">&lt;/c&gt;</span> and <span class=\"hljs-doctag\">&lt;c&gt;</span>r<span class=\"hljs-doctag\">&lt;/c&gt;</span> (including <span class=\"hljs-doctag\">&lt;c&gt;</span>l<span class=\"hljs-doctag\">&lt;/c&gt;</span> and <span class=\"hljs-doctag\">&lt;c&gt;</span>r<span class=\"hljs-doctag\">&lt;/c&gt;</span>).<span class=\"hljs-doctag\">&lt;/returns&gt;</span></span>\n        <span class=\"hljs-function\"><span class=\"hljs-keyword\">protected</span> <span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-built_in\">int</span> <span class=\"hljs-title\">Query</span>(<span class=\"hljs-params\"><span class=\"hljs-built_in\">int</span> l, <span class=\"hljs-built_in\">int</span> r, <span class=\"hljs-built_in\">int</span> a, <span class=\"hljs-built_in\">int</span> b, <span class=\"hljs-built_in\">int</span> i</span>)</span>\n        {\n            <span class=\"hljs-comment\">// If a and b are in the (by l and r) specified subarray</span>\n            <span class=\"hljs-keyword\">if</span> (l &lt;= a &amp;&amp; b &lt;= r)\n            {\n                <span class=\"hljs-keyword\">return</span> Tree[i];\n            }\n\n            <span class=\"hljs-comment\">// If a or b are out of the by l and r specified subarray</span>\n            <span class=\"hljs-keyword\">if</span> (r &lt; a || b &lt; l)\n            {\n                <span class=\"hljs-comment\">// Returns the neutral value of the operation</span>\n                <span class=\"hljs-comment\">// (in this case 0, because x + 0 = x)</span>\n                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n            }\n\n            <span class=\"hljs-comment\">// Calculates index m of the node that cuts the current subarray in half</span>\n            <span class=\"hljs-keyword\">var</span> m = (a + b) / <span class=\"hljs-number\">2</span>;\n\n            <span class=\"hljs-comment\">// Start query of new two subarrays a:m and m+1:b</span>\n            <span class=\"hljs-comment\">// The right and left child cover this intervals</span>\n            <span class=\"hljs-keyword\">return</span> Query(l, r, a, m, Left(i)) + Query(l, r, m + <span class=\"hljs-number\">1</span>, b, Right(i));\n        }\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "lakhan_nad",
      "email": "lakhannad1999@gmail.com",
      "commits": 1
    },
    {
      "name": "fffzlfk",
      "email": "44939690+fffzlfk@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Anshul",
      "email": "malikanshul29@gmail.com",
      "commits": 1
    },
    {
      "name": "AlexDvorak",
      "email": "opti.jawsome@gmail.com",
      "commits": 1
    },
    {
      "name": "Antony",
      "email": "45163503+DuckNrOne@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "hugokung",
      "email": "49091849+hugokung@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Calebe Oliveira",
      "email": "30943380+calebeof@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "KanakalathaVemuru",
      "email": "46847239+KanakalathaVemuru@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "cclauss",
      "email": "cclauss@bluewin.ch",
      "commits": 1
    },
    {
      "name": "97arushisharma",
      "email": "97arushisharma@gmail.com",
      "commits": 1
    },
    {
      "name": "Sarot Busala",
      "email": "sabuza97@gmail.com",
      "commits": 1
    },
    {
      "name": "Andrii Siriak",
      "email": "siryaka@gmail.com",
      "commits": 2
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 3
    }
  ],
  "explanationUrl": {}
}