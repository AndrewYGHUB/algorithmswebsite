{
  "slug": "support-vector-machines",
  "name": "Support Vector Machines",
  "categories": [
    "machinelearning"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "machine_learning/support_vector_machines.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/machine_learning/support_vector_machines.py",
      "code": "<span class=\"hljs-keyword\">import</span> numpy <span class=\"hljs-keyword\">as</span> np\n<span class=\"hljs-keyword\">from</span> numpy <span class=\"hljs-keyword\">import</span> ndarray\n<span class=\"hljs-keyword\">from</span> scipy.optimize <span class=\"hljs-keyword\">import</span> Bounds, LinearConstraint, minimize\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">norm_squared</span>(<span class=\"hljs-params\">vector: ndarray</span>) -&gt; <span class=\"hljs-built_in\">float</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Return the squared second norm of vector\n    norm_squared(v) = sum(x * x for x in v)\n\n    Args:\n        vector (ndarray): input vector\n\n    Returns:\n        float: squared second norm of vector\n\n    &gt;&gt;&gt; norm_squared([1, 2])\n    5\n    &gt;&gt;&gt; norm_squared(np.asarray([1, 2]))\n    5\n    &gt;&gt;&gt; norm_squared([0, 0])\n    0\n    &quot;&quot;&quot;</span>\n    <span class=\"hljs-keyword\">return</span> np.dot(vector, vector)\n\n\n<span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">SVC</span>:\n    <span class=\"hljs-string\">&quot;&quot;&quot;\n    Support Vector Classifier\n\n    Args:\n        kernel (str): kernel to use. Default: linear\n            Possible choices:\n                - linear\n        regularization: constraint for soft margin (data not linearly separable)\n            Default: unbound\n\n    &gt;&gt;&gt; SVC(kernel=&quot;asdf&quot;)\n    Traceback (most recent call last):\n        ...\n    ValueError: Unknown kernel: asdf\n\n    &gt;&gt;&gt; SVC(kernel=&quot;rbf&quot;)\n    Traceback (most recent call last):\n        ...\n    ValueError: rbf kernel requires gamma\n\n    &gt;&gt;&gt; SVC(kernel=&quot;rbf&quot;, gamma=-1)\n    Traceback (most recent call last):\n        ...\n    ValueError: gamma must be &gt; 0\n    &quot;&quot;&quot;</span>\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__init__</span>(<span class=\"hljs-params\">\n        self,\n        *,\n        regularization: <span class=\"hljs-built_in\">float</span> = np.inf,\n        kernel: <span class=\"hljs-built_in\">str</span> = <span class=\"hljs-string\">&quot;linear&quot;</span>,\n        gamma: <span class=\"hljs-built_in\">float</span> = <span class=\"hljs-number\">0</span>,\n    </span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        self.regularization = regularization\n        self.gamma = gamma\n        <span class=\"hljs-keyword\">if</span> kernel == <span class=\"hljs-string\">&quot;linear&quot;</span>:\n            self.kernel = self.__linear\n        <span class=\"hljs-keyword\">elif</span> kernel == <span class=\"hljs-string\">&quot;rbf&quot;</span>:\n            <span class=\"hljs-keyword\">if</span> self.gamma == <span class=\"hljs-number\">0</span>:\n                <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&quot;rbf kernel requires gamma&quot;</span>)\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> (<span class=\"hljs-built_in\">isinstance</span>(self.gamma, <span class=\"hljs-built_in\">float</span>) <span class=\"hljs-keyword\">or</span> <span class=\"hljs-built_in\">isinstance</span>(self.gamma, <span class=\"hljs-built_in\">int</span>)):\n                <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&quot;gamma must be float or int&quot;</span>)\n            <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">not</span> self.gamma &gt; <span class=\"hljs-number\">0</span>:\n                <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">&quot;gamma must be &gt; 0&quot;</span>)\n            self.kernel = self.__rbf\n            <span class=\"hljs-comment\"># in the future, there could be a default value like in sklearn</span>\n            <span class=\"hljs-comment\"># sklear: def_gamma = 1/(n_features * X.var()) (wiki)</span>\n            <span class=\"hljs-comment\"># previously it was 1/(n_features)</span>\n        <span class=\"hljs-keyword\">else</span>:\n            <span class=\"hljs-keyword\">raise</span> ValueError(<span class=\"hljs-string\">f&quot;Unknown kernel: <span class=\"hljs-subst\">{kernel}</span>&quot;</span>)\n\n    <span class=\"hljs-comment\"># kernels</span>\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__linear</span>(<span class=\"hljs-params\">self, vector1: ndarray, vector2: ndarray</span>) -&gt; <span class=\"hljs-built_in\">float</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;Linear kernel (as if no kernel used at all)&quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">return</span> np.dot(vector1, vector2)\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">__rbf</span>(<span class=\"hljs-params\">self, vector1: ndarray, vector2: ndarray</span>) -&gt; <span class=\"hljs-built_in\">float</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        RBF: Radial Basis Function Kernel\n\n        Note: for more information see:\n            https://en.wikipedia.org/wiki/Radial_basis_function_kernel\n\n        Args:\n            vector1 (ndarray): first vector\n            vector2 (ndarray): second vector)\n\n        Returns:\n            float: exp(-(gamma * norm_squared(vector1 - vector2)))\n        &quot;&quot;&quot;</span>\n        <span class=\"hljs-keyword\">return</span> np.exp(-(self.gamma * norm_squared(vector1 - vector2)))\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">fit</span>(<span class=\"hljs-params\">self, observations: <span class=\"hljs-built_in\">list</span>[ndarray], classes: ndarray</span>) -&gt; <span class=\"hljs-literal\">None</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        Fits the SVC with a set of observations.\n\n        Args:\n            observations (list[ndarray]): list of observations\n            classes (ndarray): classification of each observation (in {1, -1})\n        &quot;&quot;&quot;</span>\n\n        self.observations = observations\n        self.classes = classes\n\n        <span class=\"hljs-comment\"># using Wolfe&#x27;s Dual to calculate w.</span>\n        <span class=\"hljs-comment\"># Primal problem: minimize 1/2*norm_squared(w)</span>\n        <span class=\"hljs-comment\">#   constraint: yn(w . xn + b) &gt;= 1</span>\n        <span class=\"hljs-comment\">#</span>\n        <span class=\"hljs-comment\"># With l a vector</span>\n        <span class=\"hljs-comment\"># Dual problem: maximize sum_n(ln) -</span>\n        <span class=\"hljs-comment\">#       1/2 * sum_n(sum_m(ln*lm*yn*ym*xn . xm))</span>\n        <span class=\"hljs-comment\">#   constraint: self.C &gt;= ln &gt;= 0</span>\n        <span class=\"hljs-comment\">#           and sum_n(ln*yn) = 0</span>\n        <span class=\"hljs-comment\"># Then we get w using w = sum_n(ln*yn*xn)</span>\n        <span class=\"hljs-comment\"># At the end we can get b ~= mean(yn - w . xn)</span>\n        <span class=\"hljs-comment\">#</span>\n        <span class=\"hljs-comment\"># Since we use kernels, we only need l_star to calculate b</span>\n        <span class=\"hljs-comment\"># and to classify observations</span>\n\n        (n,) = np.shape(classes)\n\n        <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">to_minimize</span>(<span class=\"hljs-params\">candidate: ndarray</span>) -&gt; <span class=\"hljs-built_in\">float</span>:\n            <span class=\"hljs-string\">&quot;&quot;&quot;\n            Opposite of the function to maximize\n\n            Args:\n                candidate (ndarray): candidate array to test\n\n            Return:\n                float: Wolfe&#x27;s Dual result to minimize\n            &quot;&quot;&quot;</span>\n            s = <span class=\"hljs-number\">0</span>\n            (n,) = np.shape(candidate)\n            <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):\n                <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):\n                    s += (\n                        candidate[i]\n                        * candidate[j]\n                        * classes[i]\n                        * classes[j]\n                        * self.kernel(observations[i], observations[j])\n                    )\n            <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span> / <span class=\"hljs-number\">2</span> * s - <span class=\"hljs-built_in\">sum</span>(candidate)\n\n        ly_contraint = LinearConstraint(classes, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>)\n        l_bounds = Bounds(<span class=\"hljs-number\">0</span>, self.regularization)\n\n        l_star = minimize(\n            to_minimize, np.ones(n), bounds=l_bounds, constraints=[ly_contraint]\n        ).x\n        self.optimum = l_star\n\n        <span class=\"hljs-comment\"># calculating mean offset of separation plane to points</span>\n        s = <span class=\"hljs-number\">0</span>\n        <span class=\"hljs-keyword\">for</span> i <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):\n            <span class=\"hljs-keyword\">for</span> j <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(n):\n                s += classes[i] - classes[i] * self.optimum[i] * self.kernel(\n                    observations[i], observations[j]\n                )\n        self.offset = s / n\n\n    <span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">predict</span>(<span class=\"hljs-params\">self, observation: ndarray</span>) -&gt; <span class=\"hljs-built_in\">int</span>:\n        <span class=\"hljs-string\">&quot;&quot;&quot;\n        Get the expected class of an observation\n\n        Args:\n            observation (Vector): observation\n\n        Returns:\n            int {1, -1}: expected class\n\n        &gt;&gt;&gt; xs = [\n        ...     np.asarray([0, 1]), np.asarray([0, 2]),\n        ...     np.asarray([1, 1]), np.asarray([1, 2])\n        ... ]\n        &gt;&gt;&gt; y = np.asarray([1, 1, -1, -1])\n        &gt;&gt;&gt; s = SVC()\n        &gt;&gt;&gt; s.fit(xs, y)\n        &gt;&gt;&gt; s.predict(np.asarray([0, 1]))\n        1\n        &gt;&gt;&gt; s.predict(np.asarray([1, 1]))\n        -1\n        &gt;&gt;&gt; s.predict(np.asarray([2, 2]))\n        -1\n        &quot;&quot;&quot;</span>\n        s = <span class=\"hljs-built_in\">sum</span>(\n            self.optimum[n]\n            * self.classes[n]\n            * self.kernel(self.observations[n], observation)\n            <span class=\"hljs-keyword\">for</span> n <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-built_in\">len</span>(self.classes))\n        )\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">if</span> s + self.offset &gt;= <span class=\"hljs-number\">0</span> <span class=\"hljs-keyword\">else</span> -<span class=\"hljs-number\">1</span>\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    <span class=\"hljs-keyword\">import</span> doctest\n\n    doctest.testmod()\n"
    }
  },
  "contributors": [
    {
      "name": "QuantumNovice",
      "email": "43876848+QuantumNovice@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Todor Peev",
      "email": "46652070+Bjiornulf@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 3
    }
  ],
  "explanationUrl": {}
}