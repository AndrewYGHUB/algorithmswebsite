{
  "slug": "topological-sort",
  "name": "Topological Sort",
  "categories": [
    "sorts"
  ],
  "body": {},
  "implementations": {
    "python": {
      "dir": "sorts/topological_sort.py",
      "url": "https://github.com/TheAlgorithms/python/tree/master/sorts/topological_sort.py",
      "code": "<span class=\"hljs-string\">&quot;&quot;&quot;Topological Sort.&quot;&quot;&quot;</span>\n\n<span class=\"hljs-comment\">#     a</span>\n<span class=\"hljs-comment\">#    / \\</span>\n<span class=\"hljs-comment\">#   b  c</span>\n<span class=\"hljs-comment\">#  / \\</span>\n<span class=\"hljs-comment\"># d  e</span>\nedges = {<span class=\"hljs-string\">&quot;a&quot;</span>: [<span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-string\">&quot;b&quot;</span>], <span class=\"hljs-string\">&quot;b&quot;</span>: [<span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-string\">&quot;e&quot;</span>], <span class=\"hljs-string\">&quot;c&quot;</span>: [], <span class=\"hljs-string\">&quot;d&quot;</span>: [], <span class=\"hljs-string\">&quot;e&quot;</span>: []}\nvertices = [<span class=\"hljs-string\">&quot;a&quot;</span>, <span class=\"hljs-string\">&quot;b&quot;</span>, <span class=\"hljs-string\">&quot;c&quot;</span>, <span class=\"hljs-string\">&quot;d&quot;</span>, <span class=\"hljs-string\">&quot;e&quot;</span>]\n\n\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">topological_sort</span>(<span class=\"hljs-params\">start, visited, sort</span>):\n    <span class=\"hljs-string\">&quot;&quot;&quot;Perform topological sort on a directed acyclic graph.&quot;&quot;&quot;</span>\n    current = start\n    <span class=\"hljs-comment\"># add current to visited</span>\n    visited.append(current)\n    neighbors = edges[current]\n    <span class=\"hljs-keyword\">for</span> neighbor <span class=\"hljs-keyword\">in</span> neighbors:\n        <span class=\"hljs-comment\"># if neighbor not in visited, visit</span>\n        <span class=\"hljs-keyword\">if</span> neighbor <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> visited:\n            sort = topological_sort(neighbor, visited, sort)\n    <span class=\"hljs-comment\"># if all neighbors visited add current to sort</span>\n    sort.append(current)\n    <span class=\"hljs-comment\"># if all vertices haven&#x27;t been visited select a new one to visit</span>\n    <span class=\"hljs-keyword\">if</span> <span class=\"hljs-built_in\">len</span>(visited) != <span class=\"hljs-built_in\">len</span>(vertices):\n        <span class=\"hljs-keyword\">for</span> vertice <span class=\"hljs-keyword\">in</span> vertices:\n            <span class=\"hljs-keyword\">if</span> vertice <span class=\"hljs-keyword\">not</span> <span class=\"hljs-keyword\">in</span> visited:\n                sort = topological_sort(vertice, visited, sort)\n    <span class=\"hljs-comment\"># return sort</span>\n    <span class=\"hljs-keyword\">return</span> sort\n\n\n<span class=\"hljs-keyword\">if</span> __name__ == <span class=\"hljs-string\">&quot;__main__&quot;</span>:\n    sort = topological_sort(<span class=\"hljs-string\">&quot;a&quot;</span>, [], [])\n    <span class=\"hljs-built_in\">print</span>(sort)\n"
    },
    "javascript": {
      "dir": "Sorts/TopologicalSort.js",
      "url": "https://github.com/TheAlgorithms/javascript/tree/master/Sorts/TopologicalSort.js",
      "code": "\n<span class=\"hljs-keyword\">export</span> <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">TopologicalSorter</span> () {\n  <span class=\"hljs-keyword\">const</span> graph = {}\n  <span class=\"hljs-keyword\">let</span> isVisitedNode\n  <span class=\"hljs-keyword\">let</span> finishTimeCount\n  <span class=\"hljs-keyword\">let</span> finishingTimeList\n  <span class=\"hljs-keyword\">let</span> nextNode\n\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">addOrder</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">nodeA, nodeB</span>) {\n    nodeA = <span class=\"hljs-title class_\">String</span>(nodeA)\n    nodeB = <span class=\"hljs-title class_\">String</span>(nodeB)\n    graph[nodeA] = graph[nodeA] || []\n    graph[nodeA].<span class=\"hljs-title function_\">push</span>(nodeB)\n  }\n\n  <span class=\"hljs-variable language_\">this</span>.<span class=\"hljs-property\">sortAndGetOrderedItems</span> = <span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\"></span>) {\n    isVisitedNode = <span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-title function_\">create</span>(<span class=\"hljs-literal\">null</span>)\n    finishTimeCount = <span class=\"hljs-number\">0</span>\n    finishingTimeList = []\n\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">const</span> node <span class=\"hljs-keyword\">in</span> graph) {\n      <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-title class_\">Object</span>.<span class=\"hljs-property\"><span class=\"hljs-keyword\">prototype</span></span>.<span class=\"hljs-property\">hasOwnProperty</span>.<span class=\"hljs-title function_\">call</span>(graph, node) &amp;&amp; !isVisitedNode[node]) {\n        <span class=\"hljs-title function_\">dfsTraverse</span>(node)\n      }\n    }\n\n    finishingTimeList.<span class=\"hljs-title function_\">sort</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">item1, item2</span>) {\n      <span class=\"hljs-keyword\">return</span> item1.<span class=\"hljs-property\">finishTime</span> &gt; item2.<span class=\"hljs-property\">finishTime</span> ? -<span class=\"hljs-number\">1</span> : <span class=\"hljs-number\">1</span>\n    })\n\n    <span class=\"hljs-keyword\">return</span> finishingTimeList.<span class=\"hljs-title function_\">map</span>(<span class=\"hljs-keyword\">function</span> (<span class=\"hljs-params\">value</span>) { <span class=\"hljs-keyword\">return</span> value.<span class=\"hljs-property\">node</span> })\n  }\n\n  <span class=\"hljs-keyword\">function</span> <span class=\"hljs-title function_\">dfsTraverse</span> (node) {\n    isVisitedNode[node] = <span class=\"hljs-literal\">true</span>\n    <span class=\"hljs-keyword\">if</span> (graph[node]) {\n      <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">let</span> i = <span class=\"hljs-number\">0</span>; i &lt; graph[node].<span class=\"hljs-property\">length</span>; i++) {\n        nextNode = graph[node][i]\n        <span class=\"hljs-keyword\">if</span> (isVisitedNode[nextNode]) <span class=\"hljs-keyword\">continue</span>\n        <span class=\"hljs-title function_\">dfsTraverse</span>(nextNode)\n      }\n    }\n\n    finishingTimeList.<span class=\"hljs-title function_\">push</span>({\n      node,\n      <span class=\"hljs-attr\">finishTime</span>: ++finishTimeCount\n    })\n  }\n}\n\n<span class=\"hljs-comment\">/* TEST */</span>\n<span class=\"hljs-comment\">// const topoSorter = new TopologicalSorter()</span>\n<span class=\"hljs-comment\">// topoSorter.addOrder(5, 2)</span>\n<span class=\"hljs-comment\">// topoSorter.addOrder(5, 0)</span>\n<span class=\"hljs-comment\">// topoSorter.addOrder(4, 0)</span>\n<span class=\"hljs-comment\">// topoSorter.addOrder(4, 1)</span>\n<span class=\"hljs-comment\">// topoSorter.addOrder(2, 3)</span>\n<span class=\"hljs-comment\">// topoSorter.addOrder(3, 1)</span>\n<span class=\"hljs-comment\">// topoSorter.sortAndGetOrderedItems()</span>\n"
    },
    "c-plus-plus": {
      "dir": "graph/topological_sort.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/graph/topological_sort.cpp",
      "code": "<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span>\n\n<span class=\"hljs-type\">int</span> number_of_vertices,\n    number_of_edges;  <span class=\"hljs-comment\">// For number of Vertices (V) and number of edges (E)</span>\nstd::vector&lt;std::vector&lt;<span class=\"hljs-type\">int</span>&gt;&gt; graph;\nstd::vector&lt;<span class=\"hljs-type\">bool</span>&gt; visited;\nstd::vector&lt;<span class=\"hljs-type\">int</span>&gt; topological_order;\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> v)</span> </span>{\n    visited[v] = <span class=\"hljs-literal\">true</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> u : graph[v]) {\n        <span class=\"hljs-keyword\">if</span> (!visited[u]) {\n            <span class=\"hljs-built_in\">dfs</span>(u);\n        }\n    }\n    topological_order.<span class=\"hljs-built_in\">push_back</span>(v);\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">topological_sort</span><span class=\"hljs-params\">()</span> </span>{\n    visited.<span class=\"hljs-built_in\">assign</span>(number_of_vertices, <span class=\"hljs-literal\">false</span>);\n    topological_order.<span class=\"hljs-built_in\">clear</span>();\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; number_of_vertices; ++i) {\n        <span class=\"hljs-keyword\">if</span> (!visited[i]) {\n            <span class=\"hljs-built_in\">dfs</span>(i);\n        }\n    }\n    <span class=\"hljs-built_in\">reverse</span>(topological_order.<span class=\"hljs-built_in\">begin</span>(), topological_order.<span class=\"hljs-built_in\">end</span>());\n}\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout\n        &lt;&lt; <span class=\"hljs-string\">&quot;Enter the number of vertices and the number of directed edges\\n&quot;</span>;\n    std::cin &gt;&gt; number_of_vertices &gt;&gt; number_of_edges;\n    <span class=\"hljs-type\">int</span> x = <span class=\"hljs-number\">0</span>, y = <span class=\"hljs-number\">0</span>;\n    graph.<span class=\"hljs-built_in\">resize</span>(number_of_vertices, std::<span class=\"hljs-built_in\">vector</span>&lt;<span class=\"hljs-type\">int</span>&gt;());\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; number_of_edges; ++i) {\n        std::cin &gt;&gt; x &gt;&gt; y;\n        x--, y--;  <span class=\"hljs-comment\">// to convert 1-indexed to 0-indexed</span>\n        graph[x].<span class=\"hljs-built_in\">push_back</span>(y);\n    }\n    <span class=\"hljs-built_in\">topological_sort</span>();\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Topological Order : \\n&quot;</span>;\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> v : topological_order) {\n        std::cout &lt;&lt; v + <span class=\"hljs-number\">1</span>\n                  &lt;&lt; <span class=\"hljs-string\">&#x27; &#x27;</span>;  <span class=\"hljs-comment\">// converting zero based indexing back to one based.</span>\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&#x27;\\n&#x27;</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    },
    "java": {
      "dir": "src/main/java/com/thealgorithms/sorts/TopologicalSort.java",
      "url": "https://github.com/TheAlgorithms/java/tree/master/src/main/java/com/thealgorithms/sorts/TopologicalSort.java",
      "code": "<span class=\"hljs-keyword\">package</span> com.thealgorithms.sorts;\n\n<span class=\"hljs-keyword\">import</span> java.util.*;\n\n<span class=\"hljs-comment\">/**\n * The Topological Sorting algorithm linearly orders a DAG or Directed Acyclic Graph into\n * a linked list. A Directed Graph is proven to be acyclic when a DFS or Depth First Search is\n * performed, yielding no back-edges.\n *\n * https://en.wikipedia.org/wiki/Topological_sorting\n *\n * <span class=\"hljs-doctag\">@author</span> Jonathan Taylor (https://github.com/Jtmonument)\n * Based on Introduction to Algorithms 3rd Edition\n */</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">TopologicalSort</span> {\n\n     <span class=\"hljs-comment\">/*\n     * Enum to represent the colors for the depth first search\n     * */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title class_\">Color</span> {\n        WHITE, GRAY, BLACK\n    }\n\n     <span class=\"hljs-comment\">/*\n     * Class to represent vertices\n     * */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Vertex</span> {\n        <span class=\"hljs-comment\">/*\n        * Name of vertex\n        * */</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> String label;\n\n        <span class=\"hljs-comment\">/*\n        * Weight of vertex\n        * (more accurately defined as the time that a vertex has begun a visit in DFS)\n        * */</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> weight;\n\n        <span class=\"hljs-comment\">/*\n        * The time that the vertex has finished a visit in DFS\n        * */</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">int</span> finished;\n\n        <span class=\"hljs-comment\">/*\n        * π parent of the vertex\n        * */</span>\n        <span class=\"hljs-keyword\">public</span> Vertex predecessor;\n\n        <span class=\"hljs-comment\">/*\n        * Represents the category of visit in DFS\n        * */</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-type\">Color</span> <span class=\"hljs-variable\">color</span> <span class=\"hljs-operator\">=</span> Color.WHITE;\n\n        <span class=\"hljs-comment\">/*\n        * The array of names of descendant vertices\n        * */</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">final</span> ArrayList&lt;String&gt; next = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">ArrayList</span>&lt;&gt;();\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">Vertex</span><span class=\"hljs-params\">(String label)</span> {\n            <span class=\"hljs-built_in\">this</span>.label = label;\n        }\n     }\n\n     <span class=\"hljs-comment\">/*\n     * Graph class uses the adjacency list representation\n     * */</span>\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Graph</span> {\n\n        <span class=\"hljs-comment\">/*\n         * Adjacency list representation\n         * */</span>\n        <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">final</span> HashMap&lt;String, Vertex&gt; adj = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedHashMap</span>&lt;&gt;();\n\n        <span class=\"hljs-comment\">/*\n         * Function to add an edge to the graph\n         * */</span>\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title function_\">addEdge</span><span class=\"hljs-params\">(String label, String... next)</span> {\n            adj.put(label, <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">Vertex</span>(label));\n            <span class=\"hljs-keyword\">if</span> (!next[<span class=\"hljs-number\">0</span>].isEmpty())\n                Collections.addAll(adj.get(label).next, next);\n        }\n    }\n\n    <span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">BackEdgeException</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title class_\">RuntimeException</span> {\n\n        <span class=\"hljs-keyword\">public</span> <span class=\"hljs-title function_\">BackEdgeException</span><span class=\"hljs-params\">(String backEdge)</span> {\n            <span class=\"hljs-built_in\">super</span>(<span class=\"hljs-string\">&quot;This graph contains a cycle. No linear ordering is possible. &quot;</span> + backEdge);\n        }\n\n    }\n\n    <span class=\"hljs-comment\">/*\n     * Time variable in DFS\n     * */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> <span class=\"hljs-type\">int</span> time;\n\n    <span class=\"hljs-comment\">/*\n     * Depth First Search\n     *\n     * DFS(G)\n     *   for each vertex u ∈ G.V\n     *       u.color = WHITE\n     *       u.π = NIL\n     *   time = 0\n     *   for each vertex u ∈ G.V\n     *   if u.color == WHITE\n     *       DFS-VISIT(G, u)\n     *\n     * Performed in Θ(V + E) time\n     * */</span>\n    <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">static</span> LinkedList&lt;String&gt; <span class=\"hljs-title function_\">sort</span><span class=\"hljs-params\">(Graph graph)</span> {\n        LinkedList&lt;String&gt; list = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">LinkedList</span>&lt;&gt;();\n        graph.adj.forEach((name, vertex) -&gt; {\n            <span class=\"hljs-keyword\">if</span> (vertex.color == Color.WHITE) {\n                list.addFirst(sort(graph, vertex, list));\n            }\n        });\n        <span class=\"hljs-keyword\">return</span> list;\n    }\n\n    <span class=\"hljs-comment\">/*\n     * Depth First Search Visit\n     *\n     * DFS-Visit(G, u)\n     *   time = time + 1\n     *   u.d = time\n     *   u.color = GRAY\n     *   for each v ∈ G.Adj[u]\n     *       if v.color == WHITE\n     *           v.π = u\n     *           DFS-Visit(G, u)\n     *   u.color = BLACK\n     *   time = time + 1\n     *   u.f = time\n     * */</span>\n    <span class=\"hljs-keyword\">private</span> <span class=\"hljs-keyword\">static</span> String <span class=\"hljs-title function_\">sort</span><span class=\"hljs-params\">(Graph graph, Vertex u, LinkedList&lt;String&gt; list)</span> {\n        time++;\n        u.weight = time;\n        u.color = Color.GRAY;\n        graph.adj.get(u.label).next.forEach(label -&gt; {\n            <span class=\"hljs-keyword\">if</span> (graph.adj.get(label).color == Color.WHITE) {\n                graph.adj.get(label).predecessor = u;\n                list.addFirst(sort(graph, graph.adj.get(label), list));\n            } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (graph.adj.get(label).color == Color.GRAY) {\n                <span class=\"hljs-comment\">/*\n                 * A back edge exists if an edge (u, v) connects a vertex u to its ancestor vertex v\n                 * in a depth first tree. If v.d ≤ u.d &lt; u.f ≤ v.f\n                 *\n                 * In many cases, we will not know u.f, but v.color denotes the type of edge\n                 * */</span>\n                <span class=\"hljs-keyword\">throw</span> <span class=\"hljs-keyword\">new</span> <span class=\"hljs-title class_\">BackEdgeException</span>(<span class=\"hljs-string\">&quot;Back edge: &quot;</span> + u.label + <span class=\"hljs-string\">&quot; -&gt; &quot;</span> + label);\n            }\n        });\n        u.color = Color.BLACK;\n        time++;\n        u.finished = time;\n        <span class=\"hljs-keyword\">return</span> u.label;\n    }\n}\n\n"
    },
    "c": {
      "dir": "data_structures/graphs/topological_sort.c",
      "url": "https://github.com/TheAlgorithms/c/tree/master/data_structures/graphs/topological_sort.c",
      "code": "<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> MAX_SIZE 40  <span class=\"hljs-comment\">// Assume 40 nodes at max in graph</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> INT_MIN 0</span>\n<span class=\"hljs-comment\">// A vertex of the graph</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">node</span>\n{</span>\n    <span class=\"hljs-type\">int</span> vertex;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">node</span> *<span class=\"hljs-title\">next</span>;</span>\n};\n<span class=\"hljs-comment\">// Some declarations</span>\n<span class=\"hljs-keyword\">struct</span> node *<span class=\"hljs-title function_\">createNode</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> v)</span>;\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Graph</span>\n{</span>\n    <span class=\"hljs-type\">int</span> numVertices;\n    <span class=\"hljs-type\">int</span> *visited;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">node</span> *\n        *<span class=\"hljs-title\">adjLists</span>;</span>  <span class=\"hljs-comment\">// we need int** to store a two dimensional array. Similary,</span>\n                    <span class=\"hljs-comment\">// we need struct node** to store an array of Linked lists</span>\n};\n<span class=\"hljs-comment\">// Structure to create a stack, necessary for topological sorting</span>\n<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Stack</span>\n{</span>\n    <span class=\"hljs-type\">int</span> arr[MAX_SIZE];\n    <span class=\"hljs-type\">int</span> top;\n};\n<span class=\"hljs-keyword\">struct</span> Graph *<span class=\"hljs-title function_\">createGraph</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>)</span>;\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Graph *, <span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">int</span>)</span>;\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">printGraph</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Graph *)</span>;\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">topologicalSortHelper</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>, <span class=\"hljs-keyword\">struct</span> Graph *, <span class=\"hljs-keyword\">struct</span> Stack *)</span>;\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">topologicalSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Graph *)</span>;\n<span class=\"hljs-keyword\">struct</span> Stack *<span class=\"hljs-title function_\">createStack</span><span class=\"hljs-params\">()</span>;\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">push</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Stack *, <span class=\"hljs-type\">int</span>)</span>;\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">pop</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Stack *)</span>;\n\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">()</span>\n{\n    <span class=\"hljs-type\">int</span> vertices, edges, i, src, dst;\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter the number of vertices\\n&quot;</span>);\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;vertices);\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Graph</span> *<span class=\"hljs-title\">graph</span> =</span> createGraph(vertices);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter the number of edges\\n&quot;</span>);\n    <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;edges);\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; edges; i++)\n    {\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Edge %d \\nEnter source: &quot;</span>, i + <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;src);\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter destination: &quot;</span>);\n        <span class=\"hljs-built_in\">scanf</span>(<span class=\"hljs-string\">&quot;%d&quot;</span>, &amp;dst);\n        addEdge(graph, src, dst);\n    }\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;One topological sort order is:\\n&quot;</span>);\n    topologicalSort(graph);\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);\n\n    <span class=\"hljs-comment\">// Uncomment below part to get a ready-made example</span>\n    <span class=\"hljs-comment\">/*struct Graph* graph2 = createGraph(4);\n    addEdge(graph2, 0, 1);\n    addEdge(graph2, 0, 2);\n    addEdge(graph2, 1, 2);\n    addEdge(graph2, 2, 3);\n    printf(&quot;One topological sort is:\\n&quot;);\n    topologicalSort(graph2);\n    printf(&quot;\\n&quot;);*/</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">topologicalSortHelper</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> vertex, <span class=\"hljs-keyword\">struct</span> Graph *graph, <span class=\"hljs-keyword\">struct</span> Stack *<span class=\"hljs-built_in\">stack</span>)</span>\n{\n    graph-&gt;visited[vertex] = <span class=\"hljs-number\">1</span>;\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">node</span> *<span class=\"hljs-title\">adjList</span> =</span> graph-&gt;adjLists[vertex];\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">node</span> *<span class=\"hljs-title\">temp</span> =</span> adjList;\n    <span class=\"hljs-comment\">// First add all dependents (that is, children) to stack</span>\n    <span class=\"hljs-keyword\">while</span> (temp != <span class=\"hljs-literal\">NULL</span>)\n    {\n        <span class=\"hljs-type\">int</span> connectedVertex = temp-&gt;vertex;\n        <span class=\"hljs-keyword\">if</span> (graph-&gt;visited[connectedVertex] == <span class=\"hljs-number\">0</span>)\n        {\n            topologicalSortHelper(connectedVertex, graph, <span class=\"hljs-built_in\">stack</span>);\n        }\n        temp = temp-&gt;next;\n    }\n    <span class=\"hljs-comment\">// and then add itself</span>\n    push(<span class=\"hljs-built_in\">stack</span>, vertex);\n}\n\n<span class=\"hljs-comment\">// Recursive topologial sort approach</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">topologicalSort</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Graph *graph)</span>\n{\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Stack</span> *<span class=\"hljs-title\">stack</span> =</span> createStack();\n    <span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>;\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; graph-&gt;numVertices; i++)\n    {\n        <span class=\"hljs-comment\">// Execute topological sort on all elements</span>\n        <span class=\"hljs-keyword\">if</span> (graph-&gt;visited[i] == <span class=\"hljs-number\">0</span>)\n        {\n            topologicalSortHelper(i, graph, <span class=\"hljs-built_in\">stack</span>);\n        }\n    }\n    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">stack</span>-&gt;top != <span class=\"hljs-number\">-1</span>) <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d &quot;</span>, pop(<span class=\"hljs-built_in\">stack</span>));\n}\n<span class=\"hljs-comment\">// Allocate memory for a node</span>\n<span class=\"hljs-keyword\">struct</span> node *<span class=\"hljs-title function_\">createNode</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> v)</span>\n{\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">node</span> *<span class=\"hljs-title\">newNode</span> =</span> <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> node));\n    newNode-&gt;vertex = v;\n    newNode-&gt;next = <span class=\"hljs-literal\">NULL</span>;\n    <span class=\"hljs-keyword\">return</span> newNode;\n}\n<span class=\"hljs-comment\">// Allocate memory for the entire graph structure</span>\n<span class=\"hljs-keyword\">struct</span> Graph *<span class=\"hljs-title function_\">createGraph</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> vertices)</span>\n{\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Graph</span> *<span class=\"hljs-title\">graph</span> =</span> <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> Graph));\n    graph-&gt;numVertices = vertices;\n    graph-&gt;adjLists = <span class=\"hljs-built_in\">malloc</span>(vertices * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> node *));\n    graph-&gt;visited = <span class=\"hljs-built_in\">malloc</span>(vertices * <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">int</span>));\n\n    <span class=\"hljs-type\">int</span> i;\n    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; vertices; i++)\n    {\n        graph-&gt;adjLists[i] = <span class=\"hljs-literal\">NULL</span>;\n        graph-&gt;visited[i] = <span class=\"hljs-number\">0</span>;\n    }\n    <span class=\"hljs-keyword\">return</span> graph;\n}\n<span class=\"hljs-comment\">// Creates a unidirectional graph</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">addEdge</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Graph *graph, <span class=\"hljs-type\">int</span> src, <span class=\"hljs-type\">int</span> dest)</span>\n{\n    <span class=\"hljs-comment\">// Add edge from src to dest</span>\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">node</span> *<span class=\"hljs-title\">newNode</span> =</span> createNode(dest);\n    newNode-&gt;next = graph-&gt;adjLists[src];\n    graph-&gt;adjLists[src] = newNode;\n}\n<span class=\"hljs-comment\">// Utility function to see state of graph at a given time</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">printGraph</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Graph *graph)</span>\n{\n    <span class=\"hljs-type\">int</span> v;\n    <span class=\"hljs-keyword\">for</span> (v = <span class=\"hljs-number\">0</span>; v &lt; graph-&gt;numVertices; v++)\n    {\n        <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">node</span> *<span class=\"hljs-title\">temp</span> =</span> graph-&gt;adjLists[v];\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n Adjacency list of vertex %d\\n &quot;</span>, v);\n        <span class=\"hljs-keyword\">while</span> (temp)\n        {\n            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%d -&gt; &quot;</span>, temp-&gt;vertex);\n            temp = temp-&gt;next;\n        }\n        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\n&quot;</span>);\n    }\n}\n<span class=\"hljs-comment\">// Creates a stack</span>\n<span class=\"hljs-keyword\">struct</span> Stack *<span class=\"hljs-title function_\">createStack</span><span class=\"hljs-params\">()</span>\n{\n    <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">Stack</span> *<span class=\"hljs-title\">stack</span> =</span> <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> Stack));\n    <span class=\"hljs-built_in\">stack</span>-&gt;top = <span class=\"hljs-number\">-1</span>;\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">stack</span>;\n}\n<span class=\"hljs-comment\">// Pushes element into stack</span>\n<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">push</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Stack *<span class=\"hljs-built_in\">stack</span>, <span class=\"hljs-type\">int</span> element)</span>\n{\n    <span class=\"hljs-built_in\">stack</span>-&gt;arr[++<span class=\"hljs-built_in\">stack</span>-&gt;top] =\n        element;  <span class=\"hljs-comment\">// Increment then add, as we start from -1</span>\n}\n<span class=\"hljs-comment\">// Removes element from stack, or returns INT_MIN if stack empty</span>\n<span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">pop</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> Stack *<span class=\"hljs-built_in\">stack</span>)</span>\n{\n    <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">stack</span>-&gt;top == <span class=\"hljs-number\">-1</span>)\n        <span class=\"hljs-keyword\">return</span> INT_MIN;\n    <span class=\"hljs-keyword\">else</span>\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">stack</span>-&gt;arr[<span class=\"hljs-built_in\">stack</span>-&gt;top--];\n}\n"
    },
    "rust": {
      "dir": "src/graph/topological_sort.rs",
      "url": "https://github.com/TheAlgorithms/rust/tree/master/src/graph/topological_sort.rs",
      "code": "<span class=\"hljs-keyword\">use</span> std::collections::{BTreeMap, VecDeque};\n\n<span class=\"hljs-keyword\">type</span> <span class=\"hljs-title class_\">Graph</span>&lt;V, E&gt; = BTreeMap&lt;V, <span class=\"hljs-type\">Vec</span>&lt;(V, E)&gt;&gt;;\n\n<span class=\"hljs-comment\">/// returns topological sort of the graph using Kahn&#x27;s algorithm</span>\n<span class=\"hljs-keyword\">pub</span> <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">topological_sort</span>&lt;V: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span>, E: <span class=\"hljs-built_in\">Ord</span>&gt;(graph: &amp;Graph&lt;V, E&gt;) <span class=\"hljs-punctuation\">-&gt;</span> <span class=\"hljs-type\">Vec</span>&lt;V&gt; {\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">visited</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">degree</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n    <span class=\"hljs-keyword\">for</span> <span class=\"hljs-variable\">u</span> <span class=\"hljs-keyword\">in</span> graph.<span class=\"hljs-title function_ invoke__\">keys</span>() {\n        degree.<span class=\"hljs-title function_ invoke__\">insert</span>(*u, <span class=\"hljs-number\">0</span>);\n        <span class=\"hljs-title function_ invoke__\">for</span> (v, _) <span class=\"hljs-keyword\">in</span> graph.<span class=\"hljs-title function_ invoke__\">get</span>(u).<span class=\"hljs-title function_ invoke__\">unwrap</span>() {\n            <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">entry</span> = degree.<span class=\"hljs-title function_ invoke__\">entry</span>(*v).<span class=\"hljs-title function_ invoke__\">or_insert</span>(<span class=\"hljs-number\">0</span>);\n            *entry += <span class=\"hljs-number\">1</span>;\n        }\n    }\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">queue</span> = VecDeque::<span class=\"hljs-title function_ invoke__\">new</span>();\n    <span class=\"hljs-title function_ invoke__\">for</span> (u, d) <span class=\"hljs-keyword\">in</span> degree.<span class=\"hljs-title function_ invoke__\">iter</span>() {\n        <span class=\"hljs-keyword\">if</span> *d == <span class=\"hljs-number\">0</span> {\n            queue.<span class=\"hljs-title function_ invoke__\">push_back</span>(*u);\n            visited.<span class=\"hljs-title function_ invoke__\">insert</span>(*u, <span class=\"hljs-literal\">true</span>);\n        }\n    }\n    <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">ret</span> = Vec::<span class=\"hljs-title function_ invoke__\">new</span>();\n    <span class=\"hljs-keyword\">while</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">Some</span>(u) = queue.<span class=\"hljs-title function_ invoke__\">pop_front</span>() {\n        ret.<span class=\"hljs-title function_ invoke__\">push</span>(u);\n        <span class=\"hljs-keyword\">if</span> <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">Some</span>(from_u) = graph.<span class=\"hljs-title function_ invoke__\">get</span>(&amp;u) {\n            <span class=\"hljs-title function_ invoke__\">for</span> (v, _) <span class=\"hljs-keyword\">in</span> from_u {\n                *degree.<span class=\"hljs-title function_ invoke__\">get_mut</span>(v).<span class=\"hljs-title function_ invoke__\">unwrap</span>() -= <span class=\"hljs-number\">1</span>;\n                <span class=\"hljs-keyword\">if</span> *degree.<span class=\"hljs-title function_ invoke__\">get</span>(v).<span class=\"hljs-title function_ invoke__\">unwrap</span>() == <span class=\"hljs-number\">0</span> {\n                    queue.<span class=\"hljs-title function_ invoke__\">push_back</span>(*v);\n                    visited.<span class=\"hljs-title function_ invoke__\">insert</span>(*v, <span class=\"hljs-literal\">true</span>);\n                }\n            }\n        }\n    }\n    ret\n}\n\n<span class=\"hljs-meta\">#[cfg(test)]</span>\n<span class=\"hljs-keyword\">mod</span> tests {\n    <span class=\"hljs-keyword\">use</span> std::collections::BTreeMap;\n\n    <span class=\"hljs-keyword\">use</span> super::{topological_sort, Graph};\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">add_edge</span>&lt;V: <span class=\"hljs-built_in\">Ord</span> + <span class=\"hljs-built_in\">Copy</span>, E: <span class=\"hljs-built_in\">Ord</span>&gt;(graph: &amp;<span class=\"hljs-keyword\">mut</span> Graph&lt;V, E&gt;, from: V, to: V, weight: E) {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-variable\">edges</span> = graph.<span class=\"hljs-title function_ invoke__\">entry</span>(from).<span class=\"hljs-title function_ invoke__\">or_insert</span>(Vec::<span class=\"hljs-title function_ invoke__\">new</span>());\n        edges.<span class=\"hljs-title function_ invoke__\">push</span>((to, weight));\n    }\n\n    <span class=\"hljs-meta\">#[test]</span>\n    <span class=\"hljs-keyword\">fn</span> <span class=\"hljs-title function_\">it_works</span>() {\n        <span class=\"hljs-keyword\">let</span> <span class=\"hljs-keyword\">mut </span><span class=\"hljs-variable\">graph</span> = BTreeMap::<span class=\"hljs-title function_ invoke__\">new</span>();\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">1</span>);\n        <span class=\"hljs-title function_ invoke__\">add_edge</span>(&amp;<span class=\"hljs-keyword\">mut</span> graph, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">1</span>);\n\n        <span class=\"hljs-built_in\">assert_eq!</span>(<span class=\"hljs-title function_ invoke__\">topological_sort</span>(&amp;graph), <span class=\"hljs-built_in\">vec!</span>[<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>]);\n    }\n}\n"
    }
  },
  "contributors": [
    {
      "name": "PalAditya",
      "email": "adityapal.nghss@gmail.com",
      "commits": 1
    },
    {
      "name": "fffzlfk",
      "email": "44939690+fffzlfk@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Connor Bottum",
      "email": "cbb692@gmail.com",
      "commits": 1
    },
    {
      "name": "Niranjan Godbole",
      "email": "niranjan8192@gmail.com",
      "commits": 1
    },
    {
      "name": "Krishna Vedala",
      "email": "7001608+kvedala@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "ttuanho",
      "email": "hhoanhtuann@gmail.com",
      "commits": 1
    },
    {
      "name": "Libin Yang",
      "email": "szuyanglb@outlook.com",
      "commits": 1
    },
    {
      "name": "Mehdi ALAOUI",
      "email": "alaoui.mehdi.1995@gmail.com",
      "commits": 1
    },
    {
      "name": "Carlos Rafael",
      "email": "carlosk2gunn@hotmail.com",
      "commits": 1
    },
    {
      "name": "Eric Lavault",
      "email": "39483232+lvlte@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "Rak Laptudirm",
      "email": "68542775+raklaptudirm@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "PatOnTheBack",
      "email": "51241310+PatOnTheBack@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "ayaankhan98",
      "email": "ayaankhan98@gmail.com",
      "commits": 1
    },
    {
      "name": "Jonathan Taylor",
      "email": "jontaylor091@gmail.com",
      "commits": 1
    },
    {
      "name": "Sarvesh Kumar Dwivedi",
      "email": "georgiansarvesh4396@gmail.com",
      "commits": 1
    },
    {
      "name": "William Zhang",
      "email": "39932068+WilliamHYZhang@users.noreply.github.com",
      "commits": 1
    },
    {
      "name": "cclauss",
      "email": "cclauss@bluewin.ch",
      "commits": 1
    },
    {
      "name": "97arushisharma",
      "email": "97arushisharma@gmail.com",
      "commits": 1
    },
    {
      "name": "Zach Wild",
      "email": "zacharyjwild@gmail.com",
      "commits": 1
    },
    {
      "name": "Christian Clauss",
      "email": "cclauss@me.com",
      "commits": 2
    },
    {
      "name": "vinayak",
      "email": "itssvinayak@gmail.com",
      "commits": 2
    },
    {
      "name": "Abhishek Yadav",
      "email": "31253403+AbhiY98@users.noreply.github.com",
      "commits": 2
    },
    {
      "name": "Filip Hlasek",
      "email": "fhlasek@gmail.com",
      "commits": 4
    }
  ],
  "explanationUrl": {}
}