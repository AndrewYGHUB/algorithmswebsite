{
  "slug": "union-of-two-arrays",
  "name": "Union of Two Arrays",
  "categories": [
    "operationsondatastructures"
  ],
  "body": {},
  "implementations": {
    "c-plus-plus": {
      "dir": "operations_on_datastructures/union_of_two_arrays.cpp",
      "url": "https://github.com/TheAlgorithms/c-plus-plus/tree/master/operations_on_datastructures/union_of_two_arrays.cpp",
      "code": "<span class=\"hljs-comment\">/**\n * @file\n * @brief Implementation for the [Union of two sorted\n * Arrays](https://en.wikipedia.org/wiki/Union_(set_theory))\n * algorithm.\n * @details The Union of two arrays is the collection of all the unique elements\n * in the first array, combined with all of the unique elements of a second\n * array. This implementation uses ordered arrays, and an algorithm to correctly\n * order them and return the result as a new array (vector).\n * @see intersection_of_two_arrays.cpp\n * @author [Alvin](https://github.com/polarvoid)\n */</span>\n\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;algorithm&gt;</span>  <span class=\"hljs-comment\">/// for std::sort</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;cassert&gt;</span>    <span class=\"hljs-comment\">/// for assert</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span>   <span class=\"hljs-comment\">/// for IO operations</span></span>\n<span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span>     <span class=\"hljs-comment\">/// for std::vector</span></span>\n\n<span class=\"hljs-comment\">/**\n * @namespace operations_on_datastructures\n * @brief Operations on Data Structures\n */</span>\n<span class=\"hljs-keyword\">namespace</span> operations_on_datastructures {\n\n<span class=\"hljs-comment\">/**\n * @brief Prints the values of a vector sequentially, ending with a newline\n * character.\n * @param array Reference to the array to be printed\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; &amp;array)</span> </span>{\n    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int32_t</span> i : array) {\n        std::cout &lt;&lt; i &lt;&lt; <span class=\"hljs-string\">&quot; &quot;</span>;  <span class=\"hljs-comment\">/// Print each value in the array</span>\n    }\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;\\n&quot;</span>;  <span class=\"hljs-comment\">/// Print newline</span>\n}\n\n<span class=\"hljs-comment\">/**\n * @brief Gets the union of two sorted arrays, and returns them in a\n * vector.\n * @details An algorithm is used that compares the elements of the two vectors,\n * appending the one that has a lower value, and incrementing the index for that\n * array. If one of the arrays reaches its end, all the elements of the other\n * are appended to the resultant vector.\n * @param first A std::vector of sorted integer values\n * @param second A std::vector of sorted integer values\n * @returns A std::vector of the union of the two arrays, in ascending order\n */</span>\n<span class=\"hljs-function\">std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; <span class=\"hljs-title\">get_union</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; &amp;first,\n                               <span class=\"hljs-type\">const</span> std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; &amp;second)</span> </span>{\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; res;         <span class=\"hljs-comment\">///&lt; Vector to hold the union</span>\n    <span class=\"hljs-type\">size_t</span> f_index = <span class=\"hljs-number\">0</span>;               <span class=\"hljs-comment\">///&lt; Index for the first array</span>\n    <span class=\"hljs-type\">size_t</span> s_index = <span class=\"hljs-number\">0</span>;               <span class=\"hljs-comment\">///&lt; Index for the second array</span>\n    <span class=\"hljs-type\">size_t</span> f_length = first.<span class=\"hljs-built_in\">size</span>();   <span class=\"hljs-comment\">///&lt; Length of first array</span>\n    <span class=\"hljs-type\">size_t</span> s_length = second.<span class=\"hljs-built_in\">size</span>();  <span class=\"hljs-comment\">///&lt; Length of second array</span>\n    <span class=\"hljs-type\">int32_t</span> next = <span class=\"hljs-number\">0</span>;  <span class=\"hljs-comment\">///&lt; Integer to store value of the next element</span>\n\n    <span class=\"hljs-keyword\">while</span> (f_index &lt; f_length &amp;&amp; s_index &lt; s_length) {\n        <span class=\"hljs-keyword\">if</span> (first[f_index] &lt; second[s_index]) {\n            next = first[f_index];  <span class=\"hljs-comment\">///&lt; Append from first array</span>\n            f_index++;              <span class=\"hljs-comment\">///&lt; Increment index of second array</span>\n        } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (first[f_index] &gt; second[s_index]) {\n            next = second[s_index];  <span class=\"hljs-comment\">///&lt; Append from second array</span>\n            s_index++;               <span class=\"hljs-comment\">///&lt; Increment index of second array</span>\n        } <span class=\"hljs-keyword\">else</span> {\n            next = first[f_index];  <span class=\"hljs-comment\">///&lt; Element is the same in both</span>\n            f_index++;              <span class=\"hljs-comment\">///&lt; Increment index of first array</span>\n            s_index++;              <span class=\"hljs-comment\">///&lt; Increment index of second array too</span>\n        }\n        <span class=\"hljs-keyword\">if</span> ((res.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>) || (next != res.<span class=\"hljs-built_in\">back</span>())) {\n            res.<span class=\"hljs-built_in\">push_back</span>(next);  <span class=\"hljs-comment\">///&lt; Add the element if it is unique</span>\n        }\n    }\n    <span class=\"hljs-keyword\">while</span> (f_index &lt; f_length) {\n        next = first[f_index];  <span class=\"hljs-comment\">///&lt; Add remaining elements</span>\n        <span class=\"hljs-keyword\">if</span> ((res.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>) || (next != res.<span class=\"hljs-built_in\">back</span>())) {\n            res.<span class=\"hljs-built_in\">push_back</span>(next);  <span class=\"hljs-comment\">///&lt; Add the element if it is unique</span>\n        }\n        f_index++;\n    }\n    <span class=\"hljs-keyword\">while</span> (s_index &lt; s_length) {\n        next = second[s_index];  <span class=\"hljs-comment\">///&lt; Add remaining elements</span>\n        <span class=\"hljs-keyword\">if</span> ((res.<span class=\"hljs-built_in\">size</span>() == <span class=\"hljs-number\">0</span>) || (next != res.<span class=\"hljs-built_in\">back</span>())) {\n            res.<span class=\"hljs-built_in\">push_back</span>(next);  <span class=\"hljs-comment\">///&lt; Add the element if it is unique</span>\n        }\n        s_index++;\n    }\n    <span class=\"hljs-keyword\">return</span> res;\n}\n\n}  <span class=\"hljs-comment\">// namespace operations_on_datastructures</span>\n\n<span class=\"hljs-comment\">/**\n * @namespace tests\n * @brief Testcases to check Union of Two Arrays.\n */</span>\n<span class=\"hljs-keyword\">namespace</span> tests {\n<span class=\"hljs-keyword\">using</span> operations_on_datastructures::get_union;\n<span class=\"hljs-keyword\">using</span> operations_on_datastructures::print;\n<span class=\"hljs-comment\">/**\n * @brief A Test to check an edge case (two empty arrays)\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST CASE 1\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Intialized a = {} b = {}\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Expected result: {}\\n&quot;</span>;\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; a = {};\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; b = {};\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; result = <span class=\"hljs-built_in\">get_union</span>(a, b);\n    <span class=\"hljs-built_in\">assert</span>(result == a);  <span class=\"hljs-comment\">///&lt; Check if result is empty</span>\n    <span class=\"hljs-built_in\">print</span>(result);        <span class=\"hljs-comment\">///&lt; Should only print newline</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST PASSED!\\n\\n&quot;</span>;\n}\n<span class=\"hljs-comment\">/**\n * @brief A Test to check an edge case (one empty array)\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST CASE 2\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Intialized a = {} b = {2, 3}\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Expected result: {2, 3}\\n&quot;</span>;\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; a = {};\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; b = {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>};\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; result = <span class=\"hljs-built_in\">get_union</span>(a, b);\n    <span class=\"hljs-built_in\">assert</span>(result == b);  <span class=\"hljs-comment\">///&lt; Check if result is equal to b</span>\n    <span class=\"hljs-built_in\">print</span>(result);        <span class=\"hljs-comment\">///&lt; Should print 2 3</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST PASSED!\\n\\n&quot;</span>;\n}\n<span class=\"hljs-comment\">/**\n * @brief A Test to check correct functionality with a simple test case\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test3</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST CASE 3\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Intialized a = {4, 6} b = {2, 3}\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Expected result: {2, 3, 4, 6}\\n&quot;</span>;\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; a = {<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>};\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; b = {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>};\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; result = <span class=\"hljs-built_in\">get_union</span>(a, b);\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; expected = {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>};\n    <span class=\"hljs-built_in\">assert</span>(result == expected);  <span class=\"hljs-comment\">///&lt; Check if result is correct</span>\n    <span class=\"hljs-built_in\">print</span>(result);               <span class=\"hljs-comment\">///&lt; Should print 2 3 4 6</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST PASSED!\\n\\n&quot;</span>;\n}\n<span class=\"hljs-comment\">/**\n * @brief A Test to check correct functionality with duplicate values\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test4</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST CASE 4\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Intialized a = {4, 6, 6, 7} b = {2, 3, 4}\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Expected result: {2, 3, 4, 6, 7}\\n&quot;</span>;\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; a = {<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>};\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; b = {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>};\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; result = <span class=\"hljs-built_in\">get_union</span>(a, b);\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; expected = {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>};\n    <span class=\"hljs-built_in\">assert</span>(result == expected);  <span class=\"hljs-comment\">///&lt; Check if result is correct</span>\n    <span class=\"hljs-built_in\">print</span>(result);               <span class=\"hljs-comment\">///&lt; Should print 2 3 4 6 7</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST PASSED!\\n\\n&quot;</span>;\n}\n<span class=\"hljs-comment\">/**\n * @brief A Test to check correct functionality with a harder test case\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test5</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST CASE 5\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Intialized a = {1, 4, 6, 7, 9} b = {2, 3, 5}\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Expected result: {1, 2, 3, 4, 5, 6, 7, 9}\\n&quot;</span>;\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; a = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">9</span>};\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; b = {<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">5</span>};\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; result = <span class=\"hljs-built_in\">get_union</span>(a, b);\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; expected = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">9</span>};\n    <span class=\"hljs-built_in\">assert</span>(result == expected);  <span class=\"hljs-comment\">///&lt; Check if result is correct</span>\n    <span class=\"hljs-built_in\">print</span>(result);               <span class=\"hljs-comment\">///&lt; Should print 1 2 3 4 5 6 7 9</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST PASSED!\\n\\n&quot;</span>;\n}\n<span class=\"hljs-comment\">/**\n * @brief A Test to check correct functionality with an array sorted using\n * std::sort\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test6</span><span class=\"hljs-params\">()</span> </span>{\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST CASE 6\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Intialized a = {1, 3, 3, 2, 5, 9, 4, 3, 2} &quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;b = {11, 3, 7, 8, 6}\\n&quot;</span>;\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;Expected result: {1, 2, 3, 4, 5, 6, 7, 8, 9, 11}\\n&quot;</span>;\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; a = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">2</span>};\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; b = {<span class=\"hljs-number\">11</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">6</span>};\n    std::<span class=\"hljs-built_in\">sort</span>(a.<span class=\"hljs-built_in\">begin</span>(), a.<span class=\"hljs-built_in\">end</span>());  <span class=\"hljs-comment\">///&lt; Sort vector a</span>\n    std::<span class=\"hljs-built_in\">sort</span>(b.<span class=\"hljs-built_in\">begin</span>(), b.<span class=\"hljs-built_in\">end</span>());  <span class=\"hljs-comment\">///&lt; Sort vector b</span>\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; result = <span class=\"hljs-built_in\">get_union</span>(a, b);\n    std::vector&lt;<span class=\"hljs-type\">int32_t</span>&gt; expected = {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>, <span class=\"hljs-number\">11</span>};\n    <span class=\"hljs-built_in\">assert</span>(result == expected);  <span class=\"hljs-comment\">///&lt; Check if result is correct</span>\n    <span class=\"hljs-built_in\">print</span>(result);               <span class=\"hljs-comment\">///&lt; Should print 1 2 3 4 5 6 7 8 9 11</span>\n    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;TEST PASSED!\\n\\n&quot;</span>;\n}\n}  <span class=\"hljs-comment\">// namespace tests</span>\n\n<span class=\"hljs-comment\">/**\n * @brief Function to test the correctness of get_union() function\n * @returns void\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span> </span>{\n    tests::<span class=\"hljs-built_in\">test1</span>();\n    tests::<span class=\"hljs-built_in\">test2</span>();\n    tests::<span class=\"hljs-built_in\">test3</span>();\n    tests::<span class=\"hljs-built_in\">test4</span>();\n    tests::<span class=\"hljs-built_in\">test5</span>();\n    tests::<span class=\"hljs-built_in\">test6</span>();\n}\n\n<span class=\"hljs-comment\">/**\n * @brief main function\n * @returns 0 on exit\n */</span>\n<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span> </span>{\n    <span class=\"hljs-built_in\">test</span>();  <span class=\"hljs-comment\">// run self-test implementations</span>\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\n}\n"
    }
  },
  "contributors": [
    {
      "name": "Alvin Philips",
      "email": "alvinphilips257@gmail.com",
      "commits": 3
    }
  ],
  "explanationUrl": {}
}